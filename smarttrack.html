<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartTrack - Suivi Intelligent d'Entra√Ænement</title>    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007AFF">
    
    <style>
        /* === VARIABLES CSS === */
        :root {
            --primary: #007AFF;
            --primary-dark: #0056CC;
            --secondary: #34C759;
            --danger: #FF3B30;
            --warning: #FF9500;
            --background: #F2F2F7;
            --surface: #FFFFFF;
            --text-primary: #000000;
            --text-secondary: #6D6D70;
            --border: #C6C6C8;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --background: #1C1C1E;
            --surface: #2C2C2E;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --border: #38383A;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        /* === RESET & BASE === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.5;
            overflow-x: hidden;
        }

        /* === LAYOUT === */
        .app-container {
            max-width: 428px;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--background);
            display: flex;
            flex-direction: column;
        }

        .screen {
            display: none;
            flex: 1;
            padding: 20px;
            animation: slideIn 0.3s ease-out;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* === NAVIGATION === */
        .nav-bar {
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 10px 0;
            display: flex;
            justify-content: space-around;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }

        .nav-item {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 12px;
            transition: color 0.2s;
        }

        .nav-item.active {
            color: var(--primary);
        }

        .nav-item:hover {
            color: var(--primary);
        }

        /* === COMPONENTS === */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
        }

        .card {
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 10px var(--shadow);
            border: 1px solid var(--border);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            display: inline-block;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-success {
            background: var(--secondary);
            color: white;
        }

        .btn-full {
            width: 100%;
            margin-bottom: 12px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .input, .select, .textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 16px;
            background: var(--surface);
            color: var(--text-primary);
            transition: border-color 0.2s;
        }

        .input:focus, .select:focus, .textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .textarea {
            resize: vertical;
            min-height: 80px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .checkbox {
            width: 20px;
            height: 20px;
        }

        /* === CALENDAR GRID === */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin: 16px 0;
            max-height: 120px;
            overflow: hidden;
        }

        .calendar-day {
            aspect-ratio: 1;
            border-radius: 4px;
            background: var(--border);
            opacity: 0.3;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            max-width: 20px;
            max-height: 20px;
        }

        .calendar-day.active {
            opacity: 1;
            background: var(--secondary);
            color: white;
        }

        .calendar-day.high-volume {
            background: var(--primary);
            color: white;
        }

        /* === STATS === */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 16px 0;
        }

        .stat-card {
            background: var(--surface);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* === EXERCISE LIST === */
        .exercise-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: var(--surface);
            border-radius: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--border);
        }

        .exercise-actions {
            display: flex;
            gap: 8px;
        }

        /* === LIVE SESSION === */
        .session-timer {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: var(--primary);
            margin: 24px 0;
        }

        .current-exercise {
            text-align: center;
            margin: 24px 0;
        }

        .exercise-name {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .set-counter {
            font-size: 18px;
            color: var(--text-secondary);
        }

        .performance-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 24px 0;
        }

        .rest-timer {
            text-align: center;
            margin: 24px 0;
        }

        .rest-time {
            font-size: 72px;
            font-weight: 700;
            color: var(--warning);
        }

        .next-exercise {
            background: var(--surface);
            padding: 16px;
            border-radius: 12px;
            margin-top: 16px;
            border: 1px solid var(--border);
        }

        /* === MODAL === */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
        }

        /* === NOTIFICATION === */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 1001;
            display: none;
        }

        .notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { transform: translate(-50%, -100%); }
            to { transform: translate(-50%, 0); }
        }

        /* === CHART CONTAINER === */
        .chart-container {
            height: 300px;
            margin: 20px 0;
            background: var(--surface);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
        }

        /* === RESPONSIVE === */
        @media (max-width: 480px) {
            .app-container {
                max-width: 100%;
            }
            
            .screen {
                padding: 16px;
            }
            
            .performance-inputs {
                grid-template-columns: 1fr;
            }
        }

        /* Styles pour les sections d'exercices (√©chauffement/principal) */
        .exercise-section-title {
            margin: 16px 0 8px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .exercise-section-title.warmup {
            color: var(--warning);
            border-color: var(--warning);
        }

        .exercise-section-title.main {
            color: var(--primary);
            border-color: var(--primary);
        }

        /* Styles pour les boutons de r√©organisation */
        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .reorder-buttons button {
            padding: 2px 6px;
            font-size: 10px;
            min-width: 24px;
            height: 20px;
        }

        .reorder-buttons button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Num√©rotation des exercices */
        .exercise-number {
            background: var(--primary);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        /* Groupes d'exercices dans les mod√®les */
        .exercise-group-title {
            margin: 16px 0 8px 0;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        /* Indicateurs de mode d'exercice */
        .exercise-mode-indicator {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--background);
            color: var(--text-secondary);
            margin-left: 8px;
        }

        /* Style pour les champs conditionnels */
        .conditional-input {
            transition: all 0.3s ease;
        }

        .conditional-input.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- √âcran 0: Tableau de Bord -->
        <div id="screen-dashboard" class="screen active">
            <div class="header">
                <h1>SmartTrack</h1>
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">‚öôÔ∏è</button>
            </div>
            
            <div class="card">
                <h3>Calendrier de R√©gularit√©</h3>
                <div id="calendar-grid" class="calendar-grid"></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-sessions">0</div>
                    <div class="stat-label">S√©ances Total</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="current-streak">0</div>
                    <div class="stat-label">S√©rie Actuelle</div>
                </div>
            </div>
            
            <button class="btn btn-primary btn-full" onclick="actions.startNewSession()">
                üöÄ D√©marrer une s√©ance vide
            </button>
            <button class="btn btn-secondary btn-full" onclick="actions.resumeLastSession()">
                üìã Reprendre la derni√®re s√©ance
            </button>
        </div>

        <!-- √âcran 1: Pr√©paration de S√©ance -->
        <div id="screen-preparation" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('dashboard')">‚Üê Retour</button>
                <h1>Pr√©paration</h1>
                <div></div>
            </div>
            
            <div class="card">
                <div class="input-group">
                    <label>Date de la s√©ance</label>
                    <input type="date" id="session-date" class="input" onchange="actions.updateSessionDate(this.value)">
                </div>
                
                <div class="input-group">
                    <label>Notes de s√©ance</label>
                    <textarea id="session-notes" class="textarea" placeholder="Notes optionnelles..." onchange="actions.updateSessionNotes(this.value)"></textarea>
                </div>
                
                <button class="btn btn-secondary btn-full" onclick="actions.showTemplates()">
                    üìã Charger un mod√®le
                </button>
            </div>
            
            <div class="card">
                <h3>Ajouter un exercice</h3>
                <div class="input-group">
                    <select id="exercise-select" class="select">
                        <option value="">S√©lectionner un exercice...</option>
                    </select>
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.addExerciseToSession()">
                    ‚ûï Ajouter √† la s√©ance
                </button>
            </div>
            
            <div class="card">
                <h3>Exercices pr√©vus</h3>
                <div id="planned-exercises"></div>
            </div>
            
            <button class="btn btn-success btn-full" onclick="actions.startLiveSession()" id="start-live-btn" style="display: none;">
                üöÄ D√©marrer la S√©ance Live
            </button>

            <button class="btn btn-secondary btn-full" onclick="actions.saveSessionManually()" id="save-manual-btn" style="display: none;">
                üíæ Sauvegarder sans Live
            </button>
        </div>

        <!-- √âcran 2: S√©ance Live -->
        <div id="screen-live" class="screen">
            <div class="header">
                <button class="btn btn-small btn-danger" onclick="actions.stopLiveSession()">‚èπÔ∏è Arr√™ter</button>
                <div class="session-timer" id="live-timer">00:00</div>
                <div></div>
            </div>
            
            <div id="live-content"></div>
        </div>

        <!-- √âcran 3: Historique -->
        <div id="screen-history" class="screen">
            <div class="header">
                <h1>Historique</h1>
                <div class="stat-value" id="history-count">0</div>
            </div>
            
            <div id="sessions-list"></div>
        </div>

        <!-- √âcran 4: Statistiques -->
        <div id="screen-stats" class="screen">
            <div class="header">
                <h1>Statistiques</h1>
            </div>
            
            <div class="card">
                <div class="input-group">
                    <label>S√©lectionner un exercice</label>
                    <select id="stats-exercise-select" class="select" onchange="actions.updateStats(this.value)">
                        <option value="">Choisir un exercice...</option>
                    </select>
                </div>
            </div>
            
            <div id="stats-content"></div>
        </div>

        <!-- √âcran 5: Suivi Corporel -->
        <div id="screen-body" class="screen">
            <div class="header">
                <h1>Mensurations</h1>
            </div>
            
            <div class="card">
                <h3>Nouvelle mensuration</h3>
                <div class="input-group">
                    <label>Date</label>
                    <input type="date" id="measurement-date" class="input">
                </div>
                <div class="input-group">
                    <label>Poids (kg)</label>
                    <input type="number" id="measurement-weight" class="input" step="0.1">
                </div>
                <div class="input-group">
                    <label>Tour de taille (cm)</label>
                    <input type="number" id="measurement-waist" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de poitrine (cm)</label>
                    <input type="number" id="measurement-chest" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de bras (cm)</label>
                    <input type="number" id="measurement-arm" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de cuisse (cm)</label>
                    <input type="number" id="measurement-thigh" class="input" step="0.5">
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.addMeasurement()">
                    ‚ûï Ajouter la mensuration
                </button>
            </div>
            
            <div class="card">
                <h3>√âvolution des mensurations</h3>
                <div class="chart-container">
                    üìä Graphiques d'√©volution des mensurations
                </div>
            </div>
            
            <div id="measurements-list"></div>
        </div>

        <!-- √âcran 6: Gestion des Exercices -->
        <div id="screen-exercises" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">‚Üê Retour</button>
                <h1>Exercices</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3 id="exercise-form-title">Nouvel exercice</h3>
                
                <div class="input-group">
                    <label>Nom de l'exercice</label>
                    <input type="text" id="exercise-name" class="input" placeholder="Ex: D√©velopp√© couch√©">
                </div>
                
                <!-- NOUVEAU: Cat√©gorie principale -->
                <div class="input-group">
                    <label>Cat√©gorie</label>
                    <select id="exercise-category" class="select">
                        <option value="strength">Renforcement</option>
                        <option value="warmup">√âchauffement</option>
                    </select>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="exercise-unilateral" class="checkbox">
                    <label for="exercise-unilateral">Exercice unilat√©ral</label>
                </div>
                
                <!-- NOUVEAU: Mode d'exercice -->
                <div class="input-group">
                    <label>Mode d'ex√©cution</label>
                    <select id="exercise-mode" class="select" onchange="toggleExerciseMode()">
                        <option value="reps">R√©p√©titions</option>
                        <option value="time">Temps</option>
                        <option value="both">R√©p√©titions ou Temps</option>
                    </select>
                </div>
                
                <!-- NOUVEAU: Dur√©e par d√©faut (affich√© si mode temps) -->
                <div class="input-group" id="duration-group" style="display: none;">
                    <label>Dur√©e par d√©faut (secondes)</label>
                    <input type="number" id="exercise-duration" class="input" value="30" min="10" max="300">
                </div>
                
                <div class="input-group">
                    <label>Temps de repos par d√©faut (secondes)</label>
                    <input type="number" id="exercise-rest" class="input" value="90">
                </div>
                
                <div class="input-group">
                    <label>Groupe musculaire</label>
                    <select id="exercise-muscle-group" class="select">
                        <option value="echauffement">√âchauffement</option>
                        <option value="biceps">Biceps</option>
                        <option value="triceps">Triceps</option>
                        <option value="epaules">√âpaules</option>
                        <option value="dos">Dos</option>
                        <option value="pectoraux">Pectoraux</option>
                        <option value="jambes">Jambes</option>
                        <option value="autres">Autres</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Point d'ancrage</label>
                    <select id="exercise-anchor" class="select" onchange="showExerciseExamples(this.value)">
                        <option value="none">üèÉ Sans ancrage (√©lastique libre)</option>
                        <option value="door-middle">üö™ Porte - hauteur moyenne</option>
                        <option value="door-high">üö™‚¨ÜÔ∏è Porte - position haute</option>
                        <option value="door-low">üö™‚¨áÔ∏è Porte - position basse</option>
                        <option value="floor">ü¶µ Sol/Pieds (marcher dessus)</option>
                        <option value="body">üîÑ Corps (√©lastique autour)</option>
                        <option value="external">üå≥ Ancrage ext√©rieur</option>
                    </select>
                    <div id="exercise-examples" style="margin-top: 8px; padding: 8px; background: var(--background); border-radius: 6px; font-size: 12px; color: var(--text-secondary); display: none;">
                        <strong>Exemples d'exercices :</strong>
                        <div id="examples-list"></div>
                    </div>
                </div>
                
                <button class="btn btn-primary btn-full" onclick="actions.saveExercise()" id="save-exercise-btn">
                    ‚ûï Ajouter l'exercice
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.loadPredefinedExercises()" id="load-predefined-btn">
                    üìö Charger les exercices SmartWorkout
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.cancelExerciseEdit()" id="cancel-exercise-btn" style="display: none;">
                    ‚ùå Annuler
                </button>
            </div>
            
            <div class="card">
                <h3>Mes exercices</h3>
                <div id="exercises-list"></div>
            </div>
        </div>

        <!-- √âcran 7: Gestion des Mod√®les -->
        <div id="screen-templates" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">‚Üê Retour</button>
                <h1>Mod√®les</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3>Nouveau mod√®le</h3>
                <div class="input-group">
                    <label>Nom du mod√®le</label>
                    <input type="text" id="template-name" class="input" placeholder="Ex: Push Day">
                </div>
                <div class="input-group">
                    <label>Exercices</label>
                    <div id="template-exercises-checkboxes"></div>
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.saveTemplate()">
                    ‚ûï Cr√©er le mod√®le
                </button>
            </div>
            
            <div class="card">
                <h3>Mes mod√®les</h3>
                <div id="templates-list"></div>
            </div>
        </div>

        <!-- √âcran 8: Param√®tres -->
        <div id="screen-settings" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('dashboard')">‚Üê Retour</button>
                <h1>Param√®tres</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3>Apparence</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="dark-theme" class="checkbox" onchange="actions.toggleTheme()">
                    <label for="dark-theme">Th√®me sombre</label>
                </div>
            </div>
            
            <div class="card">
                <h3>Donn√©es</h3>
                <button class="btn btn-secondary btn-full" onclick="actions.exportData()">
                    üì§ Exporter les donn√©es
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.showImportModal()">
                    üì• Importer les donn√©es
                </button>
                <button class="btn btn-danger btn-full" onclick="actions.clearAllData()">
                    üóëÔ∏è Effacer toutes les donn√©es
                </button>
            </div>
            
            <div class="card">
                <h3>Gestion</h3>
                <button class="btn btn-secondary btn-full" onclick="actions.showScreen('exercises')">
                    üí™ G√©rer les exercices
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.showScreen('templates')">
                    üìã G√©rer les mod√®les
                </button>
            </div>
        </div>

        <!-- √âcran 9: Saisie Manuelle -->
        <div id="screen-manual-entry" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('preparation')">‚Üê Retour</button>
                <h1>Saisie Manuelle</h1>
                <div></div>
            </div>
            
            <div id="manual-entry-content"></div>
        </div>

        <!-- Navigation -->
        <nav class="nav-bar">
            <div class="nav-item active" onclick="actions.showScreen('dashboard')">
                <div>üè†</div>
                <div>Accueil</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('preparation')">
                <div>‚ö°</div>
                <div>S√©ance</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('history')">
                <div>üìä</div>
                <div>Historique</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('stats')">
                <div>üìà</div>
                <div>Stats</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('body')">
                <div>‚öñÔ∏è</div>
                <div>Corporel</div>
            </div>
        </nav>
    </div>

    <!-- Modals -->
    <div id="templates-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Charger un mod√®le</h3>
                <button class="close-btn" onclick="actions.closeModal('templates-modal')">&times;</button>
            </div>
            <div id="templates-modal-content"></div>
        </div>
    </div>

    <div id="import-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Importer des donn√©es</h3>
                <button class="close-btn" onclick="actions.closeModal('import-modal')">&times;</button>
            </div>
            <div class="input-group">
                <label>Donn√©es JSON</label>
                <textarea id="import-data" class="textarea" rows="10" placeholder="Collez vos donn√©es JSON ici..."></textarea>
            </div>
            <button class="btn btn-primary btn-full" onclick="actions.importData()">
                üì• Importer
            </button>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <script>
        // === BASE DE DONN√âES DES √âLASTIQUES SMARTWORKOUT ELITE ===
        const ELASTICS_DB = {
            cyan: { name: 'Cyan', resistance: 25, color: '#00FFFF', quantity: 3 },
            black: { name: 'Noir', resistance: 20, color: '#000000', quantity: 3 },
            blue: { name: 'Bleu', resistance: 15, color: '#0000FF', quantity: 1 },
            green: { name: 'Vert', resistance: 10, color: '#00FF00', quantity: 1 },
            beige: { name: 'Beige', resistance: 5, color: '#F5F5DC', quantity: 1 }
        };

        // Base de donn√©es des exercices pr√©-d√©finis SmartWorkout
        const PREDEFINED_EXERCISES = {
            echauffement: [
                { name: 'Jumping Jacks', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Mont√©es de genoux', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Talons-fesses', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Burpees', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Planche', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Planche lat√©rale', anchor: 'none', unilateral: true, timeBase: true },
                { name: 'Mountain climbers', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Squats au poids du corps', anchor: 'none', unilateral: false, timeBase: false },
                { name: 'Pompes', anchor: 'none', unilateral: false, timeBase: false },
                { name: 'Fentes altern√©es', anchor: 'none', unilateral: true, timeBase: false },
                { name: 'Rotations √©paules', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Cercles de bras', anchor: 'none', unilateral: false, timeBase: true },
                { name: '√âtirements dynamiques', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'High knees', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Pas chass√©s', anchor: 'none', unilateral: false, timeBase: true }
            ],
            
            biceps: [
                { name: 'Curl biceps', anchor: 'none', unilateral: false },
                { name: 'Curl biceps (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Curl biceps face √† la porte', anchor: 'door-middle', unilateral: false },
                { name: 'Curl marteau', anchor: 'none', unilateral: false },
                { name: 'Curl marteau (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Curl biceps avec poign√©e', anchor: 'none', unilateral: false },
                { name: 'Curl biceps en pronation', anchor: 'none', unilateral: false }
            ],
            epaules: [
                { name: 'Cuban press', anchor: 'none', unilateral: false },
                { name: 'D√©velopp√© arnold', anchor: 'none', unilateral: false },
                { name: 'D√©velopp√© militaire assis', anchor: 'floor', unilateral: false },
                { name: '√âl√©vations frontales', anchor: 'none', unilateral: false },
                { name: '√âl√©vations lat√©rales', anchor: 'none', unilateral: false },
                { name: 'Oiseau', anchor: 'door-middle', unilateral: false },
                { name: 'Overhead press', anchor: 'none', unilateral: false },
                { name: 'Reverse fly', anchor: 'door-middle', unilateral: false },
                { name: 'Reverse fly unilat√©ral', anchor: 'door-middle', unilateral: true },
                { name: 'Shrug', anchor: 'none', unilateral: false },
                { name: 'Tirage menton', anchor: 'door-low', unilateral: false }
            ],
            dos: [
                { name: 'Face Pull', anchor: 'door-middle', unilateral: false },
                { name: 'Face pull (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Pull-Over', anchor: 'door-high', unilateral: false },
                { name: 'Rowing buste pench√©', anchor: 'floor', unilateral: false },
                { name: 'Rowing buste pench√© (prise large)', anchor: 'floor', unilateral: false },
                { name: 'Rowing buste pench√© (prise serr√©e)', anchor: 'floor', unilateral: false },
                { name: 'Soulev√© de terre', anchor: 'floor', unilateral: false },
                { name: 'Soulev√© de terre (prise large)', anchor: 'floor', unilateral: false },
                { name: 'Tirage Bucheron (poulie basse)', anchor: 'door-low', unilateral: true },
                { name: 'Tirage horizontal unilat√©ral', anchor: 'door-middle', unilateral: true },
                { name: 'Tirage poulie basse', anchor: 'door-low', unilateral: false },
                { name: 'Tirage poulie basse (supination)', anchor: 'door-low', unilateral: false },
                { name: 'Tirage vertical', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical (prise serr√©e)', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical (supination)', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical unilat√©ral', anchor: 'door-high', unilateral: true }
            ],
            jambes: [
                { name: 'Abduction de hanches', anchor: 'body', unilateral: false },
                { name: 'Adduction de hanches', anchor: 'body', unilateral: false },
                { name: 'Donkey kick', anchor: 'body', unilateral: true },
                { name: 'Donkey kick (jambes fl√©chies)', anchor: 'body', unilateral: true },
                { name: 'Extensions mollets', anchor: 'floor', unilateral: false },
                { name: 'Extensions mollets unilat√©rales', anchor: 'floor', unilateral: true },
                { name: 'Fentes', anchor: 'none', unilateral: true },
                { name: 'Fentes bulgares', anchor: 'none', unilateral: true },
                { name: 'Front squat', anchor: 'floor', unilateral: false },
                { name: 'Hip thrust', anchor: 'body', unilateral: false },
                { name: 'Leg curl', anchor: 'body', unilateral: false },
                { name: 'Leg extension unilat√©rale', anchor: 'body', unilateral: true },
                { name: 'Soulev√© de terre jambes tendues', anchor: 'floor', unilateral: false },
                { name: 'Squat', anchor: 'none', unilateral: false },
                { name: 'Squat sumo', anchor: 'floor', unilateral: false },
                { name: 'Squat swing', anchor: 'none', unilateral: false },
                { name: 'Thruster', anchor: 'floor', unilateral: false }
            ],
            pectoraux: [
                { name: 'D√©velopp√© √©paules debout', anchor: 'none', unilateral: false },
                { name: 'D√©velopp√© debout (poulie moyenne)', anchor: 'door-middle', unilateral: false },
                { name: 'D√©velopp√© debout (2 ancrages)', anchor: 'door-middle', unilateral: false },
                { name: 'D√©velopp√© d√©clin√©', anchor: 'door-low', unilateral: false },
                { name: 'D√©velopp√© inclin√©', anchor: 'door-high', unilateral: false },
                { name: 'D√©velopp√© inclin√© (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'D√©velopp√© joint (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'D√©velopp√© joint (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'D√©velopp√© 1 ancrage (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'D√©velopp√© joint (poulie moyenne)', anchor: 'door-middle', unilateral: false },
                { name: '√âcart√© unilat√©ral', anchor: 'door-middle', unilateral: true },
                { name: '√âcart√© unilat√©ral (poulie basse)', anchor: 'door-low', unilateral: true },
                { name: '√âcart√© unilat√©ral (poulie haute)', anchor: 'door-high', unilateral: true },
                { name: 'Pompes lest√©es', anchor: 'body', unilateral: false }
            ],
            triceps: [
                { name: 'Triceps barre au front', anchor: 'door-high', unilateral: false },
                { name: 'Extension triceps (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'Extension triceps verticale', anchor: 'none', unilateral: false },
                { name: 'Extension triceps verticale (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Kickback triceps (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Kickback triceps unilat√©ral', anchor: 'door-low', unilateral: true }
            ]
        };

        class ExerciseTimer {
            constructor() {
                this.duration = 0;
                this.timeLeft = 0;
                this.isRunning = false;
                this.isPaused = false;
                this.interval = null;
                this.audioContext = null;
                this.onTick = null;
                this.onComplete = null;
                
                // Initialiser le contexte audio
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio non support√©');
                }
            }
            
            // Configurer le timer
            setup(duration, onTick, onComplete) {
                this.duration = duration;
                this.timeLeft = duration;
                this.onTick = onTick;
                this.onComplete = onComplete;
                this.isRunning = false;
                this.isPaused = false;
                
                if (this.interval) {
                    clearInterval(this.interval);
                }
            }
            
            // D√©marrer le timer
            start() {
                if (this.isRunning && !this.isPaused) return;
                
                this.isRunning = true;
                this.isPaused = false;
                
                this.interval = setInterval(() => {
                    if (this.timeLeft > 0) {
                        this.timeLeft--;
                        
                        // Appeler la fonction de mise √† jour
                        if (this.onTick) {
                            this.onTick(this.timeLeft, this.duration);
                        }
                        
                        // Alertes sonores
                        if (this.timeLeft === 5 || this.timeLeft === 3 || this.timeLeft === 1) {
                            this.playBeep(800, 200);
                        }
                        
                        // Vibration dans les derni√®res secondes
                        if (this.timeLeft <= 3 && 'vibrate' in navigator) {
                            navigator.vibrate(100);
                        }
                        
                    } else {
                        // Timer termin√©
                        this.complete();
                    }
                }, 1000);
            }
            
            // Mettre en pause
            pause() {
                this.isPaused = true;
                if (this.interval) {
                    clearInterval(this.interval);
                }
            }
            
            // Arr√™ter compl√®tement
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.interval) {
                    clearInterval(this.interval);
                }
                this.timeLeft = this.duration;
            }
            
            // Timer termin√©
            complete() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.interval) {
                    clearInterval(this.interval);
                }
                
                // Son de fin plus long
                this.playBeep(1000, 500);
                
                // Vibration de fin
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200]);
                }
                
                // Appeler la fonction de completion
                if (this.onComplete) {
                    this.onComplete();
                }
            }
            
            // Jouer un bip sonore
            playBeep(frequency = 800, duration = 200) {
                if (!this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (e) {
                    console.log('Erreur audio:', e);
                }
            }
            
            // Formater le temps MM:SS
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Ajouter du temps
            addTime(seconds) {
                this.timeLeft += seconds;
                this.duration += seconds;
                if (this.onTick) {
                    this.onTick(this.timeLeft, this.duration);
                }
            }
            
            // Enlever du temps
            removeTime(seconds) {
                this.timeLeft = Math.max(0, this.timeLeft - seconds);
                if (this.timeLeft === 0) {
                    this.complete();
                } else if (this.onTick) {
                    this.onTick(this.timeLeft, this.duration);
                }
            }
        }

        // Instance globale du timer
        let exerciseTimer = new ExerciseTimer();

        // Fonctions globales pour contr√¥ler le timer
        function startExerciseTimer() {
            exerciseTimer.start();
            updateTimerButtons();
        }

        function pauseExerciseTimer() {
            exerciseTimer.pause();
            updateTimerButtons();
        }

        function stopExerciseTimer() {
            exerciseTimer.stop();
            updateTimerButtons();
            // Remettre l'affichage par d√©faut
            const timerDisplay = document.getElementById('exercise-timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = exerciseTimer.formatTime(exerciseTimer.duration);
                timerDisplay.style.color = 'var(--primary)';
            }
        }

        function addExerciseTime() {
            exerciseTimer.addTime(10); // Ajouter 10 secondes
        }

        function removeExerciseTime() {
            exerciseTimer.removeTime(10); // Enlever 10 secondes
        }

        function updateTimerButtons() {
            const startBtn = document.getElementById('timer-start-btn');
            const pauseBtn = document.getElementById('timer-pause-btn');
            const stopBtn = document.getElementById('timer-stop-btn');
            
            if (startBtn && pauseBtn && stopBtn) {
                if (exerciseTimer.isRunning && !exerciseTimer.isPaused) {
                    startBtn.style.display = 'none';
                    pauseBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'inline-block';
                } else if (exerciseTimer.isPaused) {
                    startBtn.style.display = 'inline-block';
                    pauseBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    startBtn.style.display = 'inline-block';
                    pauseBtn.style.display = 'none';
                    stopBtn.style.display = 'none';
                }
            }
        }

        // Fonction pour g√©n√©rer l'interface du timer
        function generateTimerInterface(exercise, prefix = '') {
            const defaultDuration = exercise.default_duration || 30;
            
            return `
                <div class="exercise-timer-container" style="text-align: center; margin: 20px 0; padding: 20px; background: var(--surface); border-radius: 16px; border: 2px solid var(--primary);">
                    <h3 style="margin-bottom: 16px; color: var(--primary);">‚è±Ô∏è Timer d'exercice</h3>
                    
                    <!-- Affichage du timer -->
                    <div id="exercise-timer-display" style="font-size: 48px; font-weight: bold; color: var(--primary); margin: 16px 0;">
                        ${exerciseTimer.formatTime(defaultDuration)}
                    </div>
                    
                    <!-- Contr√¥les de temps -->
                    <div style="display: flex; justify-content: center; gap: 8px; margin: 16px 0;">
                        <button class="btn btn-small btn-secondary" onclick="removeExerciseTime()" style="font-size: 18px; padding: 8px 12px;">-10s</button>
                        <input type="number" id="${prefix}duration" class="input" value="${defaultDuration}" min="10" max="300" 
                            style="width: 80px; text-align: center; font-weight: bold;" 
                            onchange="setupTimerDuration(this.value)">
                        <button class="btn btn-small btn-secondary" onclick="addExerciseTime()" style="font-size: 18px; padding: 8px 12px;">+10s</button>
                    </div>
                    
                    <!-- Boutons de contr√¥le -->
                    <div style="display: flex; justify-content: center; gap: 12px; margin: 16px 0;">
                        <button id="timer-start-btn" class="btn btn-success" onclick="startExerciseTimer()" style="display: inline-block;">
                            ‚ñ∂Ô∏è Start
                        </button>
                        <button id="timer-pause-btn" class="btn btn-warning" onclick="pauseExerciseTimer()" style="display: none;">
                            ‚è∏Ô∏è Pause
                        </button>
                        <button id="timer-stop-btn" class="btn btn-danger" onclick="stopExerciseTimer()" style="display: none;">
                            ‚èπÔ∏è Stop
                        </button>
                    </div>
                    
                    <!-- Indicateur de progression -->
                    <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin: 16px 0;">
                        <div id="timer-progress" style="height: 100%; background: var(--primary); width: 100%; transition: width 1s linear;"></div>
                    </div>
                    
                    <p style="font-size: 14px; color: var(--text-secondary); margin-top: 12px;">
                        üîî Sons et vibrations activ√©s ‚Ä¢ Validation automatique
                    </p>
                </div>
            `;
        }

        // Fonction pour configurer la dur√©e du timer
        function setupTimerDuration(newDuration) {
            const duration = parseInt(newDuration) || 30;
            const timerDisplay = document.getElementById('exercise-timer-display');
            
            if (timerDisplay && !exerciseTimer.isRunning) {
                exerciseTimer.setup(
                    duration,
                    updateTimerDisplay,
                    completeTimedExercise
                );
                timerDisplay.textContent = exerciseTimer.formatTime(duration);
                updateTimerProgress(duration, duration);
            }
        }

        // Fonction pour mettre √† jour l'affichage du timer
        function updateTimerDisplay(timeLeft, totalDuration) {
            const timerDisplay = document.getElementById('exercise-timer-display');
            
            if (timerDisplay) {
                timerDisplay.textContent = exerciseTimer.formatTime(timeLeft);
                
                // Changer la couleur selon le temps restant
                if (timeLeft <= 5) {
                    timerDisplay.style.color = 'var(--danger)';
                } else if (timeLeft <= 10) {
                    timerDisplay.style.color = 'var(--warning)';
                } else {
                    timerDisplay.style.color = 'var(--primary)';
                }
            }
            
            // Mettre √† jour la barre de progression
            updateTimerProgress(timeLeft, totalDuration);
        }

        // Fonction pour mettre √† jour la barre de progression
        function updateTimerProgress(timeLeft, totalDuration) {
            const progressBar = document.getElementById('timer-progress');
            if (progressBar) {
                const percentage = (timeLeft / totalDuration) * 100;
                progressBar.style.width = percentage + '%';
                
                // Changer la couleur de la barre selon le temps restant
                if (timeLeft <= 5) {
                    progressBar.style.background = 'var(--danger)';
                } else if (timeLeft <= 10) {
                    progressBar.style.background = 'var(--warning)';
                } else {
                    progressBar.style.background = 'var(--primary)';
                }
            }
        }

        // Fonction appel√©e quand le timer se termine
        function completeTimedExercise() {
            // Validation automatique de la s√©rie
            setTimeout(() => {
                if (confirm('‚è∞ Temps √©coul√© ! Valider cette s√©rie automatiquement ?')) {
                    // Remplir automatiquement la dur√©e
                    const durationInput = document.getElementById('duration');
                    if (durationInput) {
                        durationInput.value = exerciseTimer.duration;
                    }
                    
                    // Valider la s√©rie
                    actions.validateSet();
                }
            }, 500); // Petit d√©lai pour que l'utilisateur entende le son
        }

        // === FONCTIONS UTILITAIRES √âLASTIQUES ===

        // Fonction pour toggle le mode d'exercice dans le formulaire
        function toggleExerciseMode() {
            const mode = document.getElementById('exercise-mode').value;
            const durationGroup = document.getElementById('duration-group');
            
            if (mode === 'time' || mode === 'both') {
                durationGroup.style.display = 'block';
            } else {
                durationGroup.style.display = 'none';
            }
        }

        // Fonction pour toggle entre temps et r√©p√©titions dans les s√©ances
        function togglePerformanceMode(prefix = '') {
            const mode = document.getElementById(`${prefix}execution-mode`).value;
            const repsInputs = document.querySelectorAll(`[id*="${prefix}reps-inputs"]`);
            const timerContainer = document.getElementById(`${prefix}timer-container`);
            
            // Arr√™ter le timer si il √©tait en cours
            if (exerciseTimer.isRunning) {
                exerciseTimer.stop();
            }
            
            if (mode === 'time') {
                // Masquer les inputs de r√©p√©titions
                repsInputs.forEach(input => {
                    if (input) input.style.display = 'none';
                });
                
                // Afficher le timer
                if (timerContainer) {
                    timerContainer.style.display = 'block';
                    
                    // Configurer le timer apr√®s un court d√©lai
                    setTimeout(() => {
                        const defaultDuration = 30; // Valeur par d√©faut
                        exerciseTimer.setup(
                            defaultDuration,
                            updateTimerDisplay,
                            completeTimedExercise
                        );
                        
                        // Mettre √† jour l'affichage initial
                        const timerDisplay = document.getElementById('exercise-timer-display');
                        if (timerDisplay) {
                            timerDisplay.textContent = exerciseTimer.formatTime(defaultDuration);
                        }
                        updateTimerButtons();
                    }, 100);
                }
            } else {
                // Afficher les inputs de r√©p√©titions
                repsInputs.forEach(input => {
                    if (input) input.style.display = 'block';
                });
                
                // Masquer le timer
                if (timerContainer) {
                    timerContainer.style.display = 'none';
                }
            }
        }

        // Fonction pour cr√©er un item d'exercice avec r√©organisation
        function createExerciseItem(exerciseData, sectionIndex, section) {
            const { exercise, planned_sets, originalIndex } = exerciseData;
            
            const div = document.createElement('div');
            div.className = 'exercise-item';
            
            // Indicateur du mode d'exercice
            const modeIcon = exercise.exercise_mode === 'time' ? '‚è±Ô∏è' : 
                            exercise.exercise_mode === 'both' ? 'üîÑ' : 'üî¢';
            
            // Informations sur l'exercice
            let exerciseInfo = `${exercise.is_unilateral ? 'Unilat√©ral' : 'Bilat√©ral'} ‚Ä¢ ${exercise.default_rest_time}s repos`;
            if (exercise.exercise_mode === 'time') {
                exerciseInfo += ` ‚Ä¢ ${exercise.default_duration || 30}s par d√©faut`;
            }
            
            // Calculer si on peut monter/descendre
            const isFirst = sectionIndex === 0;
            const totalInSection = section === 'warmup' ? 
                appState.currentSession.exercises.filter(ex => {
                    const e = appState.exercises.find(e => e.id === ex.exercise_id);
                    return e && (e.muscle_group === 'echauffement' || e.category === 'warmup');
                }).length :
                appState.currentSession.exercises.filter(ex => {
                    const e = appState.exercises.find(e => e.id === ex.exercise_id);
                    return e && e.muscle_group !== 'echauffement' && e.category !== 'warmup';
                }).length;
            const isLast = sectionIndex === totalInSection - 1;
            
            div.innerHTML = `
                <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span class="exercise-number">${sectionIndex + 1}</span>
                        <strong>${modeIcon} ${exercise.name}</strong>
                    </div>
                    <div style="font-size: 14px; color: var(--text-secondary); margin-left: 32px;">
                        ${exerciseInfo}
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="number" value="${planned_sets}" min="1" max="20"
                        style="width: 60px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px;"
                        onchange="actions.updatePlannedSets(${exercise.id}, this.value)">
                    <span style="font-size: 14px;">s√©ries</span>
                    <div class="reorder-buttons">
                        <button class="btn btn-small btn-secondary" onclick="actions.moveExerciseUp(${originalIndex}, 'session')" 
                            ${isFirst ? 'disabled' : ''}>‚Üë</button>
                        <button class="btn btn-small btn-secondary" onclick="actions.moveExerciseDown(${originalIndex}, 'session')" 
                            ${isLast ? 'disabled' : ''}>‚Üì</button>
                    </div>
                    <button class="btn btn-small btn-danger" onclick="actions.removeExerciseFromSession(${exercise.id})">‚úï</button>
                </div>
            `;
            
            return div;
        }

        // Fonction pour calculer la r√©sistance totale
        function calculateTotalResistance(selectedElastics) {
            let total = 0;
            Object.keys(selectedElastics).forEach(color => {
                const count = selectedElastics[color] || 0;
                if (ELASTICS_DB[color] && count > 0) {
                    total += ELASTICS_DB[color].resistance * count;
                }
            });
            return total;
        }

        // Fonction pour g√©n√©rer le s√©lecteur d'√©lastiques
        function generateElasticSelector(prefix = '') {
            let html = '<div class="elastics-selector" style="margin: 16px 0;">';
            html += '<h4>Combinaison d\'√©lastiques</h4>';
            html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
            
            Object.keys(ELASTICS_DB).forEach(color => {
                const elastic = ELASTICS_DB[color];
                html += `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="width: 20px; height: 20px; background: ${elastic.color}; border-radius: 50%; border: 1px solid #ccc;"></div>
                        <div style="flex: 1; font-size: 14px;">${elastic.name} (${elastic.resistance}kg)</div>
                        <select id="${prefix}elastic-${color}" class="select" style="width: 60px; padding: 4px;" onchange="updateResistanceDisplay('${prefix}')">
                `;
                
                for (let i = 0; i <= elastic.quantity; i++) {
                    html += `<option value="${i}">${i}</option>`;
                }
                
                html += '</select></div>';
            });
            
            html += '</div>';
            html += `<div style="margin-top: 12px; padding: 8px; background: var(--primary); color: white; border-radius: 8px; text-align: center; font-weight: bold;">
                R√©sistance totale: <span id="${prefix}total-resistance">0</span> kg
            </div>`;
            html += '</div>';
            
            return html;
        }

        // Fonction pour mettre √† jour l'affichage de la r√©sistance
        function updateResistanceDisplay(prefix = '') {
            const selectedElastics = {};
            Object.keys(ELASTICS_DB).forEach(color => {
                const selectElement = document.getElementById(`${prefix}elastic-${color}`);
                if (selectElement) {
                    selectedElastics[color] = parseInt(selectElement.value) || 0;
                }
            });
            
            const total = calculateTotalResistance(selectedElastics);
            const totalElement = document.getElementById(`${prefix}total-resistance`);
            if (totalElement) {
                totalElement.textContent = total;
            }
            
            return { selectedElastics, total };
        }

        // Fonction pour charger les exercices pr√©-d√©finis
        function loadPredefinedExercises() {
            const exercisesToAdd = [];
            
            Object.keys(PREDEFINED_EXERCISES).forEach(category => {
                PREDEFINED_EXERCISES[category].forEach(ex => {
                    exercisesToAdd.push({
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        name: ex.name,
                        is_unilateral: ex.unilateral,
                        default_rest_time: 90,
                        exercise_type: 'elastics',
                        anchor_point: ex.anchor,
                        muscle_group: category
                    });
                });
            });
            
            return exercisesToAdd;
        }

        // Fonction pour afficher les exemples d'exercices
        function showExerciseExamples(anchorType) {
            const examplesContainer = document.getElementById('exercise-examples');
            const examplesList = document.getElementById('examples-list');
            
            if (anchorType && examplesList) {
                const examples = {
                    'none': ['Biceps curls', '√âl√©vations lat√©rales', 'Squats', 'Overhead press'],
                    'door-middle': ['Face Pull', 'D√©velopp√© debout', 'Rowing horizontal'],
                    'door-high': ['Tirage vertical', 'Extension triceps', 'D√©velopp√© inclin√©'],
                    'door-low': ['Tirage poulie basse', 'Curl biceps', 'D√©velopp√© d√©clin√©'],
                    'floor': ['Soulev√© de terre', 'Rowing buste pench√©', 'Front squat'],
                    'body': ['Hip thrust', 'Abduction hanches', 'Donkey kick'],
                    'external': ['Exercices ext√©rieurs', 'Sprints r√©sistance']
                };
                
                if (examples[anchorType]) {
                    examplesList.innerHTML = examples[anchorType].join(', ');
                    examplesContainer.style.display = 'block';
                } else {
                    examplesContainer.style.display = 'none';
                }
            }
        }

        // === ARCHITECTURE R√âACTIVE: √âTAT CENTRAL ===
        let appState = {
            currentScreen: 'dashboard',
            currentSession: null,
            liveSession: null,
            editingExercise: null,
            exercises: [],
            sessions: [],
            templates: [],
            measurements: [],
            records: {},
            settings: {
                theme: 'light'
            }
        };

        // === STOCKAGE LOCAL AVEC VERSIONING ===
        const STORAGE_VERSION = 'v1';
        const STORAGE_PREFIX = `smarttrack_${STORAGE_VERSION}_`;

        const storage = {
            isAvailable() {
                try {
                const test = '__storage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
                } catch (e) {
                return false;
                }
            },
            
            save(key, data) {
                if (!this.isAvailable()) {
                console.warn('localStorage non disponible');
                return false;
                }
                try {
                localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(data));
                return true;
                } catch (e) {
                console.error('Erreur de sauvegarde:', e);
                return false;
                }
            },
            
            load(key, defaultValue = null) {
                if (!this.isAvailable()) {
                return defaultValue;
                }
                try {
                const item = localStorage.getItem(STORAGE_PREFIX + key);
                return item ? JSON.parse(item) : defaultValue;
                } catch (e) {
                console.error('Erreur de chargement:', e);
                return defaultValue;
                }
            },
            
            remove(key) {
                if (!this.isAvailable()) {
                return false;
                }
                try {
                localStorage.removeItem(STORAGE_PREFIX + key);
                return true;
                } catch (e) {
                console.error('Erreur de suppression:', e);
                return false;
                }
            },
            
            clear() {
                if (!this.isAvailable()) {
                return false;
                }
                try {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(STORAGE_PREFIX)) {
                    localStorage.removeItem(key);
                    }
                });
                return true;
                } catch (e) {
                console.error('Erreur de nettoyage:', e);
                return false;
                }
            }
        };

        // === FONCTIONS UTILITAIRES DE VALIDATION ===
        const utils = {
            validateNumber(value, min = 0, max = 999) {
                const num = parseFloat(value);
                return !isNaN(num) && num >= min && num <= max ? num : 0;
            },
            
            validateString(value, minLength = 1, maxLength = 100) {
                if (typeof value !== 'string') return '';
                return value.trim().length >= minLength && value.trim().length <= maxLength ? value.trim() : '';
            },
            
            validateEmail(email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            },
            
            validateDate(dateString) {
                const date = new Date(dateString);
                return !isNaN(date.getTime()) && dateString.match(/^\d{4}-\d{2}-\d{2}$/);
            }
        };

        // === ACTIONS (MODIFICATION DE L'√âTAT) ===
        const actions = {
            // Initialisation
            init() {
                this.loadData();
                this.applyTheme();
                this.setCurrentDate();
                render();
            },
            
            loadData() {
                appState.exercises = storage.load('exercises', []);
                appState.sessions = storage.load('sessions', []);
                appState.templates = storage.load('templates', []);
                appState.measurements = storage.load('measurements', []);
                appState.records = storage.load('records', {});
                appState.settings = storage.load('settings', { theme: 'light' });
            },
            
            saveData() {
                storage.save('exercises', appState.exercises);
                storage.save('sessions', appState.sessions);
                storage.save('templates', appState.templates);
                storage.save('measurements', appState.measurements);
                storage.save('records', appState.records);
                storage.save('settings', appState.settings);
            },
            
            // Navigation
            showScreen(screenName) {
                appState.currentScreen = screenName;
                render();
            },
            
            showSettings() {
                appState.currentScreen = 'settings';
                render();
            },
            
            // Gestion des exercices
            saveExercise() {
                const name = utils.validateString(document.getElementById('exercise-name').value, 1, 50);
                const isUnilateral = document.getElementById('exercise-unilateral').checked;
                const restTime = utils.validateNumber(document.getElementById('exercise-rest').value, 30, 600);
                const category = document.getElementById('exercise-category')?.value || 'strength';
                const mode = document.getElementById('exercise-mode')?.value || 'reps';
                const duration = utils.validateNumber(document.getElementById('exercise-duration').value, 10, 300);
                
                if (!name) {
                    this.showNotification('Le nom de l\'exercice est requis (1-50 caract√®res)');
                    return;
                }
                
                if (appState.editingExercise) {
                    // Modification
                    const exercise = appState.exercises.find(e => e.id === appState.editingExercise);
                    exercise.name = name;
                    exercise.is_unilateral = isUnilateral;
                    exercise.default_rest_time = restTime;
                    exercise.category = category;
                    exercise.exercise_mode = mode;
                    exercise.default_duration = duration;
                    exercise.exercise_type = category === 'warmup' ? 'bodyweight' : 'elastics';
                    exercise.anchor_point = document.getElementById('exercise-anchor')?.value || 'none';
                    exercise.muscle_group = document.getElementById('exercise-muscle-group')?.value || 'autres';
                    appState.editingExercise = null;
                } else {
                    // Cr√©ation
                    const newExercise = {
                        id: Date.now(),
                        name,
                        is_unilateral: isUnilateral,
                        default_rest_time: restTime,
                        category: category,
                        exercise_mode: mode,
                        default_duration: duration,
                        exercise_type: category === 'warmup' ? 'bodyweight' : 'elastics',
                        anchor_point: document.getElementById('exercise-anchor')?.value || 'none',
                        muscle_group: document.getElementById('exercise-muscle-group')?.value || 'autres'
                    };
                    appState.exercises.push(newExercise);
                }
                
                this.clearExerciseForm();
                this.saveData();
                render();
                this.showNotification('Exercice sauvegard√© !');
            },
            
            // Fonction pour d√©placer un exercice vers le haut
            moveExerciseUp(index, context = 'session') {
                if (index === 0) return;
                
                let exercises;
                if (context === 'session' && appState.currentSession) {
                    exercises = appState.currentSession.exercises;
                } else if (context === 'template' && appState.editingTemplate) {
                    exercises = appState.editingTemplate.exerciseIds;
                } else {
                    return;
                }
                
                // √âchanger les √©l√©ments
                [exercises[index], exercises[index - 1]] = [exercises[index - 1], exercises[index]];
                render();
            },

            // Fonction pour d√©placer un exercice vers le bas
            moveExerciseDown(index, context = 'session') {
                let exercises;
                if (context === 'session' && appState.currentSession) {
                    exercises = appState.currentSession.exercises;
                    if (index >= exercises.length - 1) return;
                } else if (context === 'template' && appState.editingTemplate) {
                    exercises = appState.editingTemplate.exerciseIds;
                    if (index >= exercises.length - 1) return;
                } else {
                    return;
                }
                
                // √âchanger les √©l√©ments
                [exercises[index], exercises[index + 1]] = [exercises[index + 1], exercises[index]];
                render();
            },

            editExercise(id) {
                const exercise = appState.exercises.find(e => e.id === id);
                if (exercise) {
                    appState.editingExercise = id;
                    document.getElementById('exercise-name').value = exercise.name;
                    document.getElementById('exercise-unilateral').checked = exercise.is_unilateral;
                    document.getElementById('exercise-rest').value = exercise.default_rest_time;
                    document.getElementById('exercise-category').value = exercise.category || 'strength';
                    document.getElementById('exercise-mode').value = exercise.exercise_mode || 'reps';
                    document.getElementById('exercise-duration').value = exercise.default_duration || 30;
                    document.getElementById('exercise-anchor').value = exercise.anchor_point || 'none';
                    document.getElementById('exercise-muscle-group').value = exercise.muscle_group || 'autres';
                    
                    // Afficher/masquer le champ dur√©e selon le mode
                    toggleExerciseMode();
                    
                    // Afficher les exemples d'exercices
                    showExerciseExamples(exercise.anchor_point || 'none');
                    
                    render();
                }
            },
            
            // Fonction pour g√©n√©rer les inputs de performance selon le mode de l'exercice
            generatePerformanceInputs(exercise, prefix = '') {
                let html = '';
                
                if (exercise.exercise_mode === 'time') {
                    // Mode temps avec TIMER INT√âGR√â
                    html = `
                        ${generateTimerInterface(exercise, prefix)}
                        ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix) : ''}
                    `;
                    
                    // Configurer le timer apr√®s le rendu
                    setTimeout(() => {
                        const defaultDuration = exercise.default_duration || 30;
                        exerciseTimer.setup(
                            defaultDuration,
                            updateTimerDisplay,
                            completeTimedExercise
                        );
                    }, 100);
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - choix entre temps et r√©p√©titions
                    const modeInputs = exercise.is_unilateral ? `
                        <div class="input-group" id="${prefix}reps-inputs" style="display: none;">
                            <label>Reps Gauche</label>
                            <input type="number" id="${prefix}left-reps" class="input" min="0">
                        </div>
                        <div class="input-group" id="${prefix}reps-inputs-2" style="display: none;">
                            <label>Reps Droite</label>
                            <input type="number" id="${prefix}right-reps" class="input" min="0">
                        </div>
                        <div id="${prefix}timer-container" style="display: none;">
                            ${generateTimerInterface(exercise, prefix)}
                        </div>
                    ` : `
                        <div class="input-group" id="${prefix}reps-inputs" style="display: none;">
                            <label>R√©p√©titions</label>
                            <input type="number" id="${prefix}reps" class="input" min="0">
                        </div>
                        <div id="${prefix}timer-container" style="display: none;">
                            ${generateTimerInterface(exercise, prefix)}
                        </div>
                    `;
                    
                    html = `
                        <div class="input-group">
                            <label>Mode d'ex√©cution</label>
                            <select id="${prefix}execution-mode" class="select" onchange="togglePerformanceMode('${prefix}')">
                                <option value="reps">R√©p√©titions</option>
                                <option value="time">Temps avec Timer</option>
                            </select>
                        </div>
                        <div class="performance-inputs">
                            ${modeInputs}
                        </div>
                        ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix) : ''}
                    `;
                } else {
                    // Mode r√©p√©titions classique
                    if (exercise.is_unilateral) {
                        html = `
                            <div class="performance-inputs">
                                <div class="input-group">
                                    <label>Reps Gauche</label>
                                    <input type="number" id="${prefix}left-reps" class="input" min="0">
                                </div>
                                <div class="input-group">
                                    <label>Reps Droite</label>
                                    <input type="number" id="${prefix}right-reps" class="input" min="0">
                                </div>
                            </div>
                            ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix) : ''}
                        `;
                    } else {
                        html = `
                            <div class="performance-inputs">
                                <div class="input-group">
                                    <label>R√©p√©titions</label>
                                    <input type="number" id="${prefix}reps" class="input" min="0">
                                </div>
                            </div>
                            ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix) : ''}
                        `;
                    }
                }
                
                return html;
            },

            deleteExercise(id) {
                if (confirm('Supprimer cet exercice ? Cette action est irr√©versible.')) {
                    appState.exercises = appState.exercises.filter(e => e.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Exercice supprim√©');
                }
            },
            
            cancelExerciseEdit() {
                appState.editingExercise = null;
                this.clearExerciseForm();
                render();
            },
            
            clearExerciseForm() {
                document.getElementById('exercise-name').value = '';
                document.getElementById('exercise-unilateral').checked = false;
                document.getElementById('exercise-rest').value = '90';
                document.getElementById('exercise-category').value = 'strength';
                document.getElementById('exercise-mode').value = 'reps';
                document.getElementById('exercise-duration').value = '30';
                document.getElementById('exercise-anchor').value = 'none';
                document.getElementById('exercise-muscle-group').value = 'biceps';
                document.getElementById('exercise-examples').style.display = 'none';
                document.getElementById('duration-group').style.display = 'none';
            },
            
            // Gestion des mod√®les
            saveTemplate() {
                const name = document.getElementById('template-name').value.trim();
                const checkboxes = document.querySelectorAll('#template-exercises-checkboxes input:checked');
                const exerciseIds = Array.from(checkboxes).map(cb => {
                    const id = cb.value;
                    return isNaN(parseInt(id)) ? id : parseInt(id);
                });
                
                if (!name) {
                    this.showNotification('Le nom du mod√®le est requis');
                    return;
                }
                
                if (exerciseIds.length === 0) {
                    this.showNotification('S√©lectionnez au moins un exercice');
                    return;
                }
                
                const newTemplate = {
                    id: Date.now(),
                    name,
                    exerciseIds
                };
                
                appState.templates.push(newTemplate);
                this.clearTemplateForm();
                this.saveData();
                render();
                this.showNotification('Mod√®le cr√©√© !');
            },
            
            deleteTemplate(id) {
                if (confirm('Supprimer ce mod√®le ?')) {
                    appState.templates = appState.templates.filter(t => t.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Mod√®le supprim√©');
                }
            },
            
            clearTemplateForm() {
                document.getElementById('template-name').value = '';
                const checkboxes = document.querySelectorAll('#template-exercises-checkboxes input');
                checkboxes.forEach(cb => cb.checked = false);
            },
            
            // Pr√©paration de s√©ance
            setCurrentDate() {
                const today = new Date().toISOString().split('T')[0];
                const dateInput = document.getElementById('session-date');
                if (dateInput) {
                    dateInput.value = today;
                    appState.currentSession = {
                        date: today,
                        notes: '',
                        exercises: []
                    };
                }
            },
            
            updateSessionDate(date) {
                if (appState.currentSession) {
                    appState.currentSession.date = date;
                }
            },
            
            updateSessionNotes(notes) {
                if (appState.currentSession) {
                    appState.currentSession.notes = notes;
                }
            },
            
            addExerciseToSession() {
                const select = document.getElementById('exercise-select');
                const exerciseId = parseInt(select.value);
                
                if (!exerciseId || isNaN(exerciseId)) {
                    this.showNotification('S√©lectionnez un exercice');
                    return;
                }
                
                if (!appState.currentSession) {
                    appState.currentSession = {
                        date: new Date().toISOString().split('T')[0],
                        notes: '',
                        exercises: []
                    };
                }
                
                // V√©rifier si l'exercice n'est pas d√©j√† dans la liste
                const exists = appState.currentSession.exercises.find(e => e.exercise_id === exerciseId);
                if (exists) {
                    this.showNotification('Cet exercice est d√©j√† dans la liste');
                    return;
                }
                
                appState.currentSession.exercises.push({
                    exercise_id: exerciseId,
                    planned_sets: 3,
                    sets: []
                });
                
                select.value = '';
                render();
                this.showNotification('Exercice ajout√© !');
            },
            
            removeExerciseFromSession(exerciseId) {
                if (appState.currentSession) {
                    appState.currentSession.exercises = appState.currentSession.exercises.filter(
                        e => e.exercise_id !== exerciseId
                    );
                    render();
                }
            },
            
            updatePlannedSets(exerciseId, sets) {
                if (appState.currentSession) {
                    const exercise = appState.currentSession.exercises.find(e => e.exercise_id === exerciseId);
                    if (exercise) {
                        const setsNumber = utils.validateNumber(sets, 1, 20);
                        if (setsNumber > 0) {
                            exercise.planned_sets = setsNumber;
                        } else {
                            // Remettre la valeur pr√©c√©dente si la validation √©choue
                            const input = document.querySelector(`input[onchange*="${exerciseId}"]`);
                            if (input) {
                                input.value = exercise.planned_sets;
                            }
                            this.showNotification('Nombre de s√©ries invalide (1-20)');
                        }
                    }
                }
            },
            
            startNewSession() {
                appState.currentSession = {
                    date: new Date().toISOString().split('T')[0],
                    notes: '',
                    exercises: []
                };
                this.showScreen('preparation');
            },
            
            resumeLastSession() {
                const lastSession = appState.sessions[appState.sessions.length - 1];
                if (lastSession) {
                    appState.currentSession = {
                        date: new Date().toISOString().split('T')[0],
                        notes: '',
                        exercises: lastSession.exercises.map(e => ({
                            exercise_id: e.exercise_id,
                            planned_sets: e.planned_sets,
                            sets: []
                        }))
                    };
                    this.showScreen('preparation');
                } else {
                    this.showNotification('Aucune s√©ance pr√©c√©dente trouv√©e');
                }
            },

            saveSessionManually() {
                if (!appState.currentSession || appState.currentSession.exercises.length === 0) {
                    this.showNotification('Ajoutez au moins un exercice');
                    return;
                }
                
                // Pr√©parer la s√©ance pour saisie manuelle
                appState.manualSession = {
                    ...appState.currentSession,
                    id: Date.now(),
                    startTime: Date.now(),
                    currentExerciseIndex: 0
                };
                
                this.showScreen('manual-entry');
                render();
            },

            finishManualSession() {
                if (appState.manualSession) {
                    // S'assurer que la date est bien celle d'aujourd'hui
                    appState.manualSession.endTime = Date.now();
                    appState.manualSession.date = new Date().toISOString().split('T')[0];
                    
                    appState.sessions.push(appState.manualSession);
                    appState.manualSession = null;
                    appState.currentSession = null;
                    
                    // Sauvegarder AVANT de changer d'√©cran
                    this.saveData();
                    
                    this.showScreen('dashboard');
                    this.showNotification('S√©ance sauvegard√©e !');
                    
                    // Forcer la mise √† jour du calendrier apr√®s un petit d√©lai
                    setTimeout(() => {
                        render();
                        console.log('Sessions apr√®s sauvegarde:', appState.sessions.map(s => s.date));
                    }, 50);
                }
            },

            saveManualSet() {
                if (!appState.manualSession) return;
                
                const currentExercise = appState.manualSession.exercises[appState.manualSession.currentExerciseIndex];
                const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                
                // R√©cup√©rer les donn√©es de performance selon le mode de l'exercice
                let performance = {};
                const setType = document.getElementById('manual-set-type')?.value || 'work';

                // R√©cup√©rer la combinaison d'√©lastiques (si applicable)
                const elasticsData = exercise.exercise_type === 'elastics' ? updateResistanceDisplay('manual-') : { selectedElastics: {}, total: 0 };

                if (exercise.exercise_mode === 'time') {
                    // Mode temps pur - utiliser la valeur du timer ou de l'input
                    const durationInput = document.getElementById('manual-duration');
                    const duration = durationInput ? parseInt(durationInput.value) : (exerciseTimer.duration || 30);
                    
                    performance = {
                        duration: duration,
                        exercise_mode: 'time',
                        elastics: elasticsData.selectedElastics,
                        total_resistance: elasticsData.total
                    };
                    
                    // Arr√™ter le timer si il √©tait en cours
                    if (exerciseTimer.isRunning) {
                        exerciseTimer.stop();
                    }
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - v√©rifier le mode choisi
                    const executionMode = document.getElementById('manual-execution-mode')?.value || 'reps';
                    
                    if (executionMode === 'time') {
                        const durationInput = document.getElementById('manual-duration');
                        const duration = durationInput ? parseInt(durationInput.value) : 30;
                        
                        performance = {
                            duration: duration,
                            exercise_mode: 'time',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                        
                        if (exerciseTimer.isRunning) {
                            exerciseTimer.stop();
                        }
                    } else {
                        // Mode r√©p√©titions
                        if (exercise.is_unilateral) {
                            performance = {
                                left_reps: parseInt(document.getElementById('manual-left-reps')?.value) || 0,
                                right_reps: parseInt(document.getElementById('manual-right-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        } else {
                            performance = {
                                reps: parseInt(document.getElementById('manual-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        }
                    }
                } else {
                    // Mode r√©p√©titions classique
                    if (exercise.is_unilateral) {
                        performance = {
                            left_reps: parseInt(document.getElementById('manual-left-reps')?.value) || 0,
                            right_reps: parseInt(document.getElementById('manual-right-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    } else {
                        performance = {
                            reps: parseInt(document.getElementById('manual-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    }
                }
                
                // Ajouter la s√©rie
                currentExercise.sets.push({
                    type: setType,
                    ...performance
                });
                
                // V√©rifier les records
                this.checkRecords(currentExercise.exercise_id, performance, setType);
                
                // V√©rifier si on a atteint le nombre de s√©ries pr√©vues
                if (currentExercise.sets.length >= currentExercise.planned_sets) {
                    // V√©rifier s'il y a encore des exercices
                    if (appState.manualSession.currentExerciseIndex + 1 >= appState.manualSession.exercises.length) {
                        // C'√©tait le dernier exercice, proposer de finir
                        if (confirm('Toutes les s√©ries pr√©vues sont termin√©es. Finir la s√©ance ?')) {
                            this.finishManualSession();
                        } else {
                            render();
                        }
                    } else {
                        // Passer automatiquement √† l'exercice suivant
                        this.nextManualExercise();
                    }
                    return;
                }
                
                // Effacer les champs pour la s√©rie suivante
                if (exercise.is_unilateral) {
                    document.getElementById('manual-left-reps').value = '';
                    document.getElementById('manual-right-reps').value = '';
                } else {
                    document.getElementById('manual-reps').value = '';
                }
                
                // Remettre les √©lastiques √† z√©ro
                Object.keys(ELASTICS_DB).forEach(color => {
                    const selectElement = document.getElementById(`manual-elastic-${color}`);
                    if (selectElement) {
                        selectElement.value = '0';
                    }
                });
                updateResistanceDisplay('manual-');
                
                render();
                this.showNotification('S√©rie ajout√©e !');
            },

            nextManualExercise() {
                if (appState.manualSession) {
                    appState.manualSession.currentExerciseIndex++;
                    if (appState.manualSession.currentExerciseIndex >= appState.manualSession.exercises.length) {
                        this.finishManualSession();
                    } else {
                        render();
                    }
                }
            },
            
            // S√©ance live
            startLiveSession() {
                if (!appState.currentSession || appState.currentSession.exercises.length === 0) {
                    this.showNotification('Ajoutez au moins un exercice');
                    return;
                }
                
                appState.liveSession = {
                    ...appState.currentSession,
                    id: Date.now(),
                    startTime: Date.now(),
                    currentExerciseIndex: 0,
                    currentSetIndex: 0,
                    isResting: false,
                    restStartTime: null,
                    restDuration: 0
                };
                
                this.showScreen('live');
                this.startSessionTimer();
                render();
            },
            
            startSessionTimer() {
                if (appState.sessionTimer) {
                    clearInterval(appState.sessionTimer);
                }
                
                appState.sessionTimer = setInterval(() => {
                    if (appState.liveSession) {
                        const elapsed = Date.now() - appState.liveSession.startTime;
                        const timerElement = document.getElementById('live-timer');
                        if (timerElement) {
                            timerElement.textContent = this.formatTime(elapsed);
                        }
                        
                        // G√©rer le timer de repos
                        if (appState.liveSession.isResting) {
                            const restElapsed = Date.now() - appState.liveSession.restStartTime;
                            const restRemaining = Math.max(0, appState.liveSession.restDuration - restElapsed);
                            const restElement = document.querySelector('.rest-time');
                            if (restElement) {
                                restElement.textContent = this.formatTime(restRemaining);
                                if (restRemaining === 0) {
                                    restElement.style.color = 'var(--danger)';
                                }
                            }
                        }
                    }
                }, 1000);
            },
            
            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            },
            
            validateSet() {
                if (!appState.liveSession) return;
                
                const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                
                // R√©cup√©rer les donn√©es de performance selon le mode de l'exercice
                let performance = {};
                const setType = document.getElementById('set-type')?.value || 'work';

                // R√©cup√©rer la combinaison d'√©lastiques (si applicable)
                const elasticsData = exercise.exercise_type === 'elastics' ? updateResistanceDisplay() : { selectedElastics: {}, total: 0 };

                if (exercise.exercise_mode === 'time') {
                    // Mode temps pur - utiliser la valeur du timer ou de l'input
                    const durationInput = document.getElementById('duration');
                    const duration = durationInput ? parseInt(durationInput.value) : (exerciseTimer.duration || 30);
                    
                    performance = {
                        duration: duration,
                        exercise_mode: 'time',
                        elastics: elasticsData.selectedElastics,
                        total_resistance: elasticsData.total
                    };
                    
                    // Arr√™ter le timer si il √©tait en cours
                    if (exerciseTimer.isRunning) {
                        exerciseTimer.stop();
                    }
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - v√©rifier le mode choisi
                    const executionMode = document.getElementById('execution-mode')?.value || 'reps';
                    
                    if (executionMode === 'time') {
                        const durationInput = document.getElementById('duration');
                        const duration = durationInput ? parseInt(durationInput.value) : 30;
                        
                        performance = {
                            duration: duration,
                            exercise_mode: 'time',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                        
                        if (exerciseTimer.isRunning) {
                            exerciseTimer.stop();
                        }
                    } else {
                        // Mode r√©p√©titions
                        if (exercise.is_unilateral) {
                            performance = {
                                left_reps: parseInt(document.getElementById('left-reps')?.value) || 0,
                                right_reps: parseInt(document.getElementById('right-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        } else {
                            performance = {
                                reps: parseInt(document.getElementById('reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        }
                    }
                } else {
                    // Mode r√©p√©titions classique
                    if (exercise.is_unilateral) {
                        performance = {
                            left_reps: parseInt(document.getElementById('left-reps')?.value) || 0,
                            right_reps: parseInt(document.getElementById('right-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    } else {
                        performance = {
                            reps: parseInt(document.getElementById('reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    }
                }
                
                // Ajouter la s√©rie
                currentExercise.sets.push({
                    type: setType,
                    ...performance
                });
                
                // V√©rifier les records
                this.checkRecords(currentExercise.exercise_id, performance, setType);
                
                // V√©rifier si on a atteint le nombre de s√©ries pr√©vues
                if (currentExercise.sets.length >= currentExercise.planned_sets) {
                    // V√©rifier s'il y a encore des exercices
                    if (appState.liveSession.currentExerciseIndex + 1 >= appState.liveSession.exercises.length) {
                        // C'√©tait le dernier exercice, finir la s√©ance
                        this.finishLiveSession();
                    } else {
                        // Passer √† l'exercice suivant
                        this.nextExercise();
                    }
                } else {
                    // Passer au repos pour la s√©rie suivante
                    appState.liveSession.isResting = true;
                    appState.liveSession.restStartTime = Date.now();
                    appState.liveSession.restDuration = exercise.default_rest_time * 1000;
                    render();
                }
            },
            
            skipRest() {
                if (appState.liveSession) {
                    appState.liveSession.isResting = false;
                    render();
                }
            },
            
            nextExercise() {
                if (!appState.liveSession) return;
                appState.liveSession.currentExerciseIndex++;
                appState.liveSession.currentSetIndex = 0;
                
                if (appState.liveSession.currentExerciseIndex >= appState.liveSession.exercises.length) {
                    this.finishLiveSession();
                } else {
                    // Ajouter un repos de 2 minutes entre les exercices
                    appState.liveSession.isResting = true;
                    appState.liveSession.restStartTime = Date.now();
                    appState.liveSession.restDuration = 120 * 1000; // 2 minutes en millisecondes
                    render();
                }
            },
            
            // Nettoyer tous les timers actifs
            cleanupTimers() {
                if (appState.sessionTimer) {
                    clearInterval(appState.sessionTimer);
                    appState.sessionTimer = null;
                }
                if (appState.restTimer) {
                    clearInterval(appState.restTimer);
                    appState.restTimer = null;
                }
            },

            finishLiveSession() {
                if (!appState.liveSession) return;
                
                // Sauvegarder la s√©ance avec la date d'aujourd'hui
                const sessionToSave = {
                    ...appState.liveSession,
                    endTime: Date.now(),
                    date: new Date().toISOString().split('T')[0] // S'assurer que la date est aujourd'hui
                };
  
                appState.sessions.push(sessionToSave);
                
                // Nettoyer
                appState.liveSession = null;
                appState.currentSession = null;
                this.cleanupTimers();
                
                // Sauvegarder AVANT de changer d'√©cran
                this.saveData();
  
                this.showScreen('dashboard');
                this.showNotification('S√©ance termin√©e ! üéâ');
                
                // Forcer la mise √† jour du calendrier apr√®s un petit d√©lai
                setTimeout(() => {
                    render();
                    console.log('Sessions apr√®s sauvegarde:', appState.sessions.map(s => s.date));
                }, 50);
            },
            
            stopLiveSession() {
                if (confirm('Arr√™ter la s√©ance ? Les donn√©es seront perdues.')) {
                    appState.liveSession = null;
                    this.cleanupTimers(); // Utilise la nouvelle fonction
                    this.showScreen('preparation');
                    render();
                }
            },
            
            // Gestion des records
            checkRecords(exerciseId, performance, setType) {
                if (setType !== 'work') return; // Seules les s√©ries de travail comptent pour les records
                
                if (!appState.records[exerciseId]) {
                    appState.records[exerciseId] = [];
                }
                
                const today = new Date().toISOString().split('T')[0];
                let newRecords = [];
                
                // Record de poids max (utiliser la r√©sistance totale des √©lastiques)
                let maxWeight = performance.total_resistance || 0;
                
                const currentMaxWeight = this.getCurrentRecord(exerciseId, 'max_weight');
                if (maxWeight > currentMaxWeight) {
                    newRecords.push({ date: today, type: 'max_weight', value: maxWeight });
                }
                
                // Record de r√©p√©titions max
                let maxReps = 0;
                if (performance.reps) {
                    maxReps = performance.reps;
                } else if (performance.left_reps && performance.right_reps) {
                    maxReps = Math.max(performance.left_reps, performance.right_reps);
                }
                
                const currentMaxReps = this.getCurrentRecord(exerciseId, 'max_reps');
                if (maxReps > currentMaxReps) {
                    newRecords.push({ date: today, type: 'max_reps', value: maxReps });
                }
                
                // 1RM estim√© (formule d'Epley)
                if (maxWeight > 0 && maxReps > 0) {
                    const estimated1RM = maxWeight * (1 + maxReps / 30);
                    const current1RM = this.getCurrentRecord(exerciseId, 'max_1rm');
                    if (estimated1RM > current1RM) {
                        newRecords.push({ date: today, type: 'max_1rm', value: estimated1RM });
                    }
                }
                
                // Ajouter les nouveaux records
                if (newRecords.length > 0) {
                    appState.records[exerciseId].push(...newRecords);
                    this.showNotification('üéâ Nouveau PR !');
                }
            },
            
            getCurrentRecord(exerciseId, type) {
                const records = appState.records[exerciseId] || [];
                const typeRecords = records.filter(r => r.type === type);
                return typeRecords.length > 0 ? Math.max(...typeRecords.map(r => r.value)) : 0;
            },

            getLastPerformance(exerciseId) {
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                if (!exercise) return null;
                
                // Trouver la derni√®re s√©ance avec cet exercice
                const sessionsWithExercise = appState.sessions
                    .filter(session => session.exercises.some(ex => ex.exercise_id === exerciseId))
                    .sort((a, b) => b.date.localeCompare(a.date));
  
                if (sessionsWithExercise.length === 0) return null;
                
                const lastSession = sessionsWithExercise[0];
                const exerciseData = lastSession.exercises.find(ex => ex.exercise_id === exerciseId);
                
                if (!exerciseData || exerciseData.sets.length === 0) return null;
                
                // R√©cup√©rer le meilleur set de la derni√®re s√©ance
                const workSets = exerciseData.sets.filter(set => set.type === 'work');
                if (workSets.length === 0) return null;
  
                const bestSet = workSets.reduce((best, current) => {
                    const currentTotal = (current.total_resistance || 0) * (current.reps || Math.max(current.left_reps || 0, current.right_reps || 0));
                    const bestTotal = (best.total_resistance || 0) * (best.reps || Math.max(best.left_reps || 0, best.right_reps || 0));
                    return currentTotal > bestTotal ? current : best;
                });
  
                return {
                    date: lastSession.date,
                    resistance: bestSet.total_resistance || 0,
                    reps: exercise.is_unilateral ? 
                        `${bestSet.left_reps || 0}G/${bestSet.right_reps || 0}D` : 
                        (bestSet.reps || 0),
                    elastics: bestSet.elastics || {}
                };
            },

            // Navigation du calendrier
            previousMonth() {
                if (!appState.calendarDate) {
                    appState.calendarDate = new Date();
                }
                appState.calendarDate.setMonth(appState.calendarDate.getMonth() - 1);
                render();
            },

            nextMonth() {
                if (!appState.calendarDate) {
                    appState.calendarDate = new Date();
                }
                appState.calendarDate.setMonth(appState.calendarDate.getMonth() + 1);
                render();
            },

            generateMeasurementsChart() {
                console.log('Measurements data:', appState.measurements); // LIGNE DE DEBUG
                if (appState.measurements.length === 0) {
                    return '<p style="text-align: center; color: var(--text-secondary);">Aucune donn√©e disponible</p>';
                }
    
                // Trier par date
                const sortedMeasurements = [...appState.measurements].sort((a, b) => a.date.localeCompare(b.date));
    
                let chartHtml = '<div style="font-size: 12px; max-height: 250px; overflow-y: auto;">';
    
                // Graphique du poids
                const weightData = sortedMeasurements.filter(m => m.weight && m.weight > 0);
                if (weightData.length > 0) {
                    chartHtml += '<h4>√âvolution du poids</h4>';
                    const maxWeight = Math.max(...weightData.map(d => d.weight));
                    const minWeight = Math.min(...weightData.map(d => d.weight));
        
                    weightData.forEach(data => {
                        const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                        const barWidth = Math.max(10, ((data.weight - minWeight) / (maxWeight - minWeight)) * 80 + 20);
            
                        chartHtml += `
                            <div style="display: flex; align-items: center; margin: 4px 0;">
                                <div style="width: 60px; font-size: 10px;">${date}</div>
                                <div style="width: ${barWidth}%; height: 15px; background: var(--primary); margin: 0 8px; border-radius: 2px;"></div>
                                <div style="font-size: 10px;">${data.weight}kg</div>
                            </div>
                        `;
                    });
                }
    
                // Graphique de la taille
                const waistData = sortedMeasurements.filter(m => m.waist && m.waist > 0);
                if (waistData.length > 0) {
                    chartHtml += '<h4 style="margin-top: 16px;">√âvolution tour de taille</h4>';
                    const maxWaist = Math.max(...waistData.map(d => d.waist));
                    const minWaist = Math.min(...waistData.map(d => d.waist));
                    
                    waistData.forEach(data => {
                        const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                        const barWidth = Math.max(10, ((data.waist - minWaist) / (maxWaist - minWaist)) * 80 + 20);
                        
                        chartHtml += `
                            <div style="display: flex; align-items: center; margin: 4px 0;">
                                <div style="width: 60px; font-size: 10px;">${date}</div>
                                <div style="width: ${barWidth}%; height: 15px; background: var(--secondary); margin: 0 8px; border-radius: 2px;"></div>
                                <div style="font-size: 10px;">${data.waist}cm</div>
                            </div>
                        `;
                    });
                }
                
                // Si aucune donn√©e n'est disponible
                if (weightData.length === 0 && waistData.length === 0) {
                    chartHtml += '<p style="text-align: center; color: var(--text-secondary);">Ajoutez des mensurations pour voir les graphiques</p>';
                }
                
                chartHtml += '</div>';
                return chartHtml;
            },
    

            generateSimpleChart(exerciseId, exerciseName) {
                // R√©cup√©rer les donn√©es de performance
                const performanceData = [];
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                
                appState.sessions.forEach(session => {
                    const sessionExercise = session.exercises.find(e => e.exercise_id === exerciseId);
                    if (sessionExercise && sessionExercise.sets.length > 0) {
                        // Calculer le meilleur set de la s√©ance
                        let maxWeight = 0;
                        let maxReps = 0;
                        
                        sessionExercise.sets.forEach(set => {
                            if (set.type === 'work') {
                                // Utiliser la r√©sistance totale des √©lastiques
                                const setWeight = set.total_resistance || 0;
                                if (setWeight > maxWeight) maxWeight = setWeight;
                                
                                // Pour les r√©p√©titions
                                if (exercise.is_unilateral) {
                                    const leftReps = set.left_reps || 0;
                                    const rightReps = set.right_reps || 0;
                                    if (leftReps > maxReps) maxReps = leftReps;
                                    if (rightReps > maxReps) maxReps = rightReps;
                                } else {
                                    const setReps = set.reps || 0;
                                    if (setReps > maxReps) maxReps = setReps;
                                }
                            }
                        });
                        
                        if (maxWeight > 0 || maxReps > 0) {
                            performanceData.push({
                                date: session.date,
                                weight: maxWeight,
                                reps: maxReps,
                                volume: maxWeight * maxReps
                            });
                        }
                    }
                });
                
                if (performanceData.length === 0) {
                    return '<p style="text-align: center; color: var(--text-secondary);">Aucune donn√©e disponible</p>';
                }
                
                // Trier par date
                performanceData.sort((a, b) => a.date.localeCompare(b.date));
                
                // Cr√©er un graphique simple
                let chartHtml = `<div style="font-size: 12px; max-height: 250px; overflow-y: auto;">`;
                chartHtml += `<h4>Progression du poids max</h4>`;
                
                const maxWeight = Math.max(...performanceData.map(d => d.weight));
                
                performanceData.forEach((data, index) => {
                    const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                    const barWidth = Math.max(1, (data.weight / maxWeight) * 100);
                    
                    chartHtml += `
                        <div style="display: flex; align-items: center; margin: 4px 0;">
                            <div style="width: 60px; font-size: 10px;">${date}</div>
                            <div style="width: ${barWidth}%; height: 20px; background: var(--primary); margin: 0 8px; border-radius: 2px;"></div>
                            <div style="font-size: 10px;">${data.weight}kg</div>
                        </div>
                    `;
                });
                
                chartHtml += `</div>`;
                return chartHtml;
            },
            
            // Gestion des mesures corporelles
            addMeasurement() {
                const date = document.getElementById('measurement-date').value;
                const weight = parseFloat(document.getElementById('measurement-weight').value);
                const waist = parseFloat(document.getElementById('measurement-waist').value);
                const chest = parseFloat(document.getElementById('measurement-chest').value);
                const arm = parseFloat(document.getElementById('measurement-arm').value);
                const thigh = parseFloat(document.getElementById('measurement-thigh').value);
                
                if (!date) {
                    this.showNotification('Date requise');
                    return;
                }
                
                const newMeasurement = {
                    id: Date.now(),
                    date,
                    weight: weight || 0,
                    waist: waist || 0,
                    chest: chest || 0,
                    arm: arm || 0,
                    thigh: thigh || 0
                };
                
                appState.measurements.push(newMeasurement);
                this.clearMeasurementForm();
                this.saveData();
                render();
                this.showNotification('Mensuration ajout√©e !');
            },
            
            deleteMeasurement(id) {
                if (confirm('Supprimer cette mesure ?')) {
                    appState.measurements = appState.measurements.filter(m => m.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Mensuration supprim√©e');
                }
            },
            
            clearMeasurementForm() {
                document.getElementById('measurement-date').value = '';
                document.getElementById('measurement-weight').value = '';
                document.getElementById('measurement-waist').value = '';
                document.getElementById('measurement-chest').value = '';
                document.getElementById('measurement-arm').value = '';
                document.getElementById('measurement-thigh').value = '';
            },
            
            // Statistiques
            updateStats(exerciseId) {
                const exerciseSelect = document.getElementById('stats-exercise-select');
                if (exerciseSelect) {
                    exerciseSelect.dataset.currentValue = exerciseId;
                }
                render();
            },
            
            // Modals
            showTemplates() {
                document.getElementById('templates-modal').classList.add('active');
                this.renderTemplatesModal();
            },
            
            showImportModal() {
                document.getElementById('import-modal').classList.add('active');
            },
            
            closeModal(modalId) {
                document.getElementById(modalId).classList.remove('active');
            },
            
            loadTemplate(templateId) {
                const template = appState.templates.find(t => t.id === templateId);
                if (template) {
                    if (!appState.currentSession) {
                        appState.currentSession = {
                            date: new Date().toISOString().split('T')[0],
                            notes: '',
                            exercises: []
                        };
                    }
                    
                    // Remplacer tous les exercices par ceux du mod√®le
                    appState.currentSession.exercises = [];
                    template.exerciseIds.forEach(exerciseId => {
                        appState.currentSession.exercises.push({
                            exercise_id: exerciseId,
                            planned_sets: 3,
                            sets: []
                        });
                    });
                    
                    this.closeModal('templates-modal');
                    render();
                    this.showNotification('Mod√®le charg√© !');
                }
            },
            
            // Th√®me
            toggleTheme() {
                appState.settings.theme = appState.settings.theme === 'light' ? 'dark' : 'light';
                this.applyTheme();
                this.saveData();
            },
            
            applyTheme() {
                document.documentElement.setAttribute('data-theme', appState.settings.theme);
                const checkbox = document.getElementById('dark-theme');
                if (checkbox) {
                    checkbox.checked = appState.settings.theme === 'dark';
                }
            },
            
            // Import/Export
            exportData() {
                const data = {
                    exercises: appState.exercises,
                    sessions: appState.sessions,
                    templates: appState.templates,
                    measurements: appState.measurements,
                    records: appState.records,
                    settings: appState.settings,
                    exportDate: new Date().toISOString(),
                    version: STORAGE_VERSION
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `smarttrack_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showNotification('Donn√©es export√©es !');
            },
            
            importData() {
                const textarea = document.getElementById('import-data');
                try {
                    const data = JSON.parse(textarea.value);
                    
                    if (confirm('Remplacer toutes les donn√©es actuelles ? Cette action est irr√©versible.')) {
                        appState.exercises = data.exercises || [];
                        appState.sessions = data.sessions || [];
                        appState.templates = data.templates || [];
                        appState.measurements = data.measurements || [];
                        appState.records = data.records || {};
                        appState.settings = data.settings || { theme: 'light' };
                        
                        this.saveData();
                        this.closeModal('import-modal');
                        this.applyTheme();
                        render();
                        this.showNotification('Donn√©es import√©es !');
                        textarea.value = '';
                    }
                } catch (e) {
                    this.showNotification('Format JSON invalide');
                }
            },
            
            clearAllData() {
                if (confirm('Effacer TOUTES les donn√©es ? Cette action est irr√©versible !')) {
                    if (confirm('√ätes-vous vraiment s√ªr ? Toutes vos s√©ances et exercices seront perdus !')) {
                        storage.clear();
                        appState = {
                            currentScreen: 'dashboard',
                            currentSession: null,
                            liveSession: null,
                            editingExercise: null,
                            exercises: [],
                            sessions: [],
                            templates: [],
                            measurements: [],
                            records: {},
                            settings: { theme: 'light' }
                        };
                        render();
                        this.showNotification('Toutes les donn√©es ont √©t√© effac√©es');
                    }
                }
            },
            
           loadPredefinedExercises() {
                if (appState.exercises.length > 0) {
                    if (!confirm('Cela va ajouter les nouveaux exercices SmartWorkout (+ √©chauffement). Continuer ?')) {
                        return;
                    }
                }
                
                const predefinedExercises = [];
                
                // Exercices existants + nouveaux exercices d'√©chauffement
                Object.keys(PREDEFINED_EXERCISES).forEach(category => {
                    PREDEFINED_EXERCISES[category].forEach(ex => {
                        predefinedExercises.push({
                            id: Date.now() + Math.floor(Math.random() * 10000),
                            name: ex.name,
                            is_unilateral: ex.unilateral,
                            default_rest_time: category === 'echauffement' ? 30 : 90,
                            exercise_type: category === 'echauffement' ? 'bodyweight' : 'elastics',
                            anchor_point: ex.anchor,
                            muscle_group: category,
                            category: category === 'echauffement' ? 'warmup' : 'strength',
                            exercise_mode: ex.timeBase ? 'time' : 'reps',
                            default_duration: ex.timeBase ? 30 : null
                        });
                    });
                });
                
                let added = 0;
                predefinedExercises.forEach(newEx => {
                    const exists = appState.exercises.find(ex =>
                        ex.name === newEx.name && ex.muscle_group === newEx.muscle_group
                    );
                    if (!exists) {
                        appState.exercises.push(newEx);
                        added++;
                    }
                });
                
                this.saveData();
                render();
                this.showNotification(`${added} nouveaux exercices ajout√©s (dont ${PREDEFINED_EXERCISES.echauffement ? PREDEFINED_EXERCISES.echauffement.length : 0} d'√©chauffement) !`);
            },

            // Notifications
            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
        };

        // === FONCTION DE RENDU UNIQUE ===
        function render() {
            console.log('Rendu pour l\'√©cran:', appState.currentScreen);
            
            // Mettre √† jour la navigation active
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Afficher le bon √©cran
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(`screen-${appState.currentScreen}`).classList.add('active');
            
            // Rendu sp√©cifique par √©cran
            switch (appState.currentScreen) {
                case 'dashboard':
                    renderDashboard();
                    document.querySelector('.nav-item').classList.add('active');
                    break;
                case 'preparation':
                    renderPreparation();
                    document.querySelectorAll('.nav-item')[1].classList.add('active');
                    break;
                case 'live':
                    renderLiveSession();
                    break;
                case 'history':
                    renderHistory();
                    document.querySelectorAll('.nav-item')[2].classList.add('active');
                    break;
                case 'stats':
                    renderStats();
                    document.querySelectorAll('.nav-item')[3].classList.add('active');
                    break;
                case 'body':
                    renderBody();
                    document.querySelectorAll('.nav-item')[4].classList.add('active');
                    break;
                case 'exercises':
                    renderExercises();
                    break;
                case 'templates':
                    renderTemplates();
                    break;
                case 'settings':
                    renderSettings();
                    break;
                case 'manual-entry':
                    renderManualEntry();
                    break;
            }
        }

        // === FONCTIONS DE RENDU PAR √âCRAN ===
        function renderDashboard() {
            // Date actuelle ou mois s√©lectionn√©
            if (!appState.calendarDate) {
                appState.calendarDate = new Date();
            }
  
            const currentMonth = appState.calendarDate.getMonth();
            const currentYear = appState.calendarDate.getFullYear();
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            
            // Calendrier mensuel
            const calendarGrid = document.getElementById('calendar-grid');
            const calendarContainer = calendarGrid.parentElement;
            
            // Remplacer le titre et ajouter la navigation
            const titleElement = calendarContainer.querySelector('h3');
            if (titleElement) {
                const monthNames = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin','Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
    
                titleElement.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <button onclick="actions.previousMonth()" class="btn btn-small btn-secondary">‚Üê</button>
                        <span>${monthNames[currentMonth]} ${currentYear}</span>
                        <button onclick="actions.nextMonth()" class="btn btn-small btn-secondary">‚Üí</button>
                    </div>
                `;
            }
  
            // Cr√©er le calendrier
            calendarGrid.innerHTML = '';
            calendarGrid.style.gridTemplateColumns = 'repeat(7, 1fr)';
            calendarGrid.style.gap = '4px';
            calendarGrid.style.maxHeight = 'none';
            
            // En-t√™tes des jours
            const dayHeaders = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.style.cssText = 'text-align: center; font-weight: bold; padding: 8px; font-size: 12px; color: var(--text-secondary);';
                header.textContent = day;
                calendarGrid.appendChild(header);
            });
  
            // Premier jour du mois et nombre de jours
            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const firstDayOfWeek = (firstDay.getDay() + 6) % 7; // Lundi = 0
            const daysInMonth = lastDay.getDate();
            
            // R√©cup√©rer les dates des s√©ances
            const sessionDates = new Set(appState.sessions.map(s => s.date));
            
            // Cases vides avant le 1er du mois
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.style.cssText = 'aspect-ratio: 1; border-radius: 8px; opacity: 0.3;';
                calendarGrid.appendChild(emptyDay);
            }
  
            // Jours du mois
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(currentYear, currentMonth, day);
                const dateStr = date.toISOString().split('T')[0];
    
                const dayElement = document.createElement('div');
                dayElement.style.cssText = `
                    aspect-ratio: 1; 
                    border-radius: 8px; 
                    background: var(--border); 
                    opacity: 0.3; 
                    font-size: 14px; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    color: var(--text-secondary); 
                    font-weight: 500;
                    min-height: 35px;
                `;
    
                dayElement.textContent = day;
    
                // Jour actuel
                if (dateStr === todayStr) {
                    dayElement.style.border = '2px solid var(--primary)';
                    dayElement.style.fontWeight = 'bold';
                }
    
                // Jour avec s√©ance
                if (sessionDates.has(dateStr)) {
                    dayElement.style.opacity = '1';
                    dayElement.style.background = 'var(--secondary)';
                    dayElement.style.color = 'white';
                }
    
                calendarGrid.appendChild(dayElement);
            }
  
            // Statistiques
            document.getElementById('total-sessions').textContent = appState.sessions.length;
            
            // Calcul de la s√©rie actuelle
            let streak = 0;
            const sortedSessions = [...appState.sessions].sort((a, b) => b.date.localeCompare(a.date));
            
            if (sortedSessions.length > 0) {
                let checkDate = new Date();
                const sessionDatesArray = new Set(sortedSessions.map(s => s.date));
                
                for (let i = 0; i < 30; i++) {
                    const dateStr = checkDate.toISOString().split('T')[0];
      
                    if (sessionDatesArray.has(dateStr)) {
                        streak++;
                        checkDate.setDate(checkDate.getDate() - 1);
                    } else {
                        if (i === 0 && dateStr === todayStr) {
                            checkDate.setDate(checkDate.getDate() - 1);
                            continue;
                        }
                        break;
                    }
                }
            }
  
            document.getElementById('current-streak').textContent = streak;
        }

        function renderPreparation() {
            // Remplir le select des exercices par groupes
            const exerciseSelect = document.getElementById('exercise-select');
            exerciseSelect.innerHTML = '<option value="">S√©lectionner un exercice...</option>';
            
            const groupedExercises = {};
            appState.exercises.forEach(exercise => {
                const group = exercise.muscle_group || 'autres';
                if (!groupedExercises[group]) {
                    groupedExercises[group] = [];
                }
                groupedExercises[group].push(exercise);
            });
            
            // Ordre d'affichage des cat√©gories (√©chauffement en premier)
            const groupOrder = ['echauffement', 'biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
            groupOrder.forEach(group => {
                if (groupedExercises[group] && groupedExercises[group].length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                    groupedExercises[group].forEach(exercise => {
                        const option = document.createElement('option');
                        option.value = exercise.id;
                        // Ajouter l'indicateur de mode
                        const modeIcon = exercise.exercise_mode === 'time' ? '‚è±Ô∏è' : 
                                        exercise.exercise_mode === 'both' ? 'üîÑ' : 'üî¢';
                        option.textContent = `${modeIcon} ${exercise.name}`;
                        optgroup.appendChild(option);
                    });
                    exerciseSelect.appendChild(optgroup);
                }
            });
            
            // Afficher les exercices planifi√©s AVEC SECTIONS
            const plannedDiv = document.getElementById('planned-exercises');
            plannedDiv.innerHTML = '';
            
            if (appState.currentSession && appState.currentSession.exercises.length > 0) {
                // S√©parer √©chauffement et entra√Ænement principal
                const warmupExercises = [];
                const mainExercises = [];
                
                appState.currentSession.exercises.forEach((plannedEx, index) => {
                    const exercise = appState.exercises.find(e => e.id === plannedEx.exercise_id);
                    if (exercise) {
                        const exerciseData = { ...plannedEx, exercise, originalIndex: index };
                        if (exercise.muscle_group === 'echauffement' || exercise.category === 'warmup') {
                            warmupExercises.push(exerciseData);
                        } else {
                            mainExercises.push(exerciseData);
                        }
                    }
                });
                
                // Section √âchauffement
                if (warmupExercises.length > 0) {
                    const warmupTitle = document.createElement('h4');
                    warmupTitle.textContent = 'üî• √âchauffement';
                    warmupTitle.className = 'exercise-section-title warmup';
                    plannedDiv.appendChild(warmupTitle);
                    
                    warmupExercises.forEach((exerciseData, sectionIndex) => {
                        plannedDiv.appendChild(createExerciseItem(exerciseData, sectionIndex, 'warmup'));
                    });
                }
                
                // Section Entra√Ænement Principal
                if (mainExercises.length > 0) {
                    const mainTitle = document.createElement('h4');
                    mainTitle.textContent = 'üí™ Entra√Ænement Principal';
                    mainTitle.className = 'exercise-section-title main';
                    plannedDiv.appendChild(mainTitle);
                    
                    mainExercises.forEach((exerciseData, sectionIndex) => {
                        plannedDiv.appendChild(createExerciseItem(exerciseData, sectionIndex, 'main'));
                    });
                }
                
                document.getElementById('start-live-btn').style.display = 'block';
                document.getElementById('save-manual-btn').style.display = 'block';
            } else {
                plannedDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">Aucun exercice planifi√©</p>';
                document.getElementById('start-live-btn').style.display = 'none';
                document.getElementById('save-manual-btn').style.display = 'none';
            }
        }

        function renderLiveSession() {
            const liveContent = document.getElementById('live-content');
            
            if (!appState.liveSession) {
                liveContent.innerHTML = '<p>Aucune s√©ance en cours</p>';
                return;
            }
            
            const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
            if (!currentExercise) {
                actions.finishLiveSession();
                return;
            }
            
            const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
            
            if (appState.liveSession.isResting) {
                // Phase de repos
                liveContent.innerHTML = `
                    <div class="rest-timer">
                        <h2>Temps de repos</h2>
                        <div class="rest-time">00:00</div>
                        <button class="btn btn-primary btn-full" onclick="actions.skipRest()">
                            ‚è≠Ô∏è Passer le repos
                        </button>
                    </div>
                    
                    <div class="next-exercise">
                        <h4>√Ä suivre :</h4>
                        <p><strong>${exercise.name}</strong></p>
                        <p>S√©rie ${currentExercise.sets.length + 1} / ${currentExercise.planned_sets}</p>
                    </div>
                `;
            } else {
                // Phase d'exercice
                const setNumber = currentExercise.sets.length + 1;
                
                // MODIFICATION : Utiliser la nouvelle fonction pour g√©rer tous les modes
                const performanceInputs = actions.generatePerformanceInputs(exercise);
                
                // R√©cup√©rer les derni√®res performances
                const lastPerf = actions.getLastPerformance(exercise.id);
                const nextExerciseIndex = appState.liveSession.currentExerciseIndex + 1;
                const nextExercise = nextExerciseIndex < appState.liveSession.exercises.length ? 
                    appState.exercises.find(e => e.id === appState.liveSession.exercises[nextExerciseIndex].exercise_id) : null;
                const nextPerf = nextExercise ? actions.getLastPerformance(nextExercise.id) : null;

                let perfRecap = '';
                if (lastPerf) {
                    perfRecap += `
                        <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                            <h5>üéØ Derni√®re performance :</h5>
                            <div style="font-size: 14px;">
                                ${lastPerf.resistance}kg ‚Ä¢ ${lastPerf.reps} reps (${new Date(lastPerf.date).toLocaleDateString('fr-FR')})
                            </div>
                        </div>
                    `;
                }

                if (nextPerf && nextExercise) {
                    perfRecap += `
                        <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                            <h5>üîú Prochain : ${nextExercise.name}</h5>
                            <div style="font-size: 14px;">
                                Derni√®re fois : ${nextPerf.resistance}kg ‚Ä¢ ${nextPerf.reps} reps
                            </div>
                        </div>
                    `;
                }

                liveContent.innerHTML = `
                    <div class="current-exercise">
                        <div class="exercise-name">${exercise.name}</div>
                        <div class="set-counter">S√©rie ${setNumber} / ${currentExercise.planned_sets}</div>
                    </div>
                    ${perfRecap}
                    ${performanceInputs}
                    
                    <div class="input-group">
                        <label>Type de s√©rie</label>
                        <select id="set-type" class="select">
                            <option value="work">Travail</option>
                            <option value="warmup">√âchauffement</option>
                            <option value="dropset">S√©rie d√©gressif</option>
                            <option value="failure">Jusqu'√† l'√©chec</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-success btn-full" onclick="actions.validateSet()">
                        ‚úÖ Valider la s√©rie
                    </button>
                    
                    <button class="btn btn-secondary btn-full" onclick="actions.nextExercise()">
                        ‚û°Ô∏è Exercice suivant
                    </button>
                `;
            }
        }

        function renderHistory() {
            const sessionsList = document.getElementById('sessions-list');
            const historyCount = document.getElementById('history-count');
            
            historyCount.textContent = appState.sessions.length;
            sessionsList.innerHTML = '';
            
            const sortedSessions = [...appState.sessions].sort((a, b) => b.date.localeCompare(a.date));
            
            sortedSessions.forEach(session => {
                const sessionDiv = document.createElement('div');
                sessionDiv.className = 'card';
                
                const date = new Date(session.date);
                const formattedDate = date.toLocaleDateString('fr-FR', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                let exercisesHtml = '';
                session.exercises.forEach(sessionEx => {
                    const exercise = appState.exercises.find(e => e.id === sessionEx.exercise_id);
                    if (exercise) {
                        exercisesHtml += `
                            <div style="margin: 8px 0; padding: 8px; background: var(--background); border-radius: 8px;">
                                <strong>${exercise.name}</strong> (${sessionEx.sets.length} s√©ries)
                                <div style="font-size: 14px; color: var(--text-secondary);">
                                    ${sessionEx.sets.map(set => {
                                        if (exercise.is_unilateral) {
                                            return `${set.left_reps || 0} reps (G) | ${set.right_reps || 0} reps (D) - ${set.total_resistance || 0}kg`;
                                        } else {
                                            return `${set.reps || 0} reps - ${set.total_resistance || 0}kg`;
                                        }
                                    }).join(' ‚Ä¢ ')}
                                </div>
                            </div>
                        `;
                    }
                });
                
                sessionDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h3>${formattedDate}</h3>
                            ${session.notes ? `<p style="color: var(--text-secondary); margin: 8px 0;">${session.notes}</p>` : ''}
                            <details style="margin-top: 12px;">
                                <summary style="cursor: pointer; font-weight: 500;">Voir les d√©tails</summary>
                                <div style="margin-top: 12px;">${exercisesHtml}</div>
                            </details>
                        </div>
                        <button class="btn btn-small btn-danger" onclick="actions.deleteSession(${session.id})" style="margin-left: 12px;">
                            üóëÔ∏è
                        </button>
                    </div>
                `;
                
                sessionsList.appendChild(sessionDiv);
            });
            
            if (sortedSessions.length === 0) {
                sessionsList.innerHTML = '<div class="card"><p style="text-align: center; color: var(--text-secondary);">Aucune s√©ance enregistr√©e</p></div>';
            }
        }

        function renderStats() {
            const exerciseSelect = document.getElementById('stats-exercise-select');
            const statsContent = document.getElementById('stats-content');
            
            // Remplir le select
            exerciseSelect.innerHTML = '<option value="">Choisir un exercice...</option>';
            appState.exercises.forEach(exercise => {
                const option = document.createElement('option');
                option.value = exercise.id;
                option.textContent = exercise.name;
                exerciseSelect.appendChild(option);
            });

            // Conserver la valeur s√©lectionn√©e si elle existe
            const currentValue = exerciseSelect.dataset.currentValue;
            if (currentValue) {
                exerciseSelect.value = currentValue;
            }
            
            const selectedExerciseId = parseInt(exerciseSelect.value);
            if (!selectedExerciseId) {
                statsContent.innerHTML = '<div class="card"><p style="text-align: center; color: var(--text-secondary);">S√©lectionnez un exercice pour voir les statistiques</p></div>';
                return;
            }
            
            const exercise = appState.exercises.find(e => e.id === selectedExerciseId);
            const records = appState.records[selectedExerciseId] || [];
            
            // Calculer les records actuels
            const maxWeight = actions.getCurrentRecord(selectedExerciseId, 'max_weight');
            const maxReps = actions.getCurrentRecord(selectedExerciseId, 'max_reps');
            const max1RM = actions.getCurrentRecord(selectedExerciseId, 'max_1rm');
            
            // Calculer le volume max (poids √ó reps max dans une s√©ance)
            let maxVolume = 0;
            appState.sessions.forEach(session => {
                const sessionExercise = session.exercises.find(e => e.exercise_id === selectedExerciseId);
                if (sessionExercise) {
                    let sessionVolume = 0;
                    sessionExercise.sets.forEach(set => {
                        if (set.type === 'work') {
                            const resistance = set.total_resistance || 0;
                            if (exercise.is_unilateral) {
                                const leftReps = set.left_reps || 0;
                                const rightReps = set.right_reps || 0;
                                sessionVolume += (leftReps + rightReps) * resistance;
                            } else {
                                const reps = set.reps || 0;
                                sessionVolume += reps * resistance;
                            }
                        }
                    });
                    maxVolume = Math.max(maxVolume, sessionVolume);
                }
            });
            
            statsContent.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${maxWeight}kg</div>
                        <div class="stat-label">Poids Max</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${maxReps}</div>
                        <div class="stat-label">Reps Max</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${maxVolume}kg</div>
                        <div class="stat-label">Volume Max</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${max1RM.toFixed(1)}kg</div>
                        <div class="stat-label">1RM Estim√©</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>√âvolution des performances</h3>
                    <div class="chart-container" id="stats-chart">
                        ${actions.generateSimpleChart(selectedExerciseId, exercise.name)}

                    </div>
                </div>
                
                <div class="card">
                    <h3>Historique des records</h3>
                    <div id="records-history">
                        ${records.length > 0 ? 
                            records.map(record => `
                                <div style="padding: 8px; border-bottom: 1px solid var(--border);">
                                    <strong>${new Date(record.date).toLocaleDateString('fr-FR')}</strong> - 
                                    ${record.type === 'max_weight' ? 'Poids Max' : 
                                      record.type === 'max_reps' ? 'Reps Max' : '1RM Estim√©'}: 
                                    <span style="color: var(--primary);">${record.value}${record.type === 'max_reps' ? '' : 'kg'}</span>
                                </div>
                            `).join('') 
                            : '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun record enregistr√©</p>'
                        }
                    </div>
                </div>
            `;
        }

        function renderBody() {
            const measurementsList = document.getElementById('measurements-list');
            
            // D√©finir la date par d√©faut √† aujourd'hui
            const measurementDate = document.getElementById('measurement-date');
            if (!measurementDate.value) {
                measurementDate.value = new Date().toISOString().split('T')[0];
            }
            
            measurementsList.innerHTML = '';
            
            // Mettre √† jour le graphique
            const chartContainer = document.querySelector('#screen-body .chart-container');
            if (chartContainer) {
                chartContainer.innerHTML = actions.generateMeasurementsChart();
            }
            
            const sortedMeasurements = [...appState.measurements].sort((a, b) => b.date.localeCompare(a.date));
            
            if (sortedMeasurements.length > 0) {
                const listDiv = document.createElement('div');
                listDiv.className = 'card';
                listDiv.innerHTML = '<h3>Historique des mensurations</h3>';
                
                sortedMeasurements.forEach(measurement => {
                    const measurementDiv = document.createElement('div');
                    measurementDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--border);';
                    
                    let details = [];
                    if (measurement.weight > 0) details.push(measurement.weight + 'kg');
                    if (measurement.waist > 0) details.push('Taille: ' + measurement.waist + 'cm');
                    if (measurement.chest > 0) details.push('Poitrine: ' + measurement.chest + 'cm');
                    if (measurement.arm > 0) details.push('Bras: ' + measurement.arm + 'cm');
                    if (measurement.thigh > 0) details.push('Cuisse: ' + measurement.thigh + 'cm');
                    
                    measurementDiv.innerHTML = `
                        <div>
                            <strong>${new Date(measurement.date).toLocaleDateString('fr-FR')}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${details.join(' ‚Ä¢ ')}
                            </div>
                        </div>
                        <button class="btn btn-small btn-danger" onclick="actions.deleteMeasurement(${measurement.id})">üóëÔ∏è</button>
                    `;
                    listDiv.appendChild(measurementDiv);
                });
                
                measurementsList.appendChild(listDiv);
            } else {
                measurementsList.innerHTML = '<div class="card"><p style="text-align: center; color: var(--text-secondary);">Aucune mensuration enregistr√©e</p></div>';
            }
        }

        function renderExercises() {
            const exercisesList = document.getElementById('exercises-list');
            const formTitle = document.getElementById('exercise-form-title');
            const saveBtn = document.getElementById('save-exercise-btn');
            const cancelBtn = document.getElementById('cancel-exercise-btn');
            
            // Mise √† jour du formulaire selon le mode (cr√©ation/√©dition)
            if (appState.editingExercise) {
                formTitle.textContent = 'Modifier l\'exercice';
                saveBtn.textContent = 'üíæ Sauvegarder';
                cancelBtn.style.display = 'block';
            } else {
                formTitle.textContent = 'Nouvel exercice';
                saveBtn.textContent = '‚ûï Ajouter l\'exercice';
                cancelBtn.style.display = 'none';
            }
            
            // Liste des exercices
            exercisesList.innerHTML = '';
            
            if (appState.exercises.length > 0) {
                // Grouper les exercices par groupe musculaire
                const groupedExercises = {};
                appState.exercises.forEach(exercise => {
                    const group = exercise.muscle_group || 'autres';
                    if (!groupedExercises[group]) {
                        groupedExercises[group] = [];
                    }
                    groupedExercises[group].push(exercise);
                });
                
                // Afficher par groupes
                const groupOrder = ['biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
                groupOrder.forEach(group => {
                    if (groupedExercises[group] && groupedExercises[group].length > 0) {
                        const groupTitle = document.createElement('h4');
                        groupTitle.textContent = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                        groupTitle.style.cssText = 'margin: 20px 0 10px 0; color: var(--primary); border-bottom: 1px solid var(--border); padding-bottom: 8px;';
                        exercisesList.appendChild(groupTitle);
                        
                        groupedExercises[group].forEach(exercise => {
                            const anchorText = {
                                'none': 'Sans ancrage',
                                'door-middle': 'Porte (milieu)',
                                'door-high': 'Porte (haut)',
                                'door-low': 'Porte (bas)',
                                'floor': 'Sol/Pieds',
                                'body': 'Corps',
                                'external': 'Ext√©rieur'
                            };
                            
                            const div = document.createElement('div');
                            div.className = 'exercise-item';
                            div.innerHTML = `
                                <div>
                                    <strong>${exercise.name}</strong>
                                    <div style="font-size: 14px; color: var(--text-secondary);">
                                        ${exercise.is_unilateral ? 'Unilat√©ral' : 'Bilat√©ral'} ‚Ä¢ ${exercise.default_rest_time}s repos ‚Ä¢ ${anchorText[exercise.anchor_point] || 'Non d√©fini'}
                                    </div>
                                </div>
                                <div class="exercise-actions">
                                    <button class="btn btn-small btn-secondary" onclick="actions.editExercise(${exercise.id})">‚úèÔ∏è</button>
                                    <button class="btn btn-small btn-danger" onclick="actions.deleteExercise(${exercise.id})">üóëÔ∏è</button>
                                </div>
                            `;
                            exercisesList.appendChild(div);
                        });
                    }
                });
            } else {
                exercisesList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun exercice cr√©√©</p>';
            }
        }

        function renderTemplates() {
            const templatesList = document.getElementById('templates-list');
            const checkboxContainer = document.getElementById('template-exercises-checkboxes');
            
            // Remplir les checkboxes d'exercices PAR CAT√âGORIE
            checkboxContainer.innerHTML = '';
            
            // Grouper les exercices par cat√©gorie
            const groupedExercises = {};
            appState.exercises.forEach(exercise => {
                const group = exercise.muscle_group || 'autres';
                if (!groupedExercises[group]) {
                    groupedExercises[group] = [];
                }
                groupedExercises[group].push(exercise);
            });
            
            // Ordre d'affichage des cat√©gories (√©chauffement en premier)
            const groupOrder = ['echauffement', 'biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
            
            groupOrder.forEach(group => {
                if (groupedExercises[group] && groupedExercises[group].length > 0) {
                    // Titre de la cat√©gorie
                    const groupTitle = document.createElement('h4');
                    groupTitle.textContent = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                    groupTitle.className = 'exercise-group-title';
                    checkboxContainer.appendChild(groupTitle);
                    
                    // Exercices de la cat√©gorie
                    groupedExercises[group].forEach(exercise => {
                        const div = document.createElement('div');
                        div.className = 'checkbox-group';
                        
                        // Indicateur du mode d'exercice
                        const modeIcon = exercise.exercise_mode === 'time' ? '‚è±Ô∏è' : 
                                        exercise.exercise_mode === 'both' ? 'üîÑ' : 'üî¢';
                        
                        div.innerHTML = `
                            <input type="checkbox" id="template-ex-${exercise.id}" value="${exercise.id}" class="checkbox">
                            <label for="template-ex-${exercise.id}">
                                ${modeIcon} ${exercise.name}
                                ${exercise.exercise_mode === 'time' ? ` (${exercise.default_duration || 30}s)` : ''}
                            </label>
                        `;
                        checkboxContainer.appendChild(div);
                    });
                }
            });
            
            // Liste des mod√®les existants
            templatesList.innerHTML = '';
            if (appState.templates.length > 0) {
                appState.templates.forEach(template => {
                    const div = document.createElement('div');
                    div.className = 'exercise-item';
                    
                    // Construire la liste des exercices du mod√®le
                    const exerciseNames = template.exerciseIds
                        .map(id => {
                            const exercise = appState.exercises.find(e => e.id === id);
                            if (exercise) {
                                const modeIcon = exercise.exercise_mode === 'time' ? '‚è±Ô∏è' : 
                                                exercise.exercise_mode === 'both' ? 'üîÑ' : 'üî¢';
                                return `${modeIcon} ${exercise.name}`;
                            }
                            return null;
                        })
                        .filter(name => name)
                        .join(', ');
                    
                    div.innerHTML = `
                        <div>
                            <strong>${template.name}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${exerciseNames || 'Aucun exercice'}
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-small btn-secondary" onclick="actions.editTemplate(${template.id})">‚úèÔ∏è</button>
                            <button class="btn btn-small btn-danger" onclick="actions.deleteTemplate(${template.id})">üóëÔ∏è</button>
                        </div>
                    `;
                    templatesList.appendChild(div);
                });
            } else {
                templatesList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun mod√®le cr√©√©</p>';
            }
        }    

        function renderSettings() {
            // Le th√®me est d√©j√† appliqu√© via applyTheme()
        }

        function renderManualEntry() {
            const content = document.getElementById('manual-entry-content');
            if (!appState.manualSession) {
                content.innerHTML = '<p>Aucune s√©ance en cours</p>';
                return;
            }

            const currentExercise = appState.manualSession.exercises[appState.manualSession.currentExerciseIndex];
            if (!currentExercise) {
                actions.finishManualSession();
                return;
            }

            const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
            const performanceInputs = actions.generatePerformanceInputs(exercise, 'manual-');

            // Afficher les s√©ries d√©j√† saisies
            let setsHtml = '';
            if (currentExercise.sets.length > 0) {
                setsHtml = `
                    <div class="card">
                        <h4>S√©ries effectu√©es</h4>
                        ${currentExercise.sets.map((set, index) => {
                            if (exercise.is_unilateral) {
                                return `<div>S√©rie ${index + 1}: ${set.left_reps || 0} reps (G) | ${set.right_reps || 0} reps (D) - ${set.total_resistance || 0}kg</div>`;
                            } else {
                                return `<div>S√©rie ${index + 1}: ${set.reps || 0} reps - ${set.total_resistance || 0}kg</div>`;
                            }
                        }).join('')}
                    </div>
                `;
            }

            content.innerHTML = `
                <div class="current-exercise">
                    <div class="exercise-name">${exercise.name}</div>
                    <div class="set-counter">S√©rie ${currentExercise.sets.length + 1}</div>
                    <div style="color: var(--text-secondary);">Exercice ${appState.manualSession.currentExerciseIndex + 1} / ${appState.manualSession.exercises.length}</div>
                </div>
                ${setsHtml}
                ${performanceInputs}
                <div class="input-group">
                    <label>Type de s√©rie</label>
                    <select id="manual-set-type" class="select">
                        <option value="work">Travail</option>
                        <option value="warmup">√âchauffement</option>
                        <option value="dropset">S√©rie d√©gressif</option>
                        <option value="failure">Jusqu'√† l'√©chec</option>
                    </select>
                </div>
                <button class="btn btn-success btn-full" onclick="actions.saveManualSet()">
                    ‚úÖ Ajouter cette s√©rie
                </button>
                <button class="btn btn-primary btn-full" onclick="actions.nextManualExercise()">
                    ‚û°Ô∏è Exercice suivant
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.finishManualSession()">
                    üèÅ Terminer la s√©ance
                </button>
            `;
        }

        // === FONCTIONS UTILITAIRES ===
        actions.renderTemplatesModal = function() {
            const modalContent = document.getElementById('templates-modal-content');
            modalContent.innerHTML = '';
            
            if (appState.templates.length > 0) {
                appState.templates.forEach(template => {
                    const div = document.createElement('div');
                    div.className = 'exercise-item';
                    div.style.cursor = 'pointer';
                    div.onclick = () => actions.loadTemplate(template.id);
                    
                    const exerciseNames = template.exerciseIds
                        .map(id => appState.exercises.find(e => e.id === id)?.name)
                        .filter(name => name)
                        .join(', ');
                    
                    div.innerHTML = `
                        <div>
                            <strong>${template.name}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${exerciseNames}
                            </div>
                        </div>
                        <div>üëÜ</div>
                    `;
                    modalContent.appendChild(div);
                });
            } else {
                modalContent.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun mod√®le disponible</p>';
            }
        };

        actions.deleteSession = function(sessionId) {
            if (confirm('Supprimer cette s√©ance ?')) {
                appState.sessions = appState.sessions.filter(s => s.id !== sessionId);
                this.saveData();
                render();
                this.showNotification('S√©ance supprim√©e');
            }
        };

        // === INITIALISATION ===
        document.addEventListener('DOMContentLoaded', () => {
            console.log('SmartTrack - Initialisation de l\'application');
            actions.init();
        });

        // Fermeture des modals en cliquant √† l'ext√©rieur
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('active');
            }
        });
    
    
    </script>
    <script>
    // Enregistrement du Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            console.log('SmartTrack SW: Enregistr√© avec succ√®s');
            
            // √âcouter les mises √† jour
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // Nouvelle version disponible
                  console.log('SmartTrack: Nouvelle version disponible');
                  // Optionnel: afficher une notification √† l'utilisateur
                }
              });
            });
          })
          .catch(error => {
            console.log('SmartTrack SW: √âchec d\'enregistrement', error);
          });
      });
    }
  </script>
</body>
</html>
