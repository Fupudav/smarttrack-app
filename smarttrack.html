<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartTrack - Suivi Intelligent d'Entraînement</title>    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#007AFF">
    
    <style>
        /* === VARIABLES CSS === */
        :root {
            --primary: #007AFF;
            --primary-dark: #0056CC;
            --secondary: #34C759;
            --danger: #FF3B30;
            --warning: #FF9500;
            --background: #F2F2F7;
            --surface: #FFFFFF;
            --text-primary: #000000;
            --text-secondary: #6D6D70;
            --border: #C6C6C8;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --background: #1C1C1E;
            --surface: #2C2C2E;
            --text-primary: #FFFFFF;
            --text-secondary: #8E8E93;
            --border: #38383A;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        /* === RESET & BASE === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.5;
            overflow-x: hidden;
        }

        /* === LAYOUT === */
        .app-container {
            max-width: 100vw;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--background);
            display: flex;
            flex-direction: column;
            width: 100%;
            overflow-x: hidden;
        }

        .screen {
            display: none;
            flex: 1;
            padding: 16px;
            animation: slideIn 0.3s ease-out;
            width: 100%;
            box-sizing: border-box;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
        }

        /* Amélioration des items d'exercices */
        .exercise-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: var(--surface);
            border-radius: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 8px;
            min-height: 80px;
        }

        .exercise-item > div:first-child {
            flex: 1;
            min-width: 250px;
            word-wrap: break-word;
        }

        .exercise-item > div:last-child {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            min-width: 300px;
        }

        .exercise-item input[type="number"] {
            min-width: 70px;
            font-size: 14px;
            text-align: center;
            font-weight: bold;
        }

        .exercise-item span {
            font-size: 12px;
            white-space: nowrap;
            font-weight: 500;
        }

        /* Amélioration responsive */
        @media (max-width: 768px) {
            .exercise-item {
                flex-direction: column;
                align-items: stretch;
                padding: 12px;
            }
        
            .exercise-item > div:first-child {
                min-width: 100%;
                margin-bottom: 8px;
            }
        
            .exercise-item > div:last-child {
                justify-content: space-between;
                min-width: 100%;
            }
        
            .exercise-item input[type="number"] {
                min-width: 60px;
            }
        }

        /* Amélioration des cartes */
        .card {
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 10px var(--shadow);
            border: 1px solid var(--border);
            max-width: 100%;
            overflow-x: auto;
        }

        /* Amélioration des grilles de stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 16px 0;
        }

        /* Amélioration des inputs de performance */
            .performance-inputs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 24px 0;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* === NAVIGATION === */
        .nav-bar {
            background: var(--surface);
            border-top: 1px solid var(--border);
            padding: 10px 0;
            display: flex;
            justify-content: space-around;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            z-index: 100;
            box-shadow: 0 -2px 10px var(--shadow);
        }

        /* Compensation pour le menu fixe en bas */
        .screen {
            padding-bottom: 80px; /* Espace pour le menu de navigation */
        }

        /* Ajuster le padding existant */
        .screen.active {
            display: flex;
            flex-direction: column;
            padding-bottom: 80px;
        }

        .nav-item {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 12px;
            transition: color 0.2s;
        }

        .nav-item.active {
            color: var(--primary);
        }

        .nav-item:hover {
            color: var(--primary);
        }

        /* === COMPONENTS === */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
        }

        .card {
            background: var(--surface);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 10px var(--shadow);
            border: 1px solid var(--border);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            display: inline-block;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-success {
            background: var(--secondary);
            color: white;
        }

        .btn-full {
            width: 100%;
            margin-bottom: 12px;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .input, .select, .textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 16px;
            background: var(--surface);
            color: var(--text-primary);
            transition: border-color 0.2s;
        }

        .input:focus, .select:focus, .textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .textarea {
            resize: vertical;
            min-height: 80px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .checkbox {
            width: 20px;
            height: 20px;
        }

        /* === CALENDAR GRID === */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin: 16px 0;
            max-height: 120px;
            overflow: hidden;
        }

        .calendar-day {
            aspect-ratio: 1;
            border-radius: 4px;
            background: var(--border);
            opacity: 0.3;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            max-width: 20px;
            max-height: 20px;
        }

        .calendar-day.active {
            opacity: 1;
            background: var(--secondary);
            color: white;
        }

        .calendar-day.high-volume {
            background: var(--primary);
            color: white;
        }

        /* === STATS === */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin: 16px 0;
        }

        .stat-card {
            background: var(--surface);
            padding: 16px;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* === EXERCISE LIST === */
        .exercise-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: var(--surface);
            border-radius: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--border);
        }

        .exercise-actions {
            display: flex;
            gap: 8px;
        }

        /* === LIVE SESSION === */
        .session-timer {
            text-align: center;
            font-size: 48px;
            font-weight: 700;
            color: var(--primary);
            margin: 24px 0;
        }

        .current-exercise {
            text-align: center;
            margin: 24px 0;
        }

        .exercise-name {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .set-counter {
            font-size: 18px;
            color: var(--text-secondary);
        }

        .performance-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 24px 0;
        }

        .rest-timer {
            text-align: center;
            margin: 24px 0;
        }

        .rest-time {
            font-size: 72px;
            font-weight: 700;
            color: var(--warning);
        }

        .next-exercise {
            background: var(--surface);
            padding: 16px;
            border-radius: 12px;
            margin-top: 16px;
            border: 1px solid var(--border);
        }

        /* === MODAL === */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
        }

        /* === NOTIFICATION === */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--secondary);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 1001;
            display: none;
            /* Amélioration pour les séances live */
            max-width: 300px;
            font-size: 14px;
            text-align: center;
        }

        .notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        /* Style spécial pour les notifications en séance */
        .notification.live-session {
            top: 80px;
            background: var(--primary);
            opacity: 0.9;
            font-size: 12px;
            padding: 8px 16px;
        }

        @keyframes slideDown {
            from { transform: translate(-50%, -100%); }
            to { transform: translate(-50%, 0); }
        }

        /* === CHART CONTAINER === */
        .chart-container {
            height: 300px;
            margin: 20px 0;
            background: var(--surface);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
        }

        /* === RESPONSIVE === */
        @media (max-width: 480px) {
            .app-container {
                max-width: 100%;
            }
            
            .screen {
                padding: 16px;
            }
            
            .performance-inputs {
                grid-template-columns: 1fr;
            }
        }

        /* Styles pour les sections d'exercices (échauffement/principal) */
        .exercise-section-title {
            margin: 16px 0 8px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .exercise-section-title.warmup {
            color: var(--warning);
            border-color: var(--warning);
        }

        .exercise-section-title.main {
            color: var(--primary);
            border-color: var(--primary);
        }

        /* Styles pour les boutons de réorganisation */
        .reorder-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .reorder-buttons button {
            padding: 2px 6px;
            font-size: 10px;
            min-width: 24px;
            height: 20px;
        }

        .reorder-buttons button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Numérotation des exercices */
        .exercise-number {
            background: var(--primary);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
        }

        /* Groupes d'exercices dans les modèles */
        .exercise-group-title {
            margin: 16px 0 8px 0;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        /* Indicateurs de mode d'exercice */
        .exercise-mode-indicator {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--background);
            color: var(--text-secondary);
            margin-left: 8px;
        }

        /* Style pour les champs conditionnels */
        .conditional-input {
            transition: all 0.3s ease;
        }

        .conditional-input.hidden {
            display: none;
        }

        /* === RECHERCHE EXERCICES === */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 2px solid var(--primary);
            border-top: none;
            border-radius: 0 0 12px 12px;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px var(--shadow);
        }

        /* Ajustement responsive pour petits écrans */
        @media (max-width: 768px) {
            .search-results {
                max-height: 50vh;
            }
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-result-item:hover, .search-result-item.highlighted {
            background: var(--primary);
            color: white;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .search-result-details {
            font-size: 12px;
            opacity: 0.8;
        }

        .search-history-item {
            display: inline-block;
            background: var(--background);
            padding: 4px 8px;
            margin: 2px;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid var(--border);
            transition: background-color 0.2s;
        }

        .search-history-item:hover {
            background: var(--primary);
            color: white;
        }

        .search-no-results {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
        }
    </style>
    <script>
        // Empêcher le pull-to-refresh par défaut
        document.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });

        let startY = null;

        function handleTouchStart(evt) {
            startY = evt.touches[0].clientY;
        }

        function handleTouchMove(evt) {
            if (startY === null) return;
            
            const currentY = evt.touches[0].clientY;
            const diff = currentY - startY;
            
            // Si on tire vers le bas depuis le haut de la page
            if (diff > 0 && window.pageYOffset === 0) {
                evt.preventDefault(); // Empêcher le refresh
            }
            
            startY = null;
        }
    </script>
</head>
<body>
    <div class="app-container">
        <!-- Écran 0: Tableau de Bord -->
        <div id="screen-dashboard" class="screen active">
            <div class="header">
                <h1>SmartTrack</h1>
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">⚙️</button>
            </div>
            
            <div class="card">
                <h3>Calendrier de Régularité</h3>
                <div id="calendar-grid" class="calendar-grid"></div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-sessions">0</div>
                    <div class="stat-label">Séances Total</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="current-streak">0</div>
                    <div class="stat-label">Série Actuelle</div>
                </div>
            </div>
            
            <button class="btn btn-primary btn-full" onclick="actions.startNewSession()">
                🚀 Démarrer une séance vide
            </button>
            <button class="btn btn-secondary btn-full" onclick="actions.resumeLastSession()">
                📋 Reprendre la dernière séance
            </button>
        </div>

        <!-- Écran 1: Préparation de Séance -->
        <div id="screen-preparation" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('dashboard')">← Retour</button>
                <h1>Préparation</h1>
                <div></div>
            </div>
            
            <div class="card">
                <div class="input-group">
                    <label>Date de la séance</label>
                    <input type="date" id="session-date" class="input" onchange="actions.updateSessionDate(this.value)">
                </div>
                
                <div class="input-group">
                    <label>Notes de séance</label>
                    <textarea id="session-notes" class="textarea" placeholder="Notes optionnelles..." onchange="actions.updateSessionNotes(this.value)"></textarea>
                </div>
                
                <button class="btn btn-secondary btn-full" onclick="actions.showTemplates()">
                    📋 Charger un modèle
                </button>
            </div>

            <div class="card">
                <h3>Ajouter un exercice</h3>
                <div class="input-group">
                    <label>Rechercher un exercice</label>
                    <div style="position: relative;">
                        <input type="text" id="exercise-search" class="input" placeholder="Tapez le nom d'un exercice ou groupe musculaire..." autocomplete="off">
                        <div id="exercise-search-results" class="search-results" style="display: none;"></div>
                    </div>
                    <div id="search-history" style="margin-top: 8px; display: none;"></div>
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.addExerciseToSession()">
                    ➕ Ajouter à la séance
                </button>
            </div>
            
            <div class="card">
                <h3>Exercices prévus</h3>
                <div id="planned-exercises"></div>
            </div>
            
            <button class="btn btn-success btn-full" onclick="actions.startLiveSession()" id="start-live-btn" style="display: none;">
                🚀 Démarrer la Séance Live
            </button>

            <button class="btn btn-secondary btn-full" onclick="actions.saveSessionManually()" id="save-manual-btn" style="display: none;">
                💾 Sauvegarder sans Live
            </button>
        </div>

        <!-- Écran 2: Séance Live -->
        <div id="screen-live" class="screen">
            <div class="header">
                <button class="btn btn-small btn-warning" onclick="actions.pauseLiveSession()">⏸️ Pause</button>
                <div class="session-timer" id="live-timer">00:00</div>
                <button class="btn btn-small btn-danger" onclick="actions.stopLiveSession()">⏹️ Arrêter</button>
            </div>
            <div id="live-content"></div>
        </div>

        <!-- Écran 3: Historique -->
        <div id="screen-history" class="screen">
            <div class="header">
                <h1>Historique</h1>
                <div class="stat-value" id="history-count">0</div>
            </div>
            
            <div id="sessions-list"></div>
        </div>

        <!-- Écran 4: Statistiques -->
        <div id="screen-stats" class="screen">
            <div class="header">
                <h1>Statistiques</h1>
            </div>
            
            <div class="card">
                <div class="input-group">
                    <label>Sélectionner un exercice</label>
                    <select id="stats-exercise-select" class="select" onchange="actions.updateStats(this.value)">
                        <option value="">Choisir un exercice...</option>
                    </select>
                </div>
            </div>
            
            <div id="stats-content"></div>
        </div>

        <!-- Écran 5: Suivi Corporel -->
        <div id="screen-body" class="screen">
            <div class="header">
                <h1>Mensurations</h1>
            </div>
            
            <div class="card">
                <h3>Nouvelle mensuration</h3>
                <div class="input-group">
                    <label>Date</label>
                    <input type="date" id="measurement-date" class="input">
                </div>
                <div class="input-group">
                    <label>Taille (cm)</label>
                    <input type="number" id="measurement-height" class="input" step="0.5" min="100" max="250">
                </div>
                <div class="input-group">
                    <label>Poids (kg)</label>
                    <input type="number" id="measurement-weight" class="input" step="0.1">
                </div>
                <div class="input-group">
                    <label>Tour de taille (cm)</label>
                    <input type="number" id="measurement-waist" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de poitrine (cm)</label>
                    <input type="number" id="measurement-chest" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de bras (cm)</label>
                    <input type="number" id="measurement-arm" class="input" step="0.5">
                </div>
                <div class="input-group">
                    <label>Tour de cuisse (cm)</label>
                    <input type="number" id="measurement-thigh" class="input" step="0.5">
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.addMeasurement()">
                    ➕ Ajouter la mensuration
                </button>
            </div>
            
            <div class="card">
                <h3>Évolution des mensurations</h3>
                <div class="chart-container">
                    📊 Graphiques d'évolution des mensurations
                </div>
            </div>
            
            <div id="measurements-list"></div>
        </div>

        <!-- Écran 6: Gestion des Exercices -->
        <div id="screen-exercises" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">← Retour</button>
                <h1>Exercices</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3 id="exercise-form-title">Nouvel exercice</h3>
                
                <div class="input-group">
                    <label>Nom de l'exercice</label>
                    <input type="text" id="exercise-name" class="input" placeholder="Ex: Développé couché">
                </div>
                
                <!-- NOUVEAU: Catégorie principale -->
                <div class="input-group">
                    <label>Catégorie</label>
                    <select id="exercise-category" class="select">
                        <option value="strength">Renforcement</option>
                        <option value="warmup">Échauffement</option>
                    </select>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="exercise-unilateral" class="checkbox">
                    <label for="exercise-unilateral">Exercice unilatéral</label>
                </div>
                
                <!-- NOUVEAU: Mode d'exercice -->
                <div class="input-group">
                    <label>Mode d'exécution</label>
                    <select id="exercise-mode" class="select" onchange="toggleExerciseMode()">
                        <option value="reps">Répétitions</option>
                        <option value="time">Temps</option>
                        <option value="both">Répétitions ou Temps</option>
                    </select>
                </div>
                
                <!-- NOUVEAU: Durée par défaut (affiché si mode temps) -->
                <div class="input-group" id="duration-group" style="display: none;">
                    <label>Durée par défaut (secondes)</label>
                    <input type="number" id="exercise-duration" class="input" value="30" min="10" max="300">
                </div>
                
                <div class="input-group">
                    <label>Temps de repos par défaut (secondes)</label>
                    <input type="number" id="exercise-rest" class="input" value="90">
                </div>
                
                <div class="input-group">
                    <label>Groupe musculaire</label>
                    <select id="exercise-muscle-group" class="select">
                        <option value="echauffement">Échauffement</option>
                        <option value="biceps">Biceps</option>
                        <option value="triceps">Triceps</option>
                        <option value="epaules">Épaules</option>
                        <option value="dos">Dos</option>
                        <option value="pectoraux">Pectoraux</option>
                        <option value="jambes">Jambes</option>
                        <option value="autres">Autres</option>
                    </select>
                </div>
                
                <div class="input-group">
                    <label>Point d'ancrage</label>
                    <select id="exercise-anchor" class="select" onchange="showExerciseExamples(this.value)">
                        <option value="none">🏃 Sans ancrage (élastique libre)</option>
                        <option value="door-middle">🚪 Porte - hauteur moyenne</option>
                        <option value="door-high">🚪⬆️ Porte - position haute</option>
                        <option value="door-low">🚪⬇️ Porte - position basse</option>
                        <option value="floor">🦵 Sol/Pieds (marcher dessus)</option>
                        <option value="body">🔄 Corps (élastique autour)</option>
                        <option value="external">🌳 Ancrage extérieur</option>
                    </select>
                    <div id="exercise-examples" style="margin-top: 8px; padding: 8px; background: var(--background); border-radius: 6px; font-size: 12px; color: var(--text-secondary); display: none;">
                        <strong>Exemples d'exercices :</strong>
                        <div id="examples-list"></div>
                    </div>
                </div>
                
                <button class="btn btn-primary btn-full" onclick="actions.saveExercise()" id="save-exercise-btn">
                    ➕ Ajouter l'exercice
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.loadPredefinedExercises()" id="load-predefined-btn">
                    📚 Charger les exercices SmartWorkout
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.cancelExerciseEdit()" id="cancel-exercise-btn" style="display: none;">
                    ❌ Annuler
                </button>
            </div>
            
            <div class="card">
                <h3>Mes exercices</h3>
                <div id="exercises-list"></div>
            </div>
        </div>

        <!-- Écran 7: Gestion des Modèles -->
        <div id="screen-templates" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showSettings()">← Retour</button>
                <h1>Modèles</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3>Nouveau modèle</h3>
                <div class="input-group">
                    <label>Nom du modèle</label>
                    <input type="text" id="template-name" class="input" placeholder="Ex: Push Day">
                </div>
                <div class="input-group">
                    <label>Exercices</label>
                    <div id="template-exercises-checkboxes"></div>
                </div>
                <button class="btn btn-primary btn-full" onclick="actions.saveTemplate()">
                    ➕ Créer le modèle
                </button>
            </div>
            
            <div class="card">
                <h3>Mes modèles</h3>
                <div id="templates-list"></div>
            </div>
        </div>

        <!-- Écran 8: Paramètres -->
        <div id="screen-settings" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('dashboard')">← Retour</button>
                <h1>Paramètres</h1>
                <div></div>
            </div>
            
            <div class="card">
                <h3>Apparence</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="dark-theme" class="checkbox" onchange="actions.toggleTheme()">
                    <label for="dark-theme">Thème sombre</label>
                </div>
            </div>
            
            <div class="card">
                <h3>Données</h3>
                <button class="btn btn-secondary btn-full" onclick="actions.exportData()">
                    📤 Exporter les données
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.showImportModal()">
                    📥 Importer les données
                </button>
                <button class="btn btn-danger btn-full" onclick="actions.clearAllData()">
                    🗑️ Effacer toutes les données
                </button>
            </div>
            
            <div class="card">
                <h3>Gestion</h3>
                <button class="btn btn-secondary btn-full" onclick="actions.showScreen('exercises')">
                    💪 Gérer les exercices
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.showScreen('templates')">
                    📋 Gérer les modèles
                </button>
            </div>
        </div>

        <!-- Écran 9: Saisie Manuelle -->
        <div id="screen-manual-entry" class="screen">
            <div class="header">
                <button class="btn btn-small btn-secondary" onclick="actions.showScreen('preparation')">← Retour</button>
                <h1>Saisie Manuelle</h1>
                <div></div>
            </div>
            
            <div id="manual-entry-content"></div>
        </div>

        <!-- Navigation -->
        <nav class="nav-bar">
            <div class="nav-item active" onclick="actions.showScreen('dashboard')">
                <div>🏠</div>
                <div>Accueil</div>
            </div>
            <div class="nav-item" onclick="actions.goToSession()">
                <div>⚡</div>
                <div>Séance</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('history')">
                <div>📊</div>
                <div>Historique</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('stats')">
                <div>📈</div>
                <div>Stats</div>
            </div>
            <div class="nav-item" onclick="actions.showScreen('body')">
                <div>⚖️</div>
                <div>Corporel</div>
            </div>
        </nav>
    </div>

    <!-- Modals -->
    <div id="templates-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Charger un modèle</h3>
                <button class="close-btn" onclick="actions.closeModal('templates-modal')">&times;</button>
            </div>
            <div id="templates-modal-content"></div>
        </div>
    </div>

    <div id="import-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Importer des données</h3>
                <button class="close-btn" onclick="actions.closeModal('import-modal')">&times;</button>
            </div>
            <div class="input-group">
                <label>Données JSON</label>
                <textarea id="import-data" class="textarea" rows="10" placeholder="Collez vos données JSON ici..."></textarea>
            </div>
            <button class="btn btn-primary btn-full" onclick="actions.importData()">
                📥 Importer
            </button>
        </div>
    </div>

    <!-- Modal difficulté de séance -->
    <div id="difficulty-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🎯 Comment s'est passée votre séance ?</h3>
            </div>
            <p style="text-align: center; color: var(--text-secondary); margin: 16px 0;">
                Cette information nous aide à suivre votre progression
            </p>
            <div style="display: grid; gap: 12px; margin: 20px 0;">
                <button class="btn btn-success btn-full" onclick="actions.finishSessionWithDifficulty('Facile')" style="padding: 16px;">
                    😊 Facile
                    <div style="font-size: 12px; opacity: 0.8;">J'aurais pu faire plus</div>
                </button>
                <button class="btn btn-primary btn-full" onclick="actions.finishSessionWithDifficulty('Normale')" style="padding: 16px;">
                    💪 Normale  
                    <div style="font-size: 12px; opacity: 0.8;">Effort modéré, bien dosé</div>
                </button>
                <button class="btn btn-danger btn-full" onclick="actions.finishSessionWithDifficulty('Difficile')" style="padding: 16px;">
                    🔥 Difficile
                    <div style="font-size: 12px; opacity: 0.8;">J'ai donné le maximum</div>
                </button>
            </div>
            <button class="btn btn-secondary btn-full" onclick="actions.finishSessionWithDifficulty(null)" style="margin-top: 8px;">
                Passer
            </button>
        </div>
    </div>

    <!-- Modal d'édition de séance -->
    <div id="edit-session-modal" class="modal">
        <div class="modal-content" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3>✏️ Modifier la séance</h3>
                <button class="close-btn" onclick="actions.closeModal('edit-session-modal')">×</button>
            </div>
            <div id="edit-session-content"></div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification"></div>

    <script>
        // === BASE DE DONNÉES DES ÉLASTIQUES SMARTWORKOUT ELITE ===
        const ELASTICS_DB = {
            cyan: { name: 'Cyan', resistance: 25, color: '#00FFFF', quantity: 3 },
            black: { name: 'Noir', resistance: 20, color: '#000000', quantity: 3 },
            blue: { name: 'Bleu', resistance: 15, color: '#0000FF', quantity: 1 },
            green: { name: 'Vert', resistance: 10, color: '#00FF00', quantity: 1 },
            beige: { name: 'Beige', resistance: 5, color: '#F5F5DC', quantity: 1 }
        };

        // === BASE DE DONNÉES DES RÉSISTANCES CONSEILLÉES ===
        const RESISTANCE_RECOMMENDATIONS = {
            // BICEPS
            'Curl biceps': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 30, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 25, max: 50, elastics: ['Noir', 'Cyan'] }
            },
            'Curl biceps (poulie basse)': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 30, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 25, max: 50, elastics: ['Noir', 'Cyan'] }
            },
            'Curl biceps face à la porte': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 30, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 25, max: 50, elastics: ['Noir', 'Cyan'] }
            },
            'Curl marteau': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 30, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 25, max: 50, elastics: ['Noir', 'Cyan'] }
            },
            
            // TRICEPS
            'Extension triceps (poulie haute)': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 30, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 25, max: 50, elastics: ['Noir', 'Cyan'] }
            },
            'Extension triceps verticale': {
                beginner: { min: 5, max: 10, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 10, max: 25, elastics: ['Vert', 'Bleu'] },
                advanced: { min: 20, max: 40, elastics: ['Bleu', 'Noir', 'Cyan'] }
            },
            'Kickback triceps': {
                beginner: { min: 5, max: 10, elastics: ['Beige'] },
                intermediate: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                advanced: { min: 15, max: 35, elastics: ['Bleu', 'Noir'] }
            },
            
            // ÉPAULES
            'Élévations latérales': {
                beginner: { min: 5, max: 10, elastics: ['Beige'] },
                intermediate: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                advanced: { min: 15, max: 35, elastics: ['Bleu', 'Noir'] }
            },
            'Élévations frontales': {
                beginner: { min: 5, max: 10, elastics: ['Beige'] },
                intermediate: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                advanced: { min: 15, max: 35, elastics: ['Bleu', 'Noir'] }
            },
            'Développé militaire assis': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 40, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 35, max: 65, elastics: ['Noir', 'Cyan'] }
            },
            'Oiseau': {
                beginner: { min: 5, max: 10, elastics: ['Beige'] },
                intermediate: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                advanced: { min: 15, max: 35, elastics: ['Bleu', 'Noir'] }
            },
            
            // DOS
            'Face Pull': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 35, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 30, max: 55, elastics: ['Noir', 'Cyan'] }
            },
            'Tirage horizontal unilatéral': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 35, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 30, max: 55, elastics: ['Noir', 'Cyan'] }
            },
            'Tirage vertical': {
                beginner: { min: 15, max: 25, elastics: ['Bleu', 'Noir'] },
                intermediate: { min: 25, max: 45, elastics: ['Noir', 'Cyan'] },
                advanced: { min: 40, max: 70, elastics: ['Cyan x2'] }
            },
            'Rowing buste penché': {
                beginner: { min: 15, max: 25, elastics: ['Bleu', 'Noir'] },
                intermediate: { min: 25, max: 45, elastics: ['Noir', 'Cyan'] },
                advanced: { min: 40, max: 70, elastics: ['Cyan x2'] }
            },
            
            // PECTORAUX
            'Développé debout (poulie moyenne)': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 35, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 30, max: 55, elastics: ['Noir', 'Cyan'] }
            },
            'Développé incliné': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 35, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 30, max: 55, elastics: ['Noir', 'Cyan'] }
            },
            'Écarté unilatéral': {
                beginner: { min: 5, max: 15, elastics: ['Beige', 'Vert'] },
                intermediate: { min: 15, max: 25, elastics: ['Vert', 'Bleu', 'Noir'] },
                advanced: { min: 20, max: 40, elastics: ['Noir', 'Cyan'] }
            },
            'Pompes lestées': {
                beginner: { min: 10, max: 25, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 25, max: 45, elastics: ['Noir', 'Cyan'] },
                advanced: { min: 40, max: 75, elastics: ['Cyan x2'] }
            },
            
            // JAMBES
            'Squat': {
                beginner: { min: 20, max: 35, elastics: ['Noir', 'Cyan'] },
                intermediate: { min: 35, max: 60, elastics: ['Cyan x2'] },
                advanced: { min: 55, max: 95, elastics: ['Cyan x2 ou x3'] }
            },
            'Front squat': {
                beginner: { min: 15, max: 30, elastics: ['Bleu', 'Noir'] },
                intermediate: { min: 30, max: 50, elastics: ['Noir', 'Cyan'] },
                advanced: { min: 45, max: 80, elastics: ['Cyan x2'] }
            },
            'Fentes': {
                beginner: { min: 10, max: 20, elastics: ['Vert', 'Bleu'] },
                intermediate: { min: 20, max: 35, elastics: ['Bleu', 'Noir'] },
                advanced: { min: 30, max: 60, elastics: ['Noir', 'Cyan'] }
            },
            'Hip thrust': {
                beginner: { min: 25, max: 40, elastics: ['Noir', 'Cyan'] },
                intermediate: { min: 40, max: 65, elastics: ['Cyan x2'] },
                advanced: { min: 60, max: 100, elastics: ['Cyan x3'] }
            },
            'Soulevé de terre': {
                beginner: { min: 25, max: 40, elastics: ['Noir', 'Cyan'] },
                intermediate: { min: 40, max: 70, elastics: ['Cyan x2'] },
                advanced: { min: 65, max: 110, elastics: ['Cyan x3'] }
            }
        };

        // Base de données des exercices pré-définis SmartWorkout
        const PREDEFINED_EXERCISES = {
            echauffement: [
                { name: 'Jumping Jacks', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Montées de genoux', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Talons-fesses', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Burpees', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Planche', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Planche latérale', anchor: 'none', unilateral: true, timeBase: true },
                { name: 'Mountain climbers', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Squats au poids du corps', anchor: 'none', unilateral: false, timeBase: false },
                { name: 'Pompes', anchor: 'none', unilateral: false, timeBase: false },
                { name: 'Fentes alternées', anchor: 'none', unilateral: true, timeBase: false },
                { name: 'Rotations épaules', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Cercles de bras', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Étirements dynamiques', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'High knees', anchor: 'none', unilateral: false, timeBase: true },
                { name: 'Pas chassés', anchor: 'none', unilateral: false, timeBase: true }
            ],
            
            biceps: [
                { name: 'Curl biceps', anchor: 'none', unilateral: false },
                { name: 'Curl biceps (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Curl biceps face à la porte', anchor: 'door-middle', unilateral: false },
                { name: 'Curl marteau', anchor: 'none', unilateral: false },
                { name: 'Curl marteau (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Curl biceps avec poignée', anchor: 'none', unilateral: false },
                { name: 'Curl biceps en pronation', anchor: 'none', unilateral: false }
            ],
            epaules: [
                { name: 'Cuban press', anchor: 'none', unilateral: false },
                { name: 'Développé arnold', anchor: 'none', unilateral: false },
                { name: 'Développé militaire assis', anchor: 'floor', unilateral: false },
                { name: 'Élévations frontales', anchor: 'none', unilateral: false },
                { name: 'Élévations latérales', anchor: 'none', unilateral: false },
                { name: 'Oiseau', anchor: 'door-middle', unilateral: false },
                { name: 'Overhead press', anchor: 'none', unilateral: false },
                { name: 'Reverse fly', anchor: 'door-middle', unilateral: false },
                { name: 'Reverse fly unilatéral', anchor: 'door-middle', unilateral: true },
                { name: 'Shrug', anchor: 'none', unilateral: false },
                { name: 'Tirage menton', anchor: 'door-low', unilateral: false }
            ],
            dos: [
                { name: 'Face Pull', anchor: 'door-middle', unilateral: false },
                { name: 'Face pull (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Pull-Over', anchor: 'door-high', unilateral: false },
                { name: 'Rowing buste penché', anchor: 'floor', unilateral: false },
                { name: 'Rowing buste penché (prise large)', anchor: 'floor', unilateral: false },
                { name: 'Rowing buste penché (prise serrée)', anchor: 'floor', unilateral: false },
                { name: 'Soulevé de terre', anchor: 'floor', unilateral: false },
                { name: 'Soulevé de terre (prise large)', anchor: 'floor', unilateral: false },
                { name: 'Tirage Bucheron (poulie basse)', anchor: 'door-low', unilateral: true },
                { name: 'Tirage horizontal unilatéral', anchor: 'door-middle', unilateral: true },
                { name: 'Tirage poulie basse', anchor: 'door-low', unilateral: false },
                { name: 'Tirage poulie basse (supination)', anchor: 'door-low', unilateral: false },
                { name: 'Tirage vertical', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical (prise serrée)', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical (supination)', anchor: 'door-high', unilateral: false },
                { name: 'Tirage vertical unilatéral', anchor: 'door-high', unilateral: true }
            ],
            jambes: [
                { name: 'Abduction de hanches', anchor: 'body', unilateral: false },
                { name: 'Adduction de hanches', anchor: 'body', unilateral: false },
                { name: 'Donkey kick', anchor: 'body', unilateral: true },
                { name: 'Donkey kick (jambes fléchies)', anchor: 'body', unilateral: true },
                { name: 'Extensions mollets', anchor: 'floor', unilateral: false },
                { name: 'Extensions mollets unilatérales', anchor: 'floor', unilateral: true },
                { name: 'Fentes', anchor: 'none', unilateral: true },
                { name: 'Fentes bulgares', anchor: 'none', unilateral: true },
                { name: 'Front squat', anchor: 'floor', unilateral: false },
                { name: 'Hip thrust', anchor: 'body', unilateral: false },
                { name: 'Leg curl', anchor: 'body', unilateral: false },
                { name: 'Leg extension unilatérale', anchor: 'body', unilateral: true },
                { name: 'Soulevé de terre jambes tendues', anchor: 'floor', unilateral: false },
                { name: 'Squat', anchor: 'none', unilateral: false },
                { name: 'Squat sumo', anchor: 'floor', unilateral: false },
                { name: 'Squat swing', anchor: 'none', unilateral: false },
                { name: 'Thruster', anchor: 'floor', unilateral: false }
            ],
            pectoraux: [
                { name: 'Développé épaules debout', anchor: 'none', unilateral: false },
                { name: 'Développé debout (poulie moyenne)', anchor: 'door-middle', unilateral: false },
                { name: 'Développé debout (2 ancrages)', anchor: 'door-middle', unilateral: false },
                { name: 'Développé décliné', anchor: 'door-low', unilateral: false },
                { name: 'Développé incliné', anchor: 'door-high', unilateral: false },
                { name: 'Développé incliné (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Développé joint (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Développé joint (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'Développé 1 ancrage (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'Développé joint (poulie moyenne)', anchor: 'door-middle', unilateral: false },
                { name: 'Écarté unilatéral', anchor: 'door-middle', unilateral: true },
                { name: 'Écarté unilatéral (poulie basse)', anchor: 'door-low', unilateral: true },
                { name: 'Écarté unilatéral (poulie haute)', anchor: 'door-high', unilateral: true },
                { name: 'Pompes lestées', anchor: 'body', unilateral: false }
            ],
            triceps: [
                { name: 'Triceps barre au front', anchor: 'door-high', unilateral: false },
                { name: 'Extension triceps (poulie haute)', anchor: 'door-high', unilateral: false },
                { name: 'Extension triceps verticale', anchor: 'none', unilateral: false },
                { name: 'Extension triceps verticale (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Kickback triceps (poulie basse)', anchor: 'door-low', unilateral: false },
                { name: 'Kickback triceps unilatéral', anchor: 'door-low', unilateral: true }
            ]
        };

        // Base de données des synonymes pour la recherche intelligente
        const EXERCISE_SYNONYMS = {
            'biceps': ['bicep', 'bras', 'curl', 'flexion'],
            'triceps': ['tricep', 'extension', 'bras'],
            'epaules': ['épaule', 'shoulder', 'deltoide', 'deltoïde', 'lateral', 'frontal'],
            'dos': ['back', 'tirage', 'rowing', 'pull', 'traction'],
            'pectoraux': ['pec', 'chest', 'poitrine', 'développé', 'ecarté'],
            'jambes': ['leg', 'cuisse', 'squat', 'fente', 'mollet'],
            'echauffement': ['warmup', 'warm', 'prep', 'preparation', 'chauffe'],
            'abdos': ['abdominal', 'core', 'gainage', 'planche'],
            'cardio': ['course', 'vélo', 'rameur', 'endurance']
        };

        // Historique des recherches (stocké en localStorage)
        let searchHistory = [];

        // Fonctions de recherche intelligente
        const smartSearch = {
            // Fonction principale de recherche
            search(query, exercises = appState.exercises) {
                if (!query || query.length < 1) {
                    return exercises;
                }
                
                // Si la query est très courte (1 caractère), retourner tous les exercices
                if (query.length < 2) {
                    return exercises;
                }
                
                query = query.toLowerCase().trim();
                
                // Vérifier le cache
                const cacheKey = { query, exercisesCount: exercises.length };
                const cached = smartCache.get('exerciseSearch', cacheKey);
                if (cached) {
                    console.log('🔍 Résultats de recherche récupérés du cache');
                    this.addToHistory(query);
                    return cached;
                }
                
                console.log('🔍 Recherche d\'exercices...');
                this.addToHistory(query);

                const results = exercises.filter(exercise => {
                    return this.matchExercise(exercise, query);
                });

                // Mettre en cache les résultats et les retourner
                const sortedResults = this.sortByRelevance(results, query);
                return smartCache.set('exerciseSearch', cacheKey, sortedResults);
            },
        
            // Vérifier si un exercice correspond à la recherche
            matchExercise(exercise, query) {
                const searchTerms = query.split(' ').filter(term => term.length > 1);
            
                return searchTerms.every(term => {
                    // Recherche dans le nom
                    if (exercise.name.toLowerCase().includes(term)) return true;
                    
                    // Recherche dans le groupe musculaire
                    if (exercise.muscle_group && exercise.muscle_group.toLowerCase().includes(term)) return true;
                    
                    // Recherche avec tolérance aux fautes de frappe (distance de Levenshtein simplifiée)
                    if (this.fuzzyMatch(exercise.name.toLowerCase(), term)) return true;
                    
                    // Recherche dans les synonymes
                    if (this.matchSynonyms(exercise.muscle_group, term)) return true;
                    
                    // Recherche dans le type d'ancrage
                    if (exercise.anchor_point && this.matchAnchor(exercise.anchor_point, term)) return true;
                    
                    return false;
                });
            },
        
            // Correspondance floue pour les fautes de frappe
            fuzzyMatch(text, term) {
                if (term.length < 3) return false;
            
                // Recherche avec 1 caractère de différence maximum
                for (let i = 0; i <= text.length - term.length; i++) {
                    const substring = text.substring(i, i + term.length);
                    if (this.levenshteinDistance(substring, term) <= 1) {
                        return true;
                    }
                }
                return false;
            },
        
            // Distance de Levenshtein simplifiée
            levenshteinDistance(str1, str2) {
                if (str1.length !== str2.length) return 999;
                let diff = 0;
                for (let i = 0; i < str1.length; i++) {
                    if (str1[i] !== str2[i]) diff++;
                }
                return diff;
            },
        
            // Correspondance avec les synonymes
            matchSynonyms(muscleGroup, term) {
                if (!muscleGroup || !EXERCISE_SYNONYMS[muscleGroup]) return false;
                
                return EXERCISE_SYNONYMS[muscleGroup].some(synonym => 
                    synonym.toLowerCase().includes(term) || term.includes(synonym.toLowerCase())
                );
            },
        
            // Correspondance avec les points d'ancrage
            matchAnchor(anchorPoint, term) {
                const anchorTerms = {
                    'door': ['porte', 'door'],
                    'floor': ['sol', 'pied', 'floor'],
                    'body': ['corps', 'body'],
                    'none': ['libre', 'sans', 'none'],
                    'external': ['extérieur', 'externe', 'external']
                };
                
                for (const [anchor, terms] of Object.entries(anchorTerms)) {
                    if (anchorPoint.includes(anchor) && terms.some(t => term.includes(t))) {
                        return true;
                    }
                }
                return false;
            },
        
            // Trier par pertinence
            sortByRelevance(results, query) {
                return results.sort((a, b) => {
                    const scoreA = this.calculateRelevanceScore(a, query);
                    const scoreB = this.calculateRelevanceScore(b, query);
                    return scoreB - scoreA;
                });
            },
        
            // Calculer le score de pertinence
            calculateRelevanceScore(exercise, query) {
                let score = 0;
                const lowerQuery = query.toLowerCase();
                const lowerName = exercise.name.toLowerCase();
                
                // Correspondance exacte dans le nom = score max
                if (lowerName.includes(lowerQuery)) score += 100;
                
                // Correspondance au début du nom
                if (lowerName.startsWith(lowerQuery)) score += 50;
                
                // Correspondance dans le groupe musculaire
                if (exercise.muscle_group && exercise.muscle_group.toLowerCase().includes(lowerQuery)) {
                    score += 30;
                }
                
                // Bonus pour les exercices populaires
                const popularExercises = ['curl', 'squat', 'développé', 'tirage', 'fente'];
                if (popularExercises.some(pop => lowerName.includes(pop))) score += 10;
                
                return score;
            },
        
            // Ajouter à l'historique
            addToHistory(query) {
                // Éviter les doublons
                searchHistory = searchHistory.filter(item => item.query !== query);
                
                // Ajouter en première position
                searchHistory.unshift({
                    query: query,
                    timestamp: Date.now()
                });
                
                // Limiter à 10 recherches
                if (searchHistory.length > 10) {
                    searchHistory = searchHistory.slice(0, 10);
                }
                
                // Sauvegarder dans localStorage
                storage.save('searchHistory', searchHistory);
            },
        
            // Charger l'historique
            loadHistory() {
                searchHistory = storage.load('searchHistory', []);
                return searchHistory;
            },
        
            // Effacer l'historique
            clearHistory() {
                searchHistory = [];
                storage.remove('searchHistory');
            }
        };

        class ExerciseTimer {
            constructor() {
                this.duration = 0;
                this.timeLeft = 0;
                this.isRunning = false;
                this.isPaused = false;
                this.interval = null;
                this.audioContext = null;
                this.onTick = null;
                this.onComplete = null;
                
                // Initialiser le contexte audio
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio non supporté');
                }
            }
            
            // Configurer le timer
            setup(duration, onTick, onComplete) {
                this.duration = duration;
                this.timeLeft = duration;
                this.onTick = onTick;
                this.onComplete = onComplete;
                this.isRunning = false;
                this.isPaused = false;
                
                if (this.interval) {
                    clearInterval(this.interval);
                }
            }
            
            // Démarrer le timer
            start() {
                if (this.isRunning && !this.isPaused) return;
                
                this.isRunning = true;
                this.isPaused = false;
                
                this.interval = setInterval(() => {
                    if (this.timeLeft > 0) {
                        this.timeLeft--;
                        
                        // Appeler la fonction de mise à jour
                        if (this.onTick) {
                            this.onTick(this.timeLeft, this.duration);
                        }
                        
                        // Alertes sonores
                        if (this.timeLeft === 5 || this.timeLeft === 3 || this.timeLeft === 1) {
                            this.playBeep(800, 200);
                        }
                        
                        // Vibration dans les dernières secondes
                        if (this.timeLeft <= 3 && 'vibrate' in navigator) {
                            navigator.vibrate(100);
                        }
                        
                    } else {
                        // Timer terminé
                        this.complete();
                    }
                }, 1000);
            }
            
            // Mettre en pause
            pause() {
                this.isPaused = true;
                if (this.interval) {
                    clearInterval(this.interval);
                }
            }
            
            // Arrêter complètement
            stop() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.interval) {
                    clearInterval(this.interval);
                }
                this.timeLeft = this.duration;
            }
            
            // Timer terminé
            complete() {
                this.isRunning = false;
                this.isPaused = false;
                if (this.interval) {
                    clearInterval(this.interval);
                }
                
                // Son de fin plus long
                this.playBeep(1000, 500);
                
                // Vibration de fin
                if ('vibrate' in navigator) {
                    navigator.vibrate([200, 100, 200]);
                }
                
                // Appeler la fonction de completion
                if (this.onComplete) {
                    this.onComplete();
                }
            }
            
            // Jouer un bip sonore
            playBeep(frequency = 800, duration = 200) {
                if (!this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (e) {
                    console.log('Erreur audio:', e);
                }
            }
            
            // Formater le temps MM:SS
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            

            // Ajouter du temps
            addTime(seconds) {
                this.timeLeft += seconds;
                this.duration += seconds;
                if (this.onTick) {
                    this.onTick(this.timeLeft, this.duration);
                }
            }
            
            // Enlever du temps
            removeTime(seconds) {
                this.timeLeft = Math.max(0, this.timeLeft - seconds);
                if (this.timeLeft === 0) {
                    this.complete();
                } else if (this.onTick) {
                    this.onTick(this.timeLeft, this.duration);
                }
            }
        }

        // Instance globale du timer
        let exerciseTimer = new ExerciseTimer();

        // Fonctions globales pour contrôler le timer
        function startExerciseTimer() {
            exerciseTimer.start();
            updateTimerButtons();
        }

        function pauseExerciseTimer() {
            exerciseTimer.pause();
            updateTimerButtons();
        }

        function stopExerciseTimer() {
            exerciseTimer.stop();
            updateTimerButtons();
            // Remettre l'affichage par défaut
            const timerDisplay = document.getElementById('exercise-timer-display');
            if (timerDisplay) {
                timerDisplay.textContent = exerciseTimer.formatTime(exerciseTimer.duration);
                timerDisplay.style.color = 'var(--primary)';
            }
        }

        function addExerciseTime() {
            exerciseTimer.addTime(10); // Ajouter 10 secondes
        }

        function removeExerciseTime() {
            exerciseTimer.removeTime(10); // Enlever 10 secondes
        }

        function updateTimerButtons() {
            const startBtn = document.getElementById('timer-start-btn');
            const pauseBtn = document.getElementById('timer-pause-btn');
            const stopBtn = document.getElementById('timer-stop-btn');
            
            if (startBtn && pauseBtn && stopBtn) {
                if (exerciseTimer.isRunning && !exerciseTimer.isPaused) {
                    startBtn.style.display = 'none';
                    pauseBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'inline-block';
                } else if (exerciseTimer.isPaused) {
                    startBtn.style.display = 'inline-block';
                    pauseBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    startBtn.style.display = 'inline-block';
                    pauseBtn.style.display = 'none';
                    stopBtn.style.display = 'none';
                }
            }
        }

        // Fonction pour générer l'interface du timer
        function generateTimerInterface(exercise, prefix = '') {
            // Récupérer la durée personnalisée si elle existe
            let defaultDuration = 30;
            if (appState.liveSession) {
                const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                defaultDuration = currentExercise?.duration || exercise.default_duration || 30;
            } else if (appState.manualSession) {
                const currentExercise = appState.manualSession.exercises[appState.manualSession.currentExerciseIndex];
                defaultDuration = currentExercise?.duration || exercise.default_duration || 30;
            } else {
                defaultDuration = exercise.default_duration || 30;
            }
            
            return `
                <div class="exercise-timer-container" style="text-align: center; margin: 20px 0; padding: 20px; background: var(--surface); border-radius: 16px; border: 2px solid var(--primary);">
                    <h3 style="margin-bottom: 16px; color: var(--primary);">⏱️ Timer d'exercice</h3>
                    
                    <!-- Affichage du timer -->
                    <div id="exercise-timer-display" style="font-size: 48px; font-weight: bold; color: var(--primary); margin: 16px 0;">
                        ${exerciseTimer.formatTime(defaultDuration)}
                    </div>
                    
                    <!-- Contrôles de temps -->
                    <div style="display: flex; justify-content: center; gap: 8px; margin: 16px 0;">
                        <button class="btn btn-small btn-secondary" onclick="removeExerciseTime()" style="font-size: 18px; padding: 8px 12px;">-10s</button>
                        <input type="number" id="${prefix}duration" class="input" value="${defaultDuration}" min="10" max="300" 
                            style="width: 80px; text-align: center; font-weight: bold;" 
                            onchange="setupTimerDuration(this.value)">
                        <button class="btn btn-small btn-secondary" onclick="addExerciseTime()" style="font-size: 18px; padding: 8px 12px;">+10s</button>
                    </div>
                    
                    <!-- Boutons de contrôle -->
                    <div style="display: flex; justify-content: center; gap: 12px; margin: 16px 0;">
                        <button id="timer-start-btn" class="btn btn-success" onclick="startExerciseTimer()" style="display: inline-block;">
                            ▶️ Start
                        </button>
                        <button id="timer-pause-btn" class="btn btn-warning" onclick="pauseExerciseTimer()" style="display: none;">
                            ⏸️ Pause
                        </button>
                        <button id="timer-stop-btn" class="btn btn-danger" onclick="stopExerciseTimer()" style="display: none;">
                            ⏹️ Stop
                        </button>
                    </div>
                    
                    <!-- Indicateur de progression -->
                    <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin: 16px 0;">
                        <div id="timer-progress" style="height: 100%; background: var(--primary); width: 100%; transition: width 1s linear;"></div>
                    </div>
                    
                    <p style="font-size: 14px; color: var(--text-secondary); margin-top: 12px;">
                        🔔 Sons et vibrations activés • Validation automatique
                    </p>
                </div>
            `;
        }

        // Fonction pour configurer la durée du timer
        function setupTimerDuration(newDuration) {
            const duration = parseInt(newDuration) || 30;
            const timerDisplay = document.getElementById('exercise-timer-display');
            
            if (timerDisplay && !exerciseTimer.isRunning) {
                exerciseTimer.setup(
                    duration,
                    updateTimerDisplay,
                    completeTimedExercise
                );
                timerDisplay.textContent = exerciseTimer.formatTime(duration);
                updateTimerProgress(duration, duration);
            }
        }

        // Fonction pour mettre à jour l'affichage du timer
        function updateTimerDisplay(timeLeft, totalDuration) {
            const timerDisplay = document.getElementById('exercise-timer-display');
            
            if (timerDisplay) {
                timerDisplay.textContent = exerciseTimer.formatTime(timeLeft);
                
                // Changer la couleur selon le temps restant
                if (timeLeft <= 5) {
                    timerDisplay.style.color = 'var(--danger)';
                } else if (timeLeft <= 10) {
                    timerDisplay.style.color = 'var(--warning)';
                } else {
                    timerDisplay.style.color = 'var(--primary)';
                }
            }
            
            // Mettre à jour la barre de progression
            updateTimerProgress(timeLeft, totalDuration);
        }

        // Fonction pour mettre à jour la barre de progression
        function updateTimerProgress(timeLeft, totalDuration) {
            const progressBar = document.getElementById('timer-progress');
            if (progressBar) {
                const percentage = (timeLeft / totalDuration) * 100;
                progressBar.style.width = percentage + '%';
                
                // Changer la couleur de la barre selon le temps restant
                if (timeLeft <= 5) {
                    progressBar.style.background = 'var(--danger)';
                } else if (timeLeft <= 10) {
                    progressBar.style.background = 'var(--warning)';
                } else {
                    progressBar.style.background = 'var(--primary)';
                }
            }
        }

        // Fonction appelée quand le timer se termine
        function completeTimedExercise() {
            // Validation automatique de la série
            setTimeout(() => {
                if (confirm('⏰ Temps écoulé ! Valider cette série automatiquement ?')) {
                    // Remplir automatiquement la durée
                    const durationInput = document.getElementById('duration');
                    if (durationInput) {
                        durationInput.value = exerciseTimer.duration;
                    }
                    
                    // Valider la série
                    actions.validateSet();
                }
            }, 500); // Petit délai pour que l'utilisateur entende le son
        }

        // === FONCTIONS UTILITAIRES ÉLASTIQUES ===

        // Fonction pour toggle le mode d'exercice dans le formulaire
        function toggleExerciseMode() {
            const mode = document.getElementById('exercise-mode').value;
            const durationGroup = document.getElementById('duration-group');
            
            if (mode === 'time' || mode === 'both') {
                durationGroup.style.display = 'block';
            } else {
                durationGroup.style.display = 'none';
            }
        }

        // Fonction pour toggle entre temps et répétitions dans les séances
        function togglePerformanceMode(prefix = '') {
            const mode = document.getElementById(`${prefix}execution-mode`).value;
            const repsInputs = document.querySelectorAll(`[id*="${prefix}reps-inputs"]`);
            const timerContainer = document.getElementById(`${prefix}timer-container`);
            
            // Arrêter le timer si il était en cours
            if (exerciseTimer.isRunning) {
                exerciseTimer.stop();
            }
            
            if (mode === 'time') {
                // Masquer les inputs de répétitions
                repsInputs.forEach(input => {
                    if (input) input.style.display = 'none';
                });
                
                // Afficher le timer
                if (timerContainer) {
                    timerContainer.style.display = 'block';
                    
                    // Configurer le timer après un court délai
                    setTimeout(() => {
                        const defaultDuration = 30; // Valeur par défaut
                        exerciseTimer.setup(
                            defaultDuration,
                            updateTimerDisplay,
                            completeTimedExercise
                        );
                        
                        // Mettre à jour l'affichage initial
                        const timerDisplay = document.getElementById('exercise-timer-display');
                        if (timerDisplay) {
                            timerDisplay.textContent = exerciseTimer.formatTime(defaultDuration);
                        }
                        updateTimerButtons();
                    }, 100);
                }
            } else {
                // Afficher les inputs de répétitions
                repsInputs.forEach(input => {
                    if (input) input.style.display = 'block';
                });
                
                // Masquer le timer
                if (timerContainer) {
                    timerContainer.style.display = 'none';
                }
            }
        }

        // Fonction pour créer un item d'exercice avec réorganisation
        function createExerciseItem(exerciseData, sectionIndex, section) {
            const { exercise, planned_sets, originalIndex } = exerciseData;
            
            const div = document.createElement('div');
            div.className = 'exercise-item';
            
            // Indicateur du mode d'exercice
            const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' : 
                            exercise.exercise_mode === 'both' ? '🔄' : '🔢';
            
            // Informations sur l'exercice
            const restTime = exerciseData.rest_time || exercise.default_rest_time;
            let exerciseInfo = `${exercise.is_unilateral ? 'Unilatéral' : 'Bilatéral'} • ${restTime}s repos`;
            if (exercise.exercise_mode === 'time') {
                exerciseInfo += ` • ${exercise.default_duration || 30}s par défaut`;
            }
            
            // Calculer si on peut monter/descendre
            const isFirst = sectionIndex === 0;
            const totalInSection = section === 'warmup' ? 
                appState.currentSession.exercises.filter(ex => {
                    const e = appState.exercises.find(e => e.id === ex.exercise_id);
                    return e && (e.muscle_group === 'echauffement' || e.category === 'warmup');
                }).length :
                appState.currentSession.exercises.filter(ex => {
                    const e = appState.exercises.find(e => e.id === ex.exercise_id);
                    return e && e.muscle_group !== 'echauffement' && e.category !== 'warmup';
                }).length;
            const isLast = sectionIndex === totalInSection - 1;
            
            div.innerHTML = `
                <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span class="exercise-number">${sectionIndex + 1}</span>
                        <strong>${modeIcon} ${exercise.name}</strong>
                    </div>
                    <div style="font-size: 14px; color: var(--text-secondary); margin-left: 32px;">
                        ${exerciseInfo}
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="number" value="${planned_sets}" min="1" max="20"
                        style="width: 60px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px;"
                        onchange="actions.updatePlannedSets(${exercise.id}, this.value)">
                    <span style="font-size: 14px;">séries</span>
                    
                    <input type="number" value="${restTime}" min="30" max="600"
                        style="width: 60px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px;"
                        onchange="actions.updateExerciseRestTime(${exercise.id}, this.value)"
                        title="Temps de repos en secondes">
                    <span style="font-size: 14px;">s repos</span>
                    ${(exercise.exercise_mode === 'time' || exercise.exercise_mode === 'both') ? `
                        <input type="number" value="${exerciseData.duration || exercise.default_duration || 30}" min="10" max="300"
                            style="width: 60px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 6px; margin-left: 8px;"
                            onchange="actions.updateExerciseDuration(${exercise.id}, this.value)"
                            title="Durée de l'exercice en secondes">
                        <span style="font-size: 14px;">s durée</span>
                    ` : ''}
                    
                    <div class="reorder-buttons">
                        <button class="btn btn-small btn-secondary" onclick="actions.moveExerciseUp(${originalIndex}, 'session')"
                            ${isFirst ? 'disabled' : ''}>↑</button>
                        <button class="btn btn-small btn-secondary" onclick="actions.moveExerciseDown(${originalIndex}, 'session')"
                            ${isLast ? 'disabled' : ''}>↓</button>
                    </div>
                    <button class="btn btn-small btn-danger" onclick="actions.removeExerciseFromSession(${exercise.id})">✕</button>
                </div>
            `;
            
            return div;
        }

        // Fonction pour calculer la résistance totale
        function calculateTotalResistance(selectedElastics) {
            let total = 0;
            Object.keys(selectedElastics).forEach(color => {
                const count = selectedElastics[color] || 0;
                if (ELASTICS_DB[color] && count > 0) {
                    total += ELASTICS_DB[color].resistance * count;
                }
            });
            return total;
        }

        // Fonction pour générer le sélecteur d'élastiques
        function generateElasticSelector(prefix = '', isUnilateral = false) {
            if (isUnilateral) {
                // Pour les exercices unilatéraux, deux sélecteurs séparés
                let html = '<div class="elastics-selector" style="margin: 16px 0;">';
                html += '<h4>Combinaison d\'élastiques par côté</h4>';
                
                // Côté gauche
                html += '<div style="margin-bottom: 16px;">';
                html += '<h5 style="color: var(--primary); margin-bottom: 8px;">🫱 Côté gauche</h5>';
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
                Object.keys(ELASTICS_DB).forEach(color => {
                    const elastic = ELASTICS_DB[color];
                    html += `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="width: 20px; height: 20px; background: ${elastic.color}; border-radius: 50%; border: 1px solid #ccc;"></div>
                        <div style="flex: 1; font-size: 14px;">${elastic.name} (${elastic.resistance}kg)</div>
                        <select id="${prefix}elastic-left-${color}" class="select" style="width: 60px; padding: 4px;" onchange="updateResistanceDisplay('${prefix}', true)">
                        `;
                    for (let i = 0; i <= elastic.quantity; i++) {
                        html += `<option value="${i}">${i}</option>`;
                    }
                    html += '</select></div>';
                });
                html += '</div>';
                html += `<div style="margin-top: 8px; padding: 8px; background: var(--primary); color: white; border-radius: 8px; text-align: center; font-weight: bold;">Résistance gauche: <span id="${prefix}total-resistance-left">0</span> kg
                </div>`;
                html += '</div>';
                
                // Côté droit
                html += '<div>';
                html += '<h5 style="color: var(--primary); margin-bottom: 8px;">🫲 Côté droit</h5>';
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
                Object.keys(ELASTICS_DB).forEach(color => {
                    const elastic = ELASTICS_DB[color];
                    html += `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="width: 20px; height: 20px; background: ${elastic.color}; border-radius: 50%; border: 1px solid #ccc;"></div>
                        <div style="flex: 1; font-size: 14px;">${elastic.name} (${elastic.resistance}kg)</div>
                        <select id="${prefix}elastic-right-${color}" class="select" style="width: 60px; padding: 4px;" onchange="updateResistanceDisplay('${prefix}', true)">
                        `;
                    for (let i = 0; i <= elastic.quantity; i++) {
                        html += `<option value="${i}">${i}</option>`;
                    }
                    html += '</select></div>';
                });
                html += '</div>';
                html += `<div style="margin-top: 8px; padding: 8px; background: var(--primary); color: white; border-radius: 8px; text-align: center; font-weight: bold;">Résistance droite: <span id="${prefix}total-resistance-right">0</span> kg
                </div>`;
                html += '</div>';
                
                html += '</div>';
                return html;
            } else {
                // Code existant pour les exercices bilatéraux
                let html = '<div class="elastics-selector" style="margin: 16px 0;">';
                html += '<h4>Combinaison d\'élastiques</h4>';
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">';
                Object.keys(ELASTICS_DB).forEach(color => {
                    const elastic = ELASTICS_DB[color];
                    html += `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="width: 20px; height: 20px; background: ${elastic.color}; border-radius: 50%; border: 1px solid #ccc;"></div>
                        <div style="flex: 1; font-size: 14px;">${elastic.name} (${elastic.resistance}kg)</div>
                        <select id="${prefix}elastic-${color}" class="select" style="width: 60px; padding: 4px;" onchange="updateResistanceDisplay('${prefix}', false)">
                        `;
                    for (let i = 0; i <= elastic.quantity; i++) {
                        html += `<option value="${i}">${i}</option>`;
                    }
                    html += '</select></div>';
                });
                html += '</div>';
                html += `<div style="margin-top: 12px; padding: 8px; background: var(--primary); color: white; border-radius: 8px; text-align: center; font-weight: bold;">Résistance totale: <span id="${prefix}total-resistance">0</span> kg
                </div>`;
                html += '</div>';
                return html;
            }
        }

        // Fonction pour mettre à jour l'affichage de la résistance
        function updateResistanceDisplay(prefix = '', isUnilateral = false) {
            if (isUnilateral) {
                // Pour les exercices unilatéraux
                const selectedElasticsLeft = {};
                const selectedElasticsRight = {};
                
                Object.keys(ELASTICS_DB).forEach(color => {
                    const selectElementLeft = document.getElementById(`${prefix}elastic-left-${color}`);
                    const selectElementRight = document.getElementById(`${prefix}elastic-right-${color}`);
                    
                    if (selectElementLeft) {
                        selectedElasticsLeft[color] = parseInt(selectElementLeft.value) || 0;
                    }
                    if (selectElementRight) {
                        selectedElasticsRight[color] = parseInt(selectElementRight.value) || 0;
                    }
                });
                
                const totalLeft = calculateTotalResistance(selectedElasticsLeft);
                const totalRight = calculateTotalResistance(selectedElasticsRight);
                
                const totalElementLeft = document.getElementById(`${prefix}total-resistance-left`);
                const totalElementRight = document.getElementById(`${prefix}total-resistance-right`);
                
                if (totalElementLeft) {
                    totalElementLeft.textContent = totalLeft;
                }
                if (totalElementRight) {
                    totalElementRight.textContent = totalRight;
                }
                
                return { 
                    selectedElastics: { left: selectedElasticsLeft, right: selectedElasticsRight }, 
                    total: { left: totalLeft, right: totalRight } 
                };
            } else {
                // Code existant pour les exercices bilatéraux
                const selectedElastics = {};
                Object.keys(ELASTICS_DB).forEach(color => {
                    const selectElement = document.getElementById(`${prefix}elastic-${color}`);
                    if (selectElement) {
                        selectedElastics[color] = parseInt(selectElement.value) || 0;
                    }
                });
                
                const total = calculateTotalResistance(selectedElastics);
                const totalElement = document.getElementById(`${prefix}total-resistance`);
                if (totalElement) {
                    totalElement.textContent = total;
                }
                
                return { selectedElastics, total };
            }
        }

        // Fonction pour charger les exercices pré-définis
        function loadPredefinedExercises() {
            const exercisesToAdd = [];
            
            Object.keys(PREDEFINED_EXERCISES).forEach(category => {
                PREDEFINED_EXERCISES[category].forEach(ex => {
                    exercisesToAdd.push({
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        name: ex.name,
                        is_unilateral: ex.unilateral,
                        default_rest_time: 90,
                        exercise_type: 'elastics',
                        anchor_point: ex.anchor,
                        muscle_group: category
                    });
                });
            });
            
            return exercisesToAdd;
        }

        // Fonction pour générer les conseils de résistance
        function generateResistanceRecommendations(exerciseName) {
            const recommendations = RESISTANCE_RECOMMENDATIONS[exerciseName];
            if (!recommendations) {
                return '<p style="font-size: 14px; color: var(--text-secondary);">Pas de recommandations disponibles pour cet exercice.</p>';
            }
            
            let html = '<div style="background: var(--background); padding: 16px; border-radius: 8px; margin: 12px 0;">';
            html += '<h5 style="color: var(--primary); margin-bottom: 12px;">💡 Conseils de résistance (première fois)</h5>';
            
            // Débutant
            html += `
                <div style="margin-bottom: 12px; padding: 12px; background: var(--surface); border-radius: 8px; border-left: 4px solid #34C759;">
                    <div style="font-weight: 600; color: #34C759; margin-bottom: 4px;">🟢 Débutant</div>
                    <div style="font-size: 14px;">
                        <strong>${recommendations.beginner.min}-${recommendations.beginner.max}kg</strong> • 
                        Élastiques : ${recommendations.beginner.elastics.join(' + ')}
                    </div>
                </div>
            `;
            
            // Intermédiaire
            html += `
                <div style="margin-bottom: 12px; padding: 12px; background: var(--surface); border-radius: 8px; border-left: 4px solid #FF9500;">
                    <div style="font-weight: 600; color: #FF9500; margin-bottom: 4px;">🟡 Intermédiaire</div>
                    <div style="font-size: 14px;">
                        <strong>${recommendations.intermediate.min}-${recommendations.intermediate.max}kg</strong> • 
                        Élastiques : ${recommendations.intermediate.elastics.join(' + ')}
                    </div>
                </div>
            `;
            
            // Confirmé
            html += `
                <div style="padding: 12px; background: var(--surface); border-radius: 8px; border-left: 4px solid #FF3B30;">
                    <div style="font-weight: 600; color: #FF3B30; margin-bottom: 4px;">🔴 Confirmé</div>
                    <div style="font-size: 14px;">
                        <strong>${recommendations.advanced.min}-${recommendations.advanced.max}kg</strong> • 
                        Élastiques : ${recommendations.advanced.elastics.join(' + ')}
                    </div>
                </div>
            `;
            
            html += '<p style="font-size: 12px; color: var(--text-secondary); margin-top: 12px; font-style: italic;">Commencez léger et ajustez selon vos sensations !</p>';
            html += '</div>';
            
            return html;
        }

        // Fonction pour afficher les exemples d'exercices
        function showExerciseExamples(anchorType) {
            const examplesContainer = document.getElementById('exercise-examples');
            const examplesList = document.getElementById('examples-list');
            
            if (anchorType && examplesList) {
                const examples = {
                    'none': ['Biceps curls', 'Élévations latérales', 'Squats', 'Overhead press'],
                    'door-middle': ['Face Pull', 'Développé debout', 'Rowing horizontal'],
                    'door-high': ['Tirage vertical', 'Extension triceps', 'Développé incliné'],
                    'door-low': ['Tirage poulie basse', 'Curl biceps', 'Développé décliné'],
                    'floor': ['Soulevé de terre', 'Rowing buste penché', 'Front squat'],
                    'body': ['Hip thrust', 'Abduction hanches', 'Donkey kick'],
                    'external': ['Exercices extérieurs', 'Sprints résistance']
                };
                
                if (examples[anchorType]) {
                    examplesList.innerHTML = examples[anchorType].join(', ');
                    examplesContainer.style.display = 'block';
                } else {
                    examplesContainer.style.display = 'none';
                }
            }
        }

        // === ARCHITECTURE RÉACTIVE: ÉTAT CENTRAL ===
        let appState = {
            currentScreen: 'dashboard',
            currentSession: null,
            liveSession: null,
            editingExercise: null,
            exercises: [],
            sessions: [],
            templates: [],
            measurements: [],
            records: {},
            settings: {
                theme: 'light'
            }
        };

        // === GESTION DE L'HISTORIQUE DE NAVIGATION ===
        let navigationHistory = ['dashboard'];
        let isNavigatingBack = false;

        // Fonction pour ajouter un écran à l'historique
        function addToNavigationHistory(screenName) {
            if (!isNavigatingBack && screenName !== navigationHistory[navigationHistory.length - 1]) {
                navigationHistory.push(screenName);
                // Limiter l'historique à 10 écrans pour éviter les fuites mémoire
                if (navigationHistory.length > 10) {
                    navigationHistory = navigationHistory.slice(-10);
                }
            }
            isNavigatingBack = false;
        }

        // Fonction pour naviguer vers l'écran précédent
        function navigateBack() {
            if (navigationHistory.length > 1) {
                navigationHistory.pop(); // Enlever l'écran actuel
                const previousScreen = navigationHistory[navigationHistory.length - 1];
                isNavigatingBack = true;
                actions.showScreen(previousScreen);
                return true; // Navigation interne effectuée
            }
            return false; // Pas d'écran précédent, laisser le comportement par défaut
        }

        // === STOCKAGE LOCAL AVEC VERSIONING ===
        const STORAGE_VERSION = 'v1';
        const STORAGE_PREFIX = `smarttrack_${STORAGE_VERSION}_`;

        const storage = {
            isAvailable() {
                try {
                const test = '__storage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
                } catch (e) {
                return false;
                }
            },
            
            save(key, data) {
                if (!this.isAvailable()) {
                console.warn('localStorage non disponible');
                return false;
                }
                try {
                localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(data));
                return true;
                } catch (e) {
                console.error('Erreur de sauvegarde:', e);
                return false;
                }
            },
            
            load(key, defaultValue = null) {
                if (!this.isAvailable()) {
                return defaultValue;
                }
                try {
                const item = localStorage.getItem(STORAGE_PREFIX + key);
                return item ? JSON.parse(item) : defaultValue;
                } catch (e) {
                console.error('Erreur de chargement:', e);
                return defaultValue;
                }
            },
            
            remove(key) {
                if (!this.isAvailable()) {
                return false;
                }
                try {
                localStorage.removeItem(STORAGE_PREFIX + key);
                return true;
                } catch (e) {
                console.error('Erreur de suppression:', e);
                return false;
                }
            },
            
            clear() {
                if (!this.isAvailable()) {
                return false;
                }
                try {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(STORAGE_PREFIX)) {
                    localStorage.removeItem(key);
                    }
                });
                return true;
                } catch (e) {
                console.error('Erreur de nettoyage:', e);
                return false;
                }
            }
        };

        // === CACHE INTELLIGENT ===
        const smartCache = {
            // Cache pour les calculs coûteux
            cache: new Map(),
            
            // Générer une clé de cache
            generateKey(type, params) {
                return `${type}_${JSON.stringify(params)}`;
            },
        
            // Récupérer du cache
            get(type, params) {
                const key = this.generateKey(type, params);
                return this.cache.get(key);
            },
        
            // Stocker en cache
            set(type, params, value) {
                const key = this.generateKey(type, params);
                this.cache.set(key, value);
                
                // Limiter la taille du cache (garder les 100 entrées les plus récentes)
                if (this.cache.size > 100) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                
                return value;
            },
        
            // Invalider le cache pour un type donné
            invalidate(type) {
                const keysToDelete = [];
                for (let key of this.cache.keys()) {
                    if (key.startsWith(type + '_')) {
                        keysToDelete.push(key);
                    }
                }
                keysToDelete.forEach(key => this.cache.delete(key));
            },
        
            // Nettoyer tout le cache
            clear() {
                this.cache.clear();
            }
        };

        // === DEBOUNCING POUR OPTIMISER LES APPELS FRÉQUENTS ===
        const debounceManager = {
            timers: new Map(),
        
            debounce(func, delay = 300, key = 'default') {
                if (this.timers.has(key)) {
                    clearTimeout(this.timers.get(key));
                }
            
                const timer = setTimeout(() => {
                    func();
                    this.timers.delete(key);
                }, delay);
            
                this.timers.set(key, timer);
            }
        };

        // === FONCTIONS UTILITAIRES DE VALIDATION ===
        const utils = {
            validateNumber(value, min = 0, max = 999) {
                const num = parseFloat(value);
                return !isNaN(num) && num >= min && num <= max ? num : 0;
            },
            
            validateString(value, minLength = 1, maxLength = 100) {
                if (typeof value !== 'string') return '';
                return value.trim().length >= minLength && value.trim().length <= maxLength ? value.trim() : '';
            },
            
            validateEmail(email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            },
            
            validateDate(dateString) {
                const date = new Date(dateString);
                return !isNaN(date.getTime()) && dateString.match(/^\d{4}-\d{2}-\d{2}$/);
            }
        };

        // === ACTIONS (MODIFICATION DE L'ÉTAT) ===
        const actions = {
            // Initialisation
            init() {
                this.loadData();
                this.applyTheme();
                this.setCurrentDate();
                // Restaurer l'écran sauvegardé ou dashboard par défaut
                const savedScreen = storage.load('currentScreen', 'dashboard');
                appState.currentScreen = savedScreen;
                render();
            },
            
            loadData() {
                appState.exercises = storage.load('exercises', []);
                appState.sessions = storage.load('sessions', []);
                appState.templates = storage.load('templates', []);
                appState.measurements = storage.load('measurements', []);
                appState.records = storage.load('records', {});
                appState.settings = storage.load('settings', { theme: 'light' });
                appState.currentScreen = storage.load('currentScreen', 'dashboard');
            },
            
            saveData() {
                // Invalider les caches liés aux données modifiées
                smartCache.invalidate('generalStats');
                smartCache.invalidate('calendar');
                smartCache.invalidate('exerciseSearch');
                storage.save('exercises', appState.exercises);
                storage.save('sessions', appState.sessions);
                storage.save('templates', appState.templates);
                storage.save('measurements', appState.measurements);
                storage.save('records', appState.records);
                storage.save('settings', appState.settings);
            },
            
            // Navigation
            showScreen(screenName) {
                // Ajouter à l'historique de navigation
                addToNavigationHistory(screenName);
            
                appState.currentScreen = screenName;
                // Sauvegarder l'écran actuel
                storage.save('currentScreen', screenName);
                render();
            },
            
            // Fonction pour naviguer intelligemment vers la séance
            goToSession() {
                if (appState.liveSession) {
                    // Si une séance live est en cours, aller directement à l'écran live
                    this.showScreen('live');
                } else {
                    // Sinon, aller à l'écran de préparation
                    this.showScreen('preparation');
                }
            },

            showSettings() {
                appState.currentScreen = 'settings';
                render();
            },
            
            // Gestion des exercices
            saveExercise() {
                const name = utils.validateString(document.getElementById('exercise-name').value, 1, 50);
                const isUnilateral = document.getElementById('exercise-unilateral').checked;
                const restTime = utils.validateNumber(document.getElementById('exercise-rest').value, 30, 600);
                const category = document.getElementById('exercise-category')?.value || 'strength';
                const mode = document.getElementById('exercise-mode')?.value || 'reps';
                const duration = utils.validateNumber(document.getElementById('exercise-duration').value, 10, 300);
                
                if (!name) {
                    this.showNotification('Le nom de l\'exercice est requis (1-50 caractères)');
                    return;
                }
                
                if (appState.editingExercise) {
                    // Modification
                    const exercise = appState.exercises.find(e => e.id === appState.editingExercise);
                    exercise.name = name;
                    exercise.is_unilateral = isUnilateral;
                    exercise.default_rest_time = restTime;
                    exercise.category = category;
                    exercise.exercise_mode = mode;
                    exercise.default_duration = duration;
                    exercise.exercise_type = category === 'warmup' ? 'bodyweight' : 'elastics';
                    exercise.anchor_point = document.getElementById('exercise-anchor')?.value || 'none';
                    exercise.muscle_group = document.getElementById('exercise-muscle-group')?.value || 'autres';
                    appState.editingExercise = null;
                } else {
                    // Création
                    const newExercise = {
                        id: Date.now(),
                        name,
                        is_unilateral: isUnilateral,
                        default_rest_time: restTime,
                        category: category,
                        exercise_mode: mode,
                        default_duration: duration,
                        exercise_type: category === 'warmup' ? 'bodyweight' : 'elastics',
                        anchor_point: document.getElementById('exercise-anchor')?.value || 'none',
                        muscle_group: document.getElementById('exercise-muscle-group')?.value || 'autres'
                    };
                    appState.exercises.push(newExercise);
                }
                
                this.clearExerciseForm();
                this.saveData();
                render();
                this.showNotification('Exercice sauvegardé !');
            },
            
            // Fonction pour déplacer un exercice vers le haut
            moveExerciseUp(index, context = 'session') {
                if (index === 0) return;
                
                let exercises;
                if (context === 'session' && appState.currentSession) {
                    exercises = appState.currentSession.exercises;
                } else if (context === 'template' && appState.editingTemplate) {
                    exercises = appState.editingTemplate.exerciseIds;
                } else {
                    return;
                }
                
                // Échanger les éléments
                [exercises[index], exercises[index - 1]] = [exercises[index - 1], exercises[index]];
                render();
            },

            // Fonction pour déplacer un exercice vers le bas
            moveExerciseDown(index, context = 'session') {
                let exercises;
                if (context === 'session' && appState.currentSession) {
                    exercises = appState.currentSession.exercises;
                    if (index >= exercises.length - 1) return;
                } else if (context === 'template' && appState.editingTemplate) {
                    exercises = appState.editingTemplate.exerciseIds;
                    if (index >= exercises.length - 1) return;
                } else {
                    return;
                }
                
                // Échanger les éléments
                [exercises[index], exercises[index + 1]] = [exercises[index + 1], exercises[index]];
                render();
            },

            editExercise(id) {
                const exercise = appState.exercises.find(e => e.id === id);
                if (exercise) {
                    appState.editingExercise = id;
                    document.getElementById('exercise-name').value = exercise.name;
                    document.getElementById('exercise-unilateral').checked = exercise.is_unilateral;
                    document.getElementById('exercise-rest').value = exercise.default_rest_time;
                    document.getElementById('exercise-category').value = exercise.category || 'strength';
                    document.getElementById('exercise-mode').value = exercise.exercise_mode || 'reps';
                    document.getElementById('exercise-duration').value = exercise.default_duration || 30;
                    document.getElementById('exercise-anchor').value = exercise.anchor_point || 'none';
                    document.getElementById('exercise-muscle-group').value = exercise.muscle_group || 'autres';
                    
                    // Afficher/masquer le champ durée selon le mode
                    toggleExerciseMode();
                    
                    // Afficher les exemples d'exercices
                    showExerciseExamples(exercise.anchor_point || 'none');
                    
                    render();
                }
            },
            
            // Fonction pour générer les inputs de performance selon le mode de l'exercice
            generatePerformanceInputs(exercise, prefix = '') {
                let html = '';
                
                if (exercise.exercise_mode === 'time') {
                    // Mode temps avec TIMER INTÉGRÉ
                    html = `
                        ${generateTimerInterface(exercise, prefix)}
                        ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix, exercise.is_unilateral) : ''}
                    `;
                    
                    // Configurer le timer après le rendu
                    setTimeout(() => {
                        const defaultDuration = exercise.default_duration || 30;
                        exerciseTimer.setup(
                            defaultDuration,
                            updateTimerDisplay,
                            completeTimedExercise
                        );
                    }, 100);
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - choix entre temps et répétitions
                    const modeInputs = exercise.is_unilateral ? `
                        <div class="input-group" id="${prefix}reps-inputs" style="display: none;">
                            <label>Reps Gauche</label>
                            <input type="number" id="${prefix}left-reps" class="input" min="0">
                        </div>
                        <div class="input-group" id="${prefix}reps-inputs-2" style="display: none;">
                            <label>Reps Droite</label>
                            <input type="number" id="${prefix}right-reps" class="input" min="0">
                        </div>
                        <div id="${prefix}timer-container" style="display: none;">
                            ${generateTimerInterface(exercise, prefix)}
                        </div>
                    ` : `
                        <div class="input-group" id="${prefix}reps-inputs" style="display: none;">
                            <label>Répétitions</label>
                            <input type="number" id="${prefix}reps" class="input" min="0">
                        </div>
                        <div id="${prefix}timer-container" style="display: none;">
                            ${generateTimerInterface(exercise, prefix)}
                        </div>
                    `;
                    
                    html = `
                        <div class="input-group">
                            <label>Mode d'exécution</label>
                            <select id="${prefix}execution-mode" class="select" onchange="togglePerformanceMode('${prefix}')">
                                <option value="reps">Répétitions</option>
                                <option value="time">Temps avec Timer</option>
                            </select>
                        </div>
                        <div class="performance-inputs">
                            ${modeInputs}
                        </div>
                        ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix, exercise.is_unilateral) : ''}
                    `;
                } else {
                    // Mode répétitions classique
                    if (exercise.is_unilateral) {
                        html = `
                            <div class="performance-inputs">
                                <div class="input-group">
                                    <label>Reps Gauche</label>
                                    <input type="number" id="${prefix}left-reps" class="input" min="0">
                                </div>
                                <div class="input-group">
                                    <label>Reps Droite</label>
                                    <input type="number" id="${prefix}right-reps" class="input" min="0">
                                </div>
                            </div>
                            ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix, exercise.is_unilateral) : ''}
                        `;
                    } else {
                        html = `
                            <div class="performance-inputs">
                                <div class="input-group">
                                    <label>Répétitions</label>
                                    <input type="number" id="${prefix}reps" class="input" min="0">
                                </div>
                            </div>
                            ${exercise.exercise_type === 'elastics' ? generateElasticSelector(prefix, exercise.is_unilateral) : ''}
                        `;
                    }
                }
                
                return html;
            },

            deleteExercise(id) {
                if (confirm('Supprimer cet exercice ? Cette action est irréversible.')) {
                    appState.exercises = appState.exercises.filter(e => e.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Exercice supprimé');
                }
            },
            
            cancelExerciseEdit() {
                appState.editingExercise = null;
                this.clearExerciseForm();
                render();
            },
            
            clearExerciseForm() {
                document.getElementById('exercise-name').value = '';
                document.getElementById('exercise-unilateral').checked = false;
                document.getElementById('exercise-rest').value = '90';
                document.getElementById('exercise-category').value = 'strength';
                document.getElementById('exercise-mode').value = 'reps';
                document.getElementById('exercise-duration').value = '30';
                document.getElementById('exercise-anchor').value = 'none';
                document.getElementById('exercise-muscle-group').value = 'biceps';
                document.getElementById('exercise-examples').style.display = 'none';
                document.getElementById('duration-group').style.display = 'none';
            },
            
            // Gestion des modèles
            saveTemplate() {
                const name = document.getElementById('template-name').value.trim();
            
                if (!name) {
                    this.showNotification('Le nom du modèle est requis');
                    return;
                }

                if (!appState.templateInCreation || appState.templateInCreation.exercises.length === 0) {
                    this.showNotification('Sélectionnez au moins un exercice');
                    return;
                }

                // Récupérer les paramètres globaux
                const restBetweenExercises = parseInt(document.getElementById('template-rest-between-exercises')?.value) || 120;
                const restBetweenSets = parseInt(document.getElementById('template-rest-between-sets')?.value) || 90;

                const newTemplate = {
                    id: Date.now(),
                    name,
                    exercises: appState.templateInCreation.exercises.map(ex => ({
                        exerciseId: ex.exerciseId,
                        plannedSets: ex.plannedSets,
                        restTime: ex.restTime,
                        duration: ex.duration // Ajouter la durée
                    })),
                    globalSettings: {
                        restBetweenExercises,
                        restBetweenSets
                    }
                };

                appState.templates.push(newTemplate);
                this.clearTemplateForm();
                this.saveData();
                render();
                this.showNotification('Modèle créé !');
            },
            
            deleteTemplate(id) {
                if (confirm('Supprimer ce modèle ?')) {
                    appState.templates = appState.templates.filter(t => t.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Modèle supprimé');
                }
            },
            
            clearTemplateForm() {
                document.getElementById('template-name').value = '';
                
                // Nettoyer le modèle en création
                appState.templateInCreation = null;
                
                // Réafficher l'interface vide
                const selectedExercisesContainer = document.getElementById('template-selected-exercises');
                if (selectedExercisesContainer) {
                    selectedExercisesContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Aucun exercice sélectionné</p>';
                }
                
                const globalSettings = document.getElementById('template-global-settings');
                if (globalSettings) {
                    globalSettings.style.display = 'none';
                }
            },
            
            // Afficher le sélecteur d'exercices
            showExerciseSelector() {
                // Fermer le modal existant s'il y en a un
                const existingModal = document.getElementById('exercise-selector-modal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                if (!appState.templateInCreation) {
                    appState.templateInCreation = {
                        exercises: [],
                        globalSettings: {
                            restBetweenExercises: 120,
                            restBetweenSets: 90
                        }
                    };
                }

                // Créer le modal de sélection d'exercices
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.id = 'exercise-selector-modal';
                
                let exercisesList = '';
                const groupedExercises = {};
                appState.exercises.forEach(exercise => {
                    const group = exercise.muscle_group || 'autres';
                    if (!groupedExercises[group]) {
                        groupedExercises[group] = [];
                    }
                    groupedExercises[group].push(exercise);
                });

                const groupOrder = ['echauffement', 'biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
                groupOrder.forEach(group => {
                    if (groupedExercises[group] && groupedExercises[group].length > 0) {
                        exercisesList += `<h4 class="exercise-group-title">${group.charAt(0).toUpperCase() + group.slice(1)}</h4>`;
                        groupedExercises[group].forEach(exercise => {
                            const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' : 
                                             exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                            const isSelected = appState.templateInCreation.exercises.some(ex => ex.exerciseId === exercise.id);
                            exercisesList += `
                                <div class="exercise-item" style="opacity: ${isSelected ? '0.5' : '1'};">
                                    <div>
                                        <strong>${modeIcon} ${exercise.name}</strong>
                                        <div style="font-size: 14px; color: var(--text-secondary);">
                                            ${exercise.is_unilateral ? 'Unilatéral' : 'Bilatéral'} • ${exercise.default_rest_time}s repos
                                        </div>
                                    </div>
                                    <button class="btn btn-small ${isSelected ? 'btn-secondary' : 'btn-primary'}" 
                                        onclick="actions.${isSelected ? 'removeFromTemplate' : 'addToTemplate'}(${exercise.id})"
                                        ${isSelected ? 'disabled' : ''}>
                                        ${isSelected ? '✓ Ajouté' : '➕ Ajouter'}
                                    </button>
                                </div>
                            `;
                        });
                    }
                });

                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h3>Sélectionner des exercices</h3>
                            <button class="close-btn" onclick="actions.closeExerciseSelector()" style="font-size: 24px; padding: 8px; background: none; border: none; cursor: pointer;">×</button>
                        </div>
                        <div style="margin: 16px 0;">
                            ${exercisesList}
                        </div>
                        <button class="btn btn-success btn-full" onclick="actions.closeExerciseSelector()">
                            ✅ Terminer la sélection
                        </button>
                    </div>
                `;
                    
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        actions.closeExerciseSelector();
                    }
                });

                document.body.appendChild(modal);
            },

            // Ajouter un exercice au modèle en création
            addToTemplate(exerciseId) {
                if (!appState.templateInCreation) {
                    appState.templateInCreation = { exercises: [], globalSettings: { restBetweenExercises: 120, restBetweenSets: 90 } };
                }

                const exercise = appState.exercises.find(e => e.id === exerciseId);
                if (exercise && !appState.templateInCreation.exercises.some(ex => ex.exerciseId === exerciseId)) {
                    appState.templateInCreation.exercises.push({
                        exerciseId: exerciseId,
                        plannedSets: 3,
                        restTime: exercise.default_rest_time
                    });
                
                    // Mettre à jour SEULEMENT le bouton de l'exercice ajouté (éviter la remontée)
                    const button = document.querySelector(`button[onclick*="addToTemplate(${exerciseId})"]`);
                    if (button) {
                        button.textContent = '✓ Ajouté';
                        button.className = 'btn btn-small btn-secondary';
                        button.disabled = true;
                        button.onclick = () => actions.removeFromTemplate(exerciseId);
                    }

                    // Rafraîchir l'affichage principal sans fermer le modal
                    this.renderSelectedExercises();
                }
            },

            // Retirer un exercice du modèle en création
            removeFromTemplate(exerciseId) {
                if (appState.templateInCreation) {
                    appState.templateInCreation.exercises = appState.templateInCreation.exercises.filter(
                        ex => ex.exerciseId !== exerciseId
                    );
                
                    // Rafraîchir le modal
                    this.showExerciseSelector();
                    // Rafraîchir l'affichage principal
                    this.renderSelectedExercises();
                }
            },

            // Fermer le sélecteur d'exercices
            closeExerciseSelector() {
                const modal = document.getElementById('exercise-selector-modal');
                if (modal) {
                    modal.remove();
                }
                this.renderSelectedExercises();
            },

            // Afficher les exercices sélectionnés
            renderSelectedExercises() {
                const container = document.getElementById('template-selected-exercises');
                const globalSettings = document.getElementById('template-global-settings');
            
                if (!appState.templateInCreation || appState.templateInCreation.exercises.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Aucun exercice sélectionné</p>';
                    globalSettings.style.display = 'none';
                    return;
                }

                globalSettings.style.display = 'block';
            
                let html = '';
                appState.templateInCreation.exercises.forEach((exData, index) => {
                    const exercise = appState.exercises.find(e => e.id === exData.exerciseId);
                    if (exercise) {
                        const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' : 
                                         exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                
                        html += `
                            <div class="exercise-item" style="margin-bottom: 8px;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                        <span class="exercise-number">${index + 1}</span>
                                        <strong>${modeIcon} ${exercise.name}</strong>
                                    </div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="display: flex; align-items: center; gap: 4px;">
                                        <input type="number" value="${exData.plannedSets}" min="1" max="20"
                                            style="width: 50px; padding: 4px; border: 1px solid var(--border); border-radius: 4px;"
                                            onchange="actions.updateTemplateExerciseSets(${index}, this.value)">
                                        <span style="font-size: 12px;">séries</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 4px;">
                                        <input type="number" value="${exData.restTime}" min="30" max="600"
                                            style="width: 60px; padding: 4px; border: 1px solid var(--border); border-radius: 4px;"
                                            onchange="actions.updateTemplateExerciseRest(${index}, this.value)">
                                        <span style="font-size: 12px;">s repos</span>
                                    </div>
                                    ${exercise.exercise_mode === 'time' || exercise.exercise_mode === 'both' ? `
                                        <div style="display: flex; align-items: center; gap: 4px;">
                                            <input type="number" value="${exData.duration || exercise.default_duration || 30}" min="10" max="300"
                                                style="width: 60px; padding: 4px; border: 1px solid var(--border); border-radius: 4px;"
                                                onchange="actions.updateTemplateExerciseDuration(${index}, this.value)">
                                            <span style="font-size: 12px;">s durée</span>
                                        </div>
                                    ` : ''}
                                    <div class="reorder-buttons">
                                        <button class="btn btn-small btn-secondary" onclick="actions.moveTemplateExerciseUp(${index})"
                                                ${index === 0 ? 'disabled' : ''}>↑</button>
                                        <button class="btn btn-small btn-secondary" onclick="actions.moveTemplateExerciseDown(${index})"
                                                ${index === appState.templateInCreation.exercises.length - 1 ? 'disabled' : ''}>↓</button>
                                    </div>
                                    <button class="btn btn-small btn-danger" onclick="actions.removeFromTemplateByIndex(${index})">✕</button>
                                </div>
                            </div>
                        `;
                    }
                });
            
                container.innerHTML = html;
            },

            // Mettre à jour le nombre de séries d'un exercice dans le modèle
            updateTemplateExerciseSets(index, sets) {
                const setsNumber = parseInt(sets);
                if (appState.templateInCreation && setsNumber >= 1 && setsNumber <= 20) {
                    appState.templateInCreation.exercises[index].plannedSets = setsNumber;
                }
            },

            // Mettre à jour le temps de repos d'un exercice dans le modèle
            updateTemplateExerciseRest(index, restTime) {
                const rest = parseInt(restTime);
                if (appState.templateInCreation && rest >= 30 && rest <= 600) {
                    appState.templateInCreation.exercises[index].restTime = rest;
                }
            },

            // Mettre à jour la durée d'un exercice dans le modèle
            updateTemplateExerciseDuration(index, duration) {
                const durationNumber = parseInt(duration);
                if (appState.templateInCreation && durationNumber >= 10 && durationNumber <= 300) {
                    appState.templateInCreation.exercises[index].duration = durationNumber;
                }
            },

            // Déplacer un exercice vers le haut dans le modèle
            moveTemplateExerciseUp(index) {
                if (appState.templateInCreation && index > 0) {
                    const exercises = appState.templateInCreation.exercises;
                    [exercises[index], exercises[index - 1]] = [exercises[index - 1], exercises[index]];
                    this.renderSelectedExercises();
                }
            },

            // Déplacer un exercice vers le bas dans le modèle
            moveTemplateExerciseDown(index) {
                if (appState.templateInCreation && index < appState.templateInCreation.exercises.length - 1) {
                    const exercises = appState.templateInCreation.exercises;
                    [exercises[index], exercises[index + 1]] = [exercises[index + 1], exercises[index]];
                    this.renderSelectedExercises();
                }
            },

            // Retirer un exercice du modèle par index
            removeFromTemplateByIndex(index) {
                if (appState.templateInCreation) {
                    appState.templateInCreation.exercises.splice(index, 1);
                    this.renderSelectedExercises();
                }
            },

            // Préparation de séance
            setCurrentDate() {
                const today = new Date().toISOString().split('T')[0];
                const dateInput = document.getElementById('session-date');
                if (dateInput) {
                    dateInput.value = today;
                    appState.currentSession = {
                        date: today,
                        notes: '',
                        exercises: [],
                        globalSettings: {
                            restBetweenExercises: 120,
                            restBetweenSets: 90
                        }
                    };
                }
            },
            
            updateSessionDate(date) {
                if (appState.currentSession) {
                    appState.currentSession.date = date;
                }
            },
            
            updateSessionNotes(notes) {
                if (appState.currentSession) {
                    appState.currentSession.notes = notes;
                }
            },
            
            addExerciseToSession() {
                // Cette fonction n'est plus utilisée avec le nouveau système de recherche
                // Elle est remplacée par selectExercise() dans le système de recherche
                this.showNotification('Utilisez la recherche ci-dessus pour ajouter un exercice');
            },
            
            removeExerciseFromSession(exerciseId) {
                if (appState.currentSession) {
                    appState.currentSession.exercises = appState.currentSession.exercises.filter(
                        e => e.exercise_id !== exerciseId
                    );
                    render();
                }
            },
            
            updatePlannedSets(exerciseId, sets) {
                if (appState.currentSession) {
                    const exercise = appState.currentSession.exercises.find(e => e.exercise_id === exerciseId);
                    if (exercise) {
                        const setsNumber = utils.validateNumber(sets, 1, 20);
                        if (setsNumber > 0) {
                            exercise.planned_sets = setsNumber;
                        } else {
                            // Remettre la valeur précédente si la validation échoue
                            const input = document.querySelector(`input[onchange*="${exerciseId}"]`);
                            if (input) {
                                input.value = exercise.planned_sets;
                            }
                            this.showNotification('Nombre de séries invalide (1-20)');
                        }
                    }
                }
            },
            
            updateExerciseRestTime(exerciseId, restTime) {
                if (appState.currentSession) {
                    const exercise = appState.currentSession.exercises.find(e => e.exercise_id === exerciseId);
                    if (exercise) {
                        const restNumber = utils.validateNumber(restTime, 30, 600);
                        if (restNumber >= 30) {
                            exercise.rest_time = restNumber;
                        } else {
                            // Remettre la valeur précédente si la validation échoue
                            const input = document.querySelector(`input[onchange*="updateExerciseRestTime(${exerciseId}"]`);
                            if (input) {
                                input.value = exercise.rest_time || 90;
                            }
                            this.showNotification('Temps de repos invalide (30-600s)');
                        }
                    }
                }
            },

            updateExerciseDuration(exerciseId, duration) {
                if (appState.currentSession) {
                    const exercise = appState.currentSession.exercises.find(e => e.exercise_id === exerciseId);
                    if (exercise) {
                        const durationNumber = utils.validateNumber(duration, 10, 300);
                        if (durationNumber >= 10) {
                            exercise.duration = durationNumber;
                        } else {
                            // Remettre la valeur précédente si la validation échoue
                            const input = document.querySelector(`input[onchange*="updateExerciseDuration(${exerciseId}"]`);
                            if (input) {
                                const defaultExercise = appState.exercises.find(e => e.id === exerciseId);
                                input.value = exercise.duration || defaultExercise?.default_duration || 30;
                            }
                            this.showNotification('Durée invalide (10-300s)');
                        }
                    }
                }
            },

            updateSessionRestSettings() {
                if (!appState.currentSession) {
                    appState.currentSession = {
                        date: new Date().toISOString().split('T')[0],
                        notes: '',
                        exercises: []
                    };
                }

                const restBetweenExercises = utils.validateNumber(document.getElementById('session-rest-between-exercises')?.value, 30, 600);
                const restBetweenSets = utils.validateNumber(document.getElementById('session-rest-between-sets')?.value, 30, 300);

                if (!appState.currentSession.globalSettings) {
                    appState.currentSession.globalSettings = {};
                }

                appState.currentSession.globalSettings.restBetweenExercises = restBetweenExercises || 120;
                appState.currentSession.globalSettings.restBetweenSets = restBetweenSets || 90;
            },

            startNewSession() {
                appState.currentSession = {
                    date: new Date().toISOString().split('T')[0],
                    notes: '',
                    exercises: [],
                    globalSettings: {
                        restBetweenExercises: 120,
                        restBetweenSets: 90
                    }
                };
                this.showScreen('preparation');
            },
            
            resumeLastSession() {
                const lastSession = appState.sessions[appState.sessions.length - 1];
                if (lastSession) {
                    appState.currentSession = {
                        date: new Date().toISOString().split('T')[0],
                        notes: '',
                        exercises: lastSession.exercises.map(e => ({
                            exercise_id: e.exercise_id,
                            planned_sets: e.planned_sets,
                            rest_time: e.rest_time, // Conserver les temps de repos individuels
                            sets: []
                        })),
                        globalSettings: {
                            // Utiliser les paramètres de la dernière séance ou les valeurs par défaut
                            restBetweenExercises: lastSession.globalSettings?.restBetweenExercises || 120,
                            restBetweenSets: lastSession.globalSettings?.restBetweenSets || 90
                        }
                    };
                    this.showScreen('preparation');
                } else {
                    this.showNotification('Aucune séance précédente trouvée');
                }
            },

            saveSessionManually() {
                if (!appState.currentSession || appState.currentSession.exercises.length === 0) {
                    this.showNotification('Ajoutez au moins un exercice');
                    return;
                }
                
                // Préparer la séance pour saisie manuelle
                appState.manualSession = {
                    ...appState.currentSession,
                    id: Date.now(),
                    startTime: Date.now(),
                    currentExerciseIndex: 0,
                    globalSettings: {
                        restBetweenExercises: appState.currentSession.globalSettings?.restBetweenExercises || 120,
                        restBetweenSets: appState.currentSession.globalSettings?.restBetweenSets || 90
                    }
                };
                this.showScreen('manual-entry');
                render();
            },

            finishManualSession() {
                if (appState.manualSession) {
                    // Préparer la séance à sauvegarder
                    appState.sessionToFinish = {
                        ...appState.manualSession,
                        endTime: Date.now(),
                        date: new Date().toISOString().split('T')[0]
                    };
                    
                    // Nettoyer les variables de session en cours
                    appState.manualSession = null;
                    appState.currentSession = null;
                    
                    // Afficher le modal de difficulté
                    document.getElementById('difficulty-modal').classList.add('active');
                }
            },

            // Fonction pour terminer la séance avec évaluation de difficulté
            finishSessionWithDifficulty(difficulty) {
                if (!appState.sessionToFinish) return;
                
                // Ajouter la difficulté à la séance
                if (difficulty) {
                    appState.sessionToFinish.difficulty = difficulty;
                }
                
                // Sauvegarder la séance
                appState.sessions.push(appState.sessionToFinish);
                
                // Nettoyer les variables temporaires
                appState.sessionToFinish = null;
                
                // Fermer le modal
                document.getElementById('difficulty-modal').classList.remove('active');
                
                // Sauvegarder et rediriger
                this.saveData();
                this.showScreen('dashboard');
                
                const difficultyEmoji = {
                    'Facile': '😊',
                    'Normale': '💪', 
                    'Difficile': '🔥'
                };
                
                this.showNotification(
                    difficulty ? 
                    `${difficultyEmoji[difficulty]} Séance ${difficulty.toLowerCase()} terminée ! 🎉` :
                    'Séance terminée ! 🎉'
                );
                
                // Forcer la mise à jour du calendrier
                setTimeout(() => {
                    render();
                }, 50);
            },

            saveManualSet() {
                if (!appState.manualSession) return;
                
                const currentExercise = appState.manualSession.exercises[appState.manualSession.currentExerciseIndex];
                const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                
                // Récupérer les données de performance selon le mode de l'exercice
                let performance = {};
                const setType = document.getElementById('manual-set-type')?.value || 'work';

                // Récupérer la combinaison d'élastiques (si applicable)
                const elasticsData = exercise.exercise_type === 'elastics' ? updateResistanceDisplay('manual-', exercise.is_unilateral) : { selectedElastics: {}, total: 0 };

                if (exercise.exercise_mode === 'time') {
                    // Mode temps pur - utiliser la valeur du timer ou de l'input
                    const durationInput = document.getElementById('manual-duration');
                    const duration = durationInput ? parseInt(durationInput.value) : (exerciseTimer.duration || 30);
                    
                    performance = {
                        duration: duration,
                        exercise_mode: 'time',
                        elastics: elasticsData.selectedElastics,
                        total_resistance: elasticsData.total
                    };
                    
                    // Arrêter le timer si il était en cours
                    if (exerciseTimer.isRunning) {
                        exerciseTimer.stop();
                    }
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - vérifier le mode choisi
                    const executionMode = document.getElementById('manual-execution-mode')?.value || 'reps';
                    
                    if (executionMode === 'time') {
                        const durationInput = document.getElementById('manual-duration');
                        const duration = durationInput ? parseInt(durationInput.value) : 30;
                        
                        performance = {
                            duration: duration,
                            exercise_mode: 'time',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                        
                        if (exerciseTimer.isRunning) {
                            exerciseTimer.stop();
                        }
                    } else {
                        // Mode répétitions
                        if (exercise.is_unilateral) {
                            performance = {
                                left_reps: parseInt(document.getElementById('manual-left-reps')?.value) || 0,
                                right_reps: parseInt(document.getElementById('manual-right-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        } else {
                            performance = {
                                reps: parseInt(document.getElementById('manual-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        }
                    }
                } else {
                    // Mode répétitions classique
                    if (exercise.is_unilateral) {
                        performance = {
                            left_reps: parseInt(document.getElementById('manual-left-reps')?.value) || 0,
                            right_reps: parseInt(document.getElementById('manual-right-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    } else {
                        performance = {
                            reps: parseInt(document.getElementById('manual-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    }
                }
                
                // Ajouter la série
                currentExercise.sets.push({
                    type: setType,
                    ...performance
                });

                // Vérification de sécurité pour éviter les bugs
                if (!currentExercise.sets) {
                    currentExercise.sets = [];
                }
                
                // Vérifier les records
                this.checkRecords(currentExercise.exercise_id, performance, setType);
                
                // Vérifier si on a atteint le nombre de séries prévues
                if (currentExercise.sets.length >= currentExercise.planned_sets) {
                    // Vérifier s'il y a encore des exercices
                    if (appState.manualSession.currentExerciseIndex + 1 >= appState.manualSession.exercises.length) {
                        // C'était le dernier exercice, proposer de finir
                        if (confirm('Toutes les séries prévues sont terminées. Finir la séance ?')) {
                            this.finishManualSession();
                        } else {
                            render();
                        }
                    } else {
                        // Passer automatiquement à l'exercice suivant
                        this.nextManualExercise();
                    }
                    return;
                }
                
                // Effacer les champs pour la série suivante
                if (exercise.is_unilateral) {
                    document.getElementById('manual-left-reps').value = '';
                    document.getElementById('manual-right-reps').value = '';
                } else {
                    document.getElementById('manual-reps').value = '';
                }
                
                // Remettre les élastiques à zéro
                if (exercise.exercise_type === 'elastics') {
                    if (exercise.is_unilateral) {
                        // Pour les exercices unilatéraux, remettre les deux côtés à zéro
                        Object.keys(ELASTICS_DB).forEach(color => {
                            const selectElementLeft = document.getElementById(`manual-elastic-left-${color}`);
                            const selectElementRight = document.getElementById(`manual-elastic-right-${color}`);
                            if (selectElementLeft) selectElementLeft.value = '0';
                            if (selectElementRight) selectElementRight.value = '0';
                        });
                        updateResistanceDisplay('manual-', true);
                    } else {
                        // Pour les exercices bilatéraux
                        Object.keys(ELASTICS_DB).forEach(color => {
                            const selectElement = document.getElementById(`manual-elastic-${color}`);
                            if (selectElement) selectElement.value = '0';
                        });
                        updateResistanceDisplay('manual-', false);
                    }
                }
            },

            nextManualExercise() {
                if (appState.manualSession) {
                    appState.manualSession.currentExerciseIndex++;
                    if (appState.manualSession.currentExerciseIndex >= appState.manualSession.exercises.length) {
                        this.finishManualSession();
                    } else {
                        render();
                    }
                }
            },
            
            // Séance live
            startLiveSession() {
                if (!appState.currentSession || appState.currentSession.exercises.length === 0) {
                    this.showNotification('Ajoutez au moins un exercice');
                    return;
                }
                
                appState.liveSession = {
                    ...appState.currentSession,
                    id: Date.now(),
                    startTime: Date.now(),
                    currentExerciseIndex: 0,
                    currentSetIndex: 0,
                    isResting: false,
                    isPreparing: true, // NOUVEAU : phase de préparation
                    prepareStartTime: Date.now(),
                    prepareDuration: 5000, // 5 secondes
                    restStartTime: null,
                    restDuration: 0,
                    exercises: appState.currentSession.exercises.map(ex => ({
                        ...ex,
                        sets: ex.sets || []  // IMPORTANT : s'assurer que sets existe
                    })),
                    globalSettings: {
                        restBetweenExercises: appState.currentSession.globalSettings?.restBetweenExercises || 120,
                        restBetweenSets: appState.currentSession.globalSettings?.restBetweenSets || 90
                    }
                };
                
                this.showScreen('live');
                this.startSessionTimer();
                render();
            },

            // Fonction pour mettre en pause la séance live
            pauseLiveSession() {
                if (appState.liveSession && !appState.liveSession.isPaused) {
                    appState.liveSession.isPaused = true;
                    appState.liveSession.pauseStartTime = Date.now();
                    
                    // Arrêter tous les timers
                    this.cleanupTimers();
                    if (exerciseTimer.isRunning) {
                        exerciseTimer.pause();
                    }
                    
                    render();
                    this.showNotification('⏸️ Séance en pause');
                }
            },

            // Fonction pour reprendre la séance live
            resumeLiveSession() {
                if (appState.liveSession && appState.liveSession.isPaused) {
                    const pauseDuration = Date.now() - appState.liveSession.pauseStartTime;
                    
                    // Ajuster les temps de début pour compenser la pause
                    appState.liveSession.startTime += pauseDuration;
                    if (appState.liveSession.restStartTime) {
                        appState.liveSession.restStartTime += pauseDuration;
                    }
                    if (appState.liveSession.prepareStartTime) {
                        appState.liveSession.prepareStartTime += pauseDuration;
                    }
                    
                    appState.liveSession.isPaused = false;
                    delete appState.liveSession.pauseStartTime;
                    
                    // Redémarrer les timers
                    this.startSessionTimer();
                    if (exerciseTimer.isPaused) {
                        exerciseTimer.start();
                    }
                    
                    render();
                    this.showNotification('▶️ Séance reprise');
                }
            },
            
            startSessionTimer() {
                if (appState.sessionTimer) {
                    clearInterval(appState.sessionTimer);
                }
                
                appState.sessionTimer = setInterval(() => {
                    if (appState.liveSession) {
                        const elapsed = Date.now() - appState.liveSession.startTime;
                        const timerElement = document.getElementById('live-timer');
                        if (timerElement) {
                            if (appState.liveSession.isPaused) {
                                // Affichage en mode pause
                                const pauseDuration = Math.floor((Date.now() - appState.liveSession.pauseStartTime) / 1000);
                                timerElement.textContent = `⏸️ ${pauseDuration}s`;
                                timerElement.style.color = 'var(--warning)';
                            } else {
                                // Affichage normal
                                timerElement.textContent = this.formatTime(elapsed);
                                timerElement.style.color = 'var(--primary)';
                            }
                        }
                        
                        // Gérer le timer de repos
                        if (appState.liveSession.isResting && !appState.liveSession.isPaused) {
                            const restElapsed = Date.now() - appState.liveSession.restStartTime;
                            const restRemaining = Math.max(0, appState.liveSession.restDuration - restElapsed);
                            const restElement = document.querySelector('.rest-time');
                            if (restElement) {
                                // Forcer la mise à jour de l'affichage à chaque seconde
                                const secondsRemaining = Math.ceil(restRemaining / 1000);
                                const minutes = Math.floor(secondsRemaining / 60);
                                const seconds = secondsRemaining % 60;
                                restElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                            
                                // Couleurs selon le temps restant
                                if (restRemaining <= 5000) {
                                    restElement.style.color = 'var(--danger)';
                                } else if (restRemaining <= 10000) {
                                    restElement.style.color = 'var(--warning)';
                                } else {
                                    restElement.style.color = 'var(--warning)';
                                }
                            
                                // Sons pour les dernières secondes (éviter les répétitions)
                                const currentSecond = Math.floor(restRemaining / 1000);
                                if (!appState.liveSession.lastRestSecond || appState.liveSession.lastRestSecond !== currentSecond) {
                                    appState.liveSession.lastRestSecond = currentSecond;
                                    // Bip à chaque seconde pendant les 5 dernières secondes
                                    if (currentSecond <= 5 && currentSecond > 0) {
                                        exerciseTimer.playBeep(800, 200);
                                        if ('vibrate' in navigator) {
                                            navigator.vibrate(100);
                                        }
                                    } else if (currentSecond === 0) {
                                        // Son spécial pour la fin
                                        exerciseTimer.playBeep(1000, 500);
                                        if ('vibrate' in navigator) {
                                            navigator.vibrate([200, 100, 200]);
                                        }
                                    }
                                }
                            
                                // Passer automatiquement quand le repos est fini
                                if (restRemaining === 0) {
                                    appState.liveSession.isResting = false;
                                    appState.liveSession.lastRestSecond = null; // Reset
                                    
                                    // CORRECTION : Vérifier que l'index est valide
                                    if (appState.liveSession.currentExerciseIndex < appState.liveSession.exercises.length) {
                                        const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                                    
                                        // Ne PAS passer automatiquement à l'exercice suivant ici
                                        // C'est déjà géré dans validateSet()
                                        render();
                                    } else {
                                        // Index invalide, terminer la séance
                                        this.finishLiveSession();
                                    }
                                }
                            }
                        }

                        // Gérer le timer de préparation
                        if (appState.liveSession.isPreparing) {
                            const prepareElapsed = Date.now() - appState.liveSession.prepareStartTime;
                            const prepareRemaining = Math.max(0, appState.liveSession.prepareDuration - prepareElapsed);
                            const countdownElement = document.getElementById('countdown-display');
                            
                            if (countdownElement) {
                                const secondsLeft = Math.ceil(prepareRemaining / 1000);
                                countdownElement.textContent = secondsLeft;
                                
                                // Changer la couleur selon le temps restant
                                if (secondsLeft <= 2) {
                                    countdownElement.style.color = 'var(--danger)';
                                } else if (secondsLeft <= 3) {
                                    countdownElement.style.color = 'var(--warning)';
                                } else {
                                    countdownElement.style.color = 'var(--primary)';
                                }
                                
                                // Sons aux dernières secondes (éviter les répétitions)
                                if (secondsLeft <= 3 && secondsLeft > 0) {
                                    const currentSecond = Math.floor(prepareRemaining / 1000);
                                    const lastSecond = Math.floor((prepareRemaining + 1000) / 1000);
                                    if (currentSecond !== lastSecond) {
                                        exerciseTimer.playBeep(800, 200);
                                    }
                                }
                                
                                // Fin de la préparation
                                if (prepareRemaining === 0) {
                                    appState.liveSession.isPreparing = false;
                                    exerciseTimer.playBeep(1000, 500); // Son de début plus long
                                    
                                    // Démarrer automatiquement le timer si l'exercice est en mode temps
                                    const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                                    const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                                
                                    // Attendre un petit moment après le son pour démarrer
                                    setTimeout(() => {
                                        render();
                                    
                                        // Si l'exercice est en mode temps, démarrer automatiquement le timer
                                        if (exercise && (exercise.exercise_mode === 'time' || 
                                            (exercise.exercise_mode === 'both' && document.getElementById('execution-mode')?.value === 'time'))) {
                                        
                                            // Configurer et démarrer le timer automatiquement
                                            setTimeout(() => {
                                                const durationInput = document.getElementById('duration');
                                                const defaultDuration = exercise.default_duration || 30;
                                                if (durationInput) {
                                                    durationInput.value = defaultDuration;
                                                }
                                                
                                                exerciseTimer.setup(
                                                    defaultDuration,
                                                    updateTimerDisplay,
                                                    completeTimedExercise
                                                );
                                                
                                                // Démarrer automatiquement
                                                startExerciseTimer();
                                            }, 200); // Petit délai pour que le DOM soit prêt
                                        }
                                    }, 500); // Délai pour que le son se termine
                                }
                            }
                        }
                    }
                }, 1000);
            },
            
            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            },
            
            // Calculer la progression basée sur les séries
            calculateSessionProgress() {
                if (!appState.liveSession || !appState.liveSession.exercises) return 0;
                
                let totalPlannedSets = 0;
                let totalCompletedSets = 0;
                
                appState.liveSession.exercises.forEach(exerciseData => {
                    totalPlannedSets += exerciseData.planned_sets || 0;
                    totalCompletedSets += exerciseData.sets ? exerciseData.sets.length : 0;
                });
                
                if (totalPlannedSets === 0) return 0;
                return Math.round((totalCompletedSets / totalPlannedSets) * 100);
            },

            validateSet() {
                if (!appState.liveSession) return;
                
                const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                
                // Récupérer les données de performance selon le mode de l'exercice
                let performance = {};
                const setType = document.getElementById('set-type')?.value || 'work';

                // Récupérer la combinaison d'élastiques (si applicable)
                const elasticsData = exercise.exercise_type === 'elastics' ? updateResistanceDisplay('', exercise.is_unilateral) : { selectedElastics: {}, total: 0 };

                if (exercise.exercise_mode === 'time') {
                    // Mode temps pur - utiliser la valeur du timer ou de l'input
                    const durationInput = document.getElementById('duration');
                    const duration = durationInput ? parseInt(durationInput.value) : (exerciseTimer.duration || 30);
                    
                    performance = {
                        duration: duration,
                        exercise_mode: 'time',
                        elastics: elasticsData.selectedElastics,
                        total_resistance: elasticsData.total
                    };
                    
                    // Arrêter le timer si il était en cours
                    if (exerciseTimer.isRunning) {
                        exerciseTimer.stop();
                    }
                    
                } else if (exercise.exercise_mode === 'both') {
                    // Mode mixte - vérifier le mode choisi
                    const executionMode = document.getElementById('execution-mode')?.value || 'reps';
                    
                    if (executionMode === 'time') {
                        const durationInput = document.getElementById('duration');
                        const duration = durationInput ? parseInt(durationInput.value) : 30;
                        
                        performance = {
                            duration: duration,
                            exercise_mode: 'time',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                        
                        if (exerciseTimer.isRunning) {
                            exerciseTimer.stop();
                        }
                    } else {
                        // Mode répétitions
                        if (exercise.is_unilateral) {
                            performance = {
                                left_reps: parseInt(document.getElementById('left-reps')?.value) || 0,
                                right_reps: parseInt(document.getElementById('right-reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        } else {
                            performance = {
                                reps: parseInt(document.getElementById('reps')?.value) || 0,
                                exercise_mode: 'reps',
                                elastics: elasticsData.selectedElastics,
                                total_resistance: elasticsData.total
                            };
                        }
                    }
                } else {
                    // Mode répétitions classique
                    if (exercise.is_unilateral) {
                        performance = {
                            left_reps: parseInt(document.getElementById('left-reps')?.value) || 0,
                            right_reps: parseInt(document.getElementById('right-reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    } else {
                        performance = {
                            reps: parseInt(document.getElementById('reps')?.value) || 0,
                            exercise_mode: 'reps',
                            elastics: elasticsData.selectedElastics,
                            total_resistance: elasticsData.total
                        };
                    }
                }
                
                // Ajouter la série
                currentExercise.sets.push({
                    type: setType,
                    ...performance
                });
                
                // Remettre les élastiques à zéro après validation
                if (exercise.exercise_type === 'elastics') {
                    if (exercise.is_unilateral) {
                        // Pour les exercices unilatéraux, remettre les deux côtés à zéro
                        Object.keys(ELASTICS_DB).forEach(color => {
                            const selectElementLeft = document.getElementById(`elastic-left-${color}`);
                            const selectElementRight = document.getElementById(`elastic-right-${color}`);
                            if (selectElementLeft) selectElementLeft.value = '0';
                            if (selectElementRight) selectElementRight.value = '0';
                        });
                        updateResistanceDisplay('', true);
                    } else {
                        // Pour les exercices bilatéraux
                        Object.keys(ELASTICS_DB).forEach(color => {
                            const selectElement = document.getElementById(`elastic-${color}`);
                            if (selectElement) selectElement.value = '0';
                        });
                        updateResistanceDisplay('', false);
                    }
                }        

                // Vérifier les records
                this.checkRecords(currentExercise.exercise_id, performance, setType);
                
                // Vérifier si on a atteint le nombre de séries prévues
                if (currentExercise.sets.length >= currentExercise.planned_sets) {
                    // Vérifier s'il y a encore des exercices
                    if (appState.liveSession.currentExerciseIndex + 1 >= appState.liveSession.exercises.length) {
                        // C'était le dernier exercice, finir la séance
                        this.finishLiveSession();
                    } else {
                        // Passer à l'exercice suivant
                        this.nextExercise();
                    }
                } else {
                    // Passer au repos pour la série suivante
                    appState.liveSession.isResting = true;
                    appState.liveSession.restStartTime = Date.now();
                    const sessionExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                    // Utiliser UNIQUEMENT le temps de repos spécifique à l'exercice, pas les règles globales
                    const customRestTime = sessionExercise.rest_time || exercise.default_rest_time;
                    appState.liveSession.restDuration = customRestTime * 1000;
                    render();
                }
            },
            
            skipRest() {
                if (appState.liveSession) {
                    appState.liveSession.isResting = false;
                    render();
                }
            },
            
            nextExercise() {
                if (!appState.liveSession) return;
                
                appState.liveSession.currentExerciseIndex++;
                appState.liveSession.currentSetIndex = 0;
                
                if (appState.liveSession.currentExerciseIndex >= appState.liveSession.exercises.length) {
                    this.finishLiveSession();
                } else {
                    // Repos avant le prochain exercice - utiliser le temps de repos entre exercices
                    appState.liveSession.isResting = true;
                    appState.liveSession.restStartTime = Date.now();
                    
                    // CORRECTION : Utiliser le temps de repos global entre exercices
                    const restBetweenExercises = appState.liveSession.globalSettings?.restBetweenExercises || 120;
                    appState.liveSession.restDuration = restBetweenExercises * 1000;
                    
                    render();
                }
            },
            
            // Nettoyer tous les timers actifs
            cleanupTimers() {
                if (appState.sessionTimer) {
                    clearInterval(appState.sessionTimer);
                    appState.sessionTimer = null;
                }
                if (appState.restTimer) {
                    clearInterval(appState.restTimer);
                    appState.restTimer = null;
                }
            },

            finishLiveSession() {
                if (!appState.liveSession) return;
                
                // Préparer la séance à sauvegarder
                appState.sessionToFinish = {
                    ...appState.liveSession,
                    endTime: Date.now(),
                    date: new Date().toISOString().split('T')[0]
                };
                
                // Nettoyer les timers
                this.cleanupTimers();
                if (exerciseTimer.isRunning) {
                    exerciseTimer.stop();
                }
                
                // Nettoyer les variables de session en cours
                appState.liveSession = null;
                appState.currentSession = null;
                
                // Afficher le modal de difficulté
                document.getElementById('difficulty-modal').classList.add('active');
            },
            
            stopLiveSession() {
                if (confirm('Arrêter la séance ? Les données seront perdues.')) {
                    appState.liveSession = null;
                    this.cleanupTimers(); // Utilise la nouvelle fonction
                    this.showScreen('preparation');
                    render();
                }
            },
            
            // Gestion des records
            checkRecords(exerciseId, performance, setType) {
                if (setType !== 'work') return; // Seules les séries de travail comptent pour les records
                
                if (!appState.records[exerciseId]) {
                    appState.records[exerciseId] = [];
                }
                
                const today = new Date().toISOString().split('T')[0];
                let newRecords = [];
                
                // Record de poids max (utiliser la résistance totale des élastiques)
                let maxWeight = performance.total_resistance || 0;
                
                const currentMaxWeight = this.getCurrentRecord(exerciseId, 'max_weight');
                if (maxWeight > currentMaxWeight) {
                    newRecords.push({ date: today, type: 'max_weight', value: maxWeight });
                }
                
                // Record de répétitions max
                let maxReps = 0;
                if (performance.reps) {
                    maxReps = performance.reps;
                } else if (performance.left_reps && performance.right_reps) {
                    maxReps = Math.max(performance.left_reps, performance.right_reps);
                }
                
                const currentMaxReps = this.getCurrentRecord(exerciseId, 'max_reps');
                if (maxReps > currentMaxReps) {
                    newRecords.push({ date: today, type: 'max_reps', value: maxReps });
                }

                // Record de temps max (pour les exercices en mode temps)
                if (performance.exercise_mode === 'time' && performance.duration) {
                    const currentMaxTime = this.getCurrentRecord(exerciseId, 'max_time');
                    if (performance.duration > currentMaxTime) {
                        newRecords.push({ date: today, type: 'max_time', value: performance.duration });
                    }
                }
                
                // 1RM estimé (formule d'Epley)
                if (maxWeight > 0 && maxReps > 0) {
                    const estimated1RM = maxWeight * (1 + maxReps / 30);
                    const current1RM = this.getCurrentRecord(exerciseId, 'max_1rm');
                    if (estimated1RM > current1RM) {
                        newRecords.push({ date: today, type: 'max_1rm', value: estimated1RM });
                    }
                }
                
                // Ajouter les nouveaux records
                if (newRecords.length > 0) {
                    appState.records[exerciseId].push(...newRecords);
                    this.showNotification('🎉 Nouveau PR !');
                }
            },
            
            getCurrentRecord(exerciseId, type) {
                const records = appState.records[exerciseId] || [];
                const typeRecords = records.filter(r => r.type === type);
                return typeRecords.length > 0 ? Math.max(...typeRecords.map(r => r.value)) : 0;
            },

            getLastPerformance(exerciseId) {
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                if (!exercise) return null;

                // Trouver la dernière séance avec cet exercice
                const sessionsWithExercise = appState.sessions
                    .filter(session => session.exercises.some(ex => ex.exercise_id === exerciseId))
                    .sort((a, b) => b.date.localeCompare(a.date));

                if (sessionsWithExercise.length === 0) return null;

                const lastSession = sessionsWithExercise[0];
                const exerciseData = lastSession.exercises.find(ex => ex.exercise_id === exerciseId);

                if (!exerciseData || exerciseData.sets.length === 0) return null;

                // Récupérer TOUTES les séries de la dernière séance (pas seulement la meilleure)
                const workSets = exerciseData.sets.filter(set => set.type === 'work');
                if (workSets.length === 0) return null;

                // Retourner toutes les séries avec leurs détails
                const allSets = workSets.map(set => {
                    if (exercise.is_unilateral) {
                        return {
                            left_reps: set.left_reps || 0,
                            right_reps: set.right_reps || 0,
                            resistance: set.total_resistance || 0,
                            exercise_mode: set.exercise_mode || 'reps',
                            duration: set.duration || 0
                        };
                    } else {
                        return {
                            reps: set.reps || 0,
                            resistance: set.total_resistance || 0,
                            exercise_mode: set.exercise_mode || 'reps',
                            duration: set.duration || 0
                        };
                    }
                });

                return {
                    date: lastSession.date,
                    sets: allSets,
                    totalSets: allSets.length
                };
            },

            getLastPerformanceForSet(exerciseId, setNumber) {
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                if (!exercise) return null;

                // Trouver la dernière séance avec cet exercice
                const sessionsWithExercise = appState.sessions
                    .filter(session => session.exercises.some(ex => ex.exercise_id === exerciseId))
                    .sort((a, b) => b.date.localeCompare(a.date));

                if (sessionsWithExercise.length === 0) return null;

                const lastSession = sessionsWithExercise[0];
                const exerciseData = lastSession.exercises.find(ex => ex.exercise_id === exerciseId);

                if (!exerciseData || exerciseData.sets.length < setNumber) return null;

                // Récupérer la série spécifique (setNumber - 1 car les arrays commencent à 0)
                const specificSet = exerciseData.sets[setNumber - 1];
                if (!specificSet || specificSet.type !== 'work') return null;

                // Adapter le retour selon le mode de l'exercice
                if (specificSet.exercise_mode === 'time') {
                    return {
                        date: lastSession.date,
                        resistance: specificSet.total_resistance || 0,
                        duration: specificSet.duration || 0,
                        mode: 'time',
                        setNumber: setNumber,
                        elastics: specificSet.elastics || {}
                    };
                } else {
                    return {
                        date: lastSession.date,
                        resistance: specificSet.total_resistance || 0,
                        reps: exercise.is_unilateral ?
                            `${specificSet.left_reps || 0}G/${specificSet.right_reps || 0}D` :
                            (specificSet.reps || 0),
                        mode: 'reps',
                        setNumber: setNumber,
                        elastics: specificSet.elastics || {}
                    };
                }
            },

            getAllLastPerformances(exerciseId) {
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                if (!exercise) return null;

                // Trouver la dernière séance avec cet exercice
                const sessionsWithExercise = appState.sessions
                    .filter(session => session.exercises.some(ex => ex.exercise_id === exerciseId))
                    .sort((a, b) => b.date.localeCompare(a.date));

                if (sessionsWithExercise.length === 0) return null;

                const lastSession = sessionsWithExercise[0];
                const exerciseData = lastSession.exercises.find(ex => ex.exercise_id === exerciseId);

                if (!exerciseData || exerciseData.sets.length === 0) return null;

                // Récupérer toutes les séries de travail
                const workSets = exerciseData.sets.filter(set => set.type === 'work');
                if (workSets.length === 0) return null;

                return {
                    date: lastSession.date,
                    sets: workSets.map((set, index) => {
                        if (set.exercise_mode === 'time') {
                            return {
                                setNumber: index + 1,
                                resistance: set.total_resistance || 0,
                                duration: set.duration || 0,
                                mode: 'time'
                            };
                        } else {
                            return {
                                setNumber: index + 1,
                                resistance: set.total_resistance || 0,
                                reps: exercise.is_unilateral ?
                                    `${set.left_reps || 0}G/${set.right_reps || 0}D` :
                                    (set.reps || 0),
                                mode: 'reps'
                            };
                        }
                    })
                };
            },

            // Navigation du calendrier
            previousMonth() {
                if (!appState.calendarDate) {
                    appState.calendarDate = new Date();
                }
                appState.calendarDate.setMonth(appState.calendarDate.getMonth() - 1);
                render();
            },

            nextMonth() {
                if (!appState.calendarDate) {
                    appState.calendarDate = new Date();
                }
                appState.calendarDate.setMonth(appState.calendarDate.getMonth() + 1);
                render();
            },

            generateMeasurementsChart() {
                console.log('Measurements data:', appState.measurements); // LIGNE DE DEBUG
                if (appState.measurements.length === 0) {
                    return '<p style="text-align: center; color: var(--text-secondary);">Aucune donnée disponible</p>';
                }
    
                // Trier par date
                const sortedMeasurements = [...appState.measurements].sort((a, b) => a.date.localeCompare(b.date));
    
                let chartHtml = '<div style="font-size: 12px; max-height: 250px; overflow-y: auto;">';
    
                // Graphique du poids
                const weightData = sortedMeasurements.filter(m => m.weight && m.weight > 0);
                if (weightData.length > 0) {
                    chartHtml += '<h4>Évolution du poids</h4>';
                    const maxWeight = Math.max(...weightData.map(d => d.weight));
                    const minWeight = Math.min(...weightData.map(d => d.weight));
        
                    weightData.forEach(data => {
                        const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                        const barWidth = Math.max(10, ((data.weight - minWeight) / (maxWeight - minWeight)) * 80 + 20);
            
                        chartHtml += `
                        <div style="display: flex; align-items: center; margin: 4px 0;">
                            <div style="width: 60px; font-size: 10px;">${date}</div>
                            <div style="width: ${barWidth}%; height: 15px; background: var(--primary); margin: 0 8px; border-radius: 2px;"></div>
                            <div style="font-size: 10px;">${data.weight}kg</div>
                        </div>
                        `;
                    });
                }
    
                // Graphique de la taille
                const waistData = sortedMeasurements.filter(m => m.waist && m.waist > 0);
                if (waistData.length > 0) {
                    chartHtml += '<h4 style="margin-top: 16px;">Évolution tour de taille</h4>';
                    const maxWaist = Math.max(...waistData.map(d => d.waist));
                    const minWaist = Math.min(...waistData.map(d => d.waist));
                    
                    waistData.forEach(data => {
                        const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                        const barWidth = Math.max(10, ((data.waist - minWaist) / (maxWaist - minWaist)) * 80 + 20);
                        
                        chartHtml += `
                            <div style="display: flex; align-items: center; margin: 4px 0;">
                                <div style="width: 60px; font-size: 10px;">${date}</div>
                                <div style="width: ${barWidth}%; height: 15px; background: var(--secondary); margin: 0 8px; border-radius: 2px;"></div>
                                <div style="font-size: 10px;">${data.waist}cm</div>
                            </div>
                        `;
                    });
                }
                
                // Si aucune donnée n'est disponible
                if (weightData.length === 0 && waistData.length === 0) {
                    chartHtml += '<p style="text-align: center; color: var(--text-secondary);">Ajoutez des mensurations pour voir les graphiques</p>';
                }
                
                chartHtml += '</div>';
                return chartHtml;
            },
    

            generateSimpleChart(exerciseId, exerciseName) {
                // Récupérer les données de performance
                const performanceData = [];
                const exercise = appState.exercises.find(e => e.id === exerciseId);
                
                appState.sessions.forEach(session => {
                    const sessionExercise = session.exercises.find(e => e.exercise_id === exerciseId);
                    if (sessionExercise && sessionExercise.sets.length > 0) {
                        // Calculer le meilleur set de la séance
                        let maxWeight = 0;
                        let maxReps = 0;
                        
                        sessionExercise.sets.forEach(set => {
                            if (set.type === 'work') {
                                // Utiliser la résistance totale des élastiques
                                const setWeight = set.total_resistance || 0;
                                if (setWeight > maxWeight) maxWeight = setWeight;
                                
                                // Pour les répétitions
                                if (exercise.is_unilateral) {
                                    const leftReps = set.left_reps || 0;
                                    const rightReps = set.right_reps || 0;
                                    if (leftReps > maxReps) maxReps = leftReps;
                                    if (rightReps > maxReps) maxReps = rightReps;
                                } else {
                                    const setReps = set.reps || 0;
                                    if (setReps > maxReps) maxReps = setReps;
                                }
                            }
                        });
                        
                        if (maxWeight > 0 || maxReps > 0) {
                            performanceData.push({
                                date: session.date,
                                weight: maxWeight,
                                reps: maxReps,
                                volume: maxWeight * maxReps
                            });
                        }
                    }
                });
                
                if (performanceData.length === 0) {
                    return '<p style="text-align: center; color: var(--text-secondary);">Aucune donnée disponible</p>';
                }
                
                // Trier par date
                performanceData.sort((a, b) => a.date.localeCompare(b.date));
                
                // Créer un graphique simple
                let chartHtml = `<div style="font-size: 12px; max-height: 250px; overflow-y: auto;">`;
                chartHtml += `<h4>Progression du poids max</h4>`;
                
                const maxWeight = Math.max(...performanceData.map(d => d.weight));
                
                performanceData.forEach((data, index) => {
                    const date = new Date(data.date).toLocaleDateString('fr-FR', {month: 'short', day: 'numeric'});
                    const barWidth = Math.max(1, (data.weight / maxWeight) * 100);
                    
                    chartHtml += `
                        <div style="display: flex; align-items: center; margin: 4px 0;">
                            <div style="width: 60px; font-size: 10px;">${date}</div>
                            <div style="width: ${barWidth}%; height: 20px; background: var(--primary); margin: 0 8px; border-radius: 2px;"></div>
                            <div style="font-size: 10px;">${data.weight}kg</div>
                        </div>
                    `;
                });
                
                chartHtml += `</div>`;
                return chartHtml;
            },
            
            // Gestion des mesures corporelles
            addMeasurement() {
                const date = document.getElementById('measurement-date').value;
                const height = parseFloat(document.getElementById('measurement-height').value);
                const weight = parseFloat(document.getElementById('measurement-weight').value);
                const waist = parseFloat(document.getElementById('measurement-waist').value);
                const chest = parseFloat(document.getElementById('measurement-chest').value);
                const arm = parseFloat(document.getElementById('measurement-arm').value);
                const thigh = parseFloat(document.getElementById('measurement-thigh').value);

                if (!date) {
                    this.showNotification('Date requise');
                    return;
                }

                // Calculer l'IMC si taille et poids sont renseignés
                let imc = 0;
                let imcCategory = '';
                if (height > 0 && weight > 0) {
                    const heightInMeters = height / 100;
                    imc = weight / (heightInMeters * heightInMeters);
                    
                    // Déterminer la catégorie IMC
                    if (imc < 18.5) {
                        imcCategory = 'Insuffisance pondérale';
                    } else if (imc < 25) {
                        imcCategory = 'Poids normal';
                    } else if (imc < 30) {
                        imcCategory = 'Surpoids';
                    } else if (imc < 35) {
                        imcCategory = 'Obésité modérée';
                    } else if (imc < 40) {
                        imcCategory = 'Obésité sévère';
                    } else {
                        imcCategory = 'Obésité morbide';
                    }
                }

                const newMeasurement = {
                    id: Date.now(),
                    date,
                    height: height || 0,
                    weight: weight || 0,
                    waist: waist || 0,
                    chest: chest || 0,
                    arm: arm || 0,
                    thigh: thigh || 0,
                    imc: Math.round(imc * 10) / 10, // Arrondir à 1 décimale
                    imcCategory: imcCategory
                };

                appState.measurements.push(newMeasurement);
                this.clearMeasurementForm();
                this.saveData();
                render();
                
                if (imc > 0) {
                    this.showNotification(`Mensuration ajoutée ! IMC: ${newMeasurement.imc} (${imcCategory})`);
                } else {
                    this.showNotification('Mensuration ajoutée !');
                }
            },
            
            deleteMeasurement(id) {
                if (confirm('Supprimer cette mesure ?')) {
                    appState.measurements = appState.measurements.filter(m => m.id !== id);
                    this.saveData();
                    render();
                    this.showNotification('Mensuration supprimée');
                }
            },
            
            clearMeasurementForm() {
                document.getElementById('measurement-date').value = '';
                document.getElementById('measurement-height').value = '';
                document.getElementById('measurement-weight').value = '';
                document.getElementById('measurement-waist').value = '';
                document.getElementById('measurement-chest').value = '';
                document.getElementById('measurement-arm').value = '';
                document.getElementById('measurement-thigh').value = '';
            },
            
            // Statistiques
            updateStats(exerciseId) {
                const exerciseSelect = document.getElementById('stats-exercise-select');
                if (exerciseSelect) {
                    exerciseSelect.dataset.currentValue = exerciseId;
                }
                render();
            },

            // Calculer les statistiques générales
            calculateGeneralStats() {
                // Vérifier le cache d'abord
                const cacheKey = { sessionsCount: appState.sessions.length, today: new Date().toISOString().split('T')[0] };
                const cached = smartCache.get('generalStats', cacheKey);
                if (cached) {
                    console.log('📊 Stats générales récupérées du cache');
                    return cached;
                }
                
                console.log('📊 Calcul des stats générales...');
                const now = new Date();
                const today = now.toISOString().split('T')[0];

                // Calculer le début de la semaine (lundi)
                const startOfWeek = new Date(now);
                const dayOfWeek = now.getDay();
                const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Dimanche = 0
                startOfWeek.setDate(now.getDate() - daysToMonday);
                startOfWeek.setHours(0, 0, 0, 0);
                const weekStart = startOfWeek.toISOString().split('T')[0];

                // Calculer le début du mois
                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                const monthStart = startOfMonth.toISOString().split('T')[0];

                // Statistiques cette semaine
                const sessionsThisWeek = appState.sessions.filter(session =>
                    session.date >= weekStart && session.date <= today
                );

                // Statistiques ce mois
                const sessionsThisMonth = appState.sessions.filter(session =>
                    session.date >= monthStart && session.date <= today
                );

                // Calculer le volume total cette semaine
                let totalVolumeThisWeek = 0;
                sessionsThisWeek.forEach(session => {
                    session.exercises.forEach(ex => {
                        const exercise = appState.exercises.find(e => e.id === ex.exercise_id);
                        ex.sets.forEach(set => {
                            if (set.type === 'work' && set.exercise_mode !== 'time') {
                                let resistance = 0;
                                let reps = 0;
                                if (exercise && exercise.is_unilateral) {
                                    if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                        resistance = (set.total_resistance.left || 0) + (set.total_resistance.right || 0);
                                    } else {
                                        resistance = (set.total_resistance || 0) * 2;
                                    }
                                    reps = (set.left_reps || 0) + (set.right_reps || 0);
                                } else {
                                    resistance = set.total_resistance || 0;
                                    reps = set.reps || 0;
                                }
                                totalVolumeThisWeek += (resistance * reps);
                            }
                        });
                    });
                });

                // Calculer le volume total ce mois
                let totalVolumeThisMonth = 0;
                sessionsThisMonth.forEach(session => {
                    session.exercises.forEach(ex => {
                        const exercise = appState.exercises.find(e => e.id === ex.exercise_id);
                        ex.sets.forEach(set => {
                            if (set.type === 'work' && set.exercise_mode !== 'time') {
                                let resistance = 0;
                                let reps = 0;
                                if (exercise && exercise.is_unilateral) {
                                    if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                        resistance = (set.total_resistance.left || 0) + (set.total_resistance.right || 0);
                                    } else {
                                        resistance = (set.total_resistance || 0) * 2;
                                    }
                                    reps = (set.left_reps || 0) + (set.right_reps || 0);
                                } else {
                                    resistance = set.total_resistance || 0;
                                    reps = set.reps || 0;
                                }
                                totalVolumeThisMonth += (resistance * reps);
                            }
                        });
                    });
                });

                // Calculer la durée moyenne des séances
                let totalDuration = 0;
                let sessionsWithDuration = 0;
                appState.sessions.forEach(session => {
                    if (session.endTime && session.startTime) {
                        totalDuration += (session.endTime - session.startTime);
                        sessionsWithDuration++;
                    }
                });
                const averageSessionDuration = sessionsWithDuration > 0 ?
                    Math.round(totalDuration / sessionsWithDuration / 1000 / 60) : 0;

                // Récupérer les records récents (derniers 30 jours)
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                const thirtyDaysAgoStr = thirtyDaysAgo.toISOString().split('T')[0];
                const recentRecords = [];
                Object.keys(appState.records).forEach(exerciseId => {
                    const exercise = appState.exercises.find(e => e.id == exerciseId);
                    if (exercise) {
                        const records = appState.records[exerciseId] || [];
                        records.forEach(record => {
                            if (record.date >= thirtyDaysAgoStr) {
                                recentRecords.push({
                                    ...record,
                                    exerciseName: exercise.name
                                });
                            }
                        });
                    }
                });

                // Trier les records récents par date (plus récent en premier)
                recentRecords.sort((a, b) => b.date.localeCompare(a.date));

                const result = {
                    sessionsThisWeek: sessionsThisWeek.length,
                    totalVolumeThisWeek: Math.round(totalVolumeThisWeek),
                    sessionsThisMonth: sessionsThisMonth.length,
                    totalVolumeThisMonth: Math.round(totalVolumeThisMonth),
                    averageSessionDuration,
                    totalSessions: appState.sessions.length,
                    recentRecords: recentRecords.slice(0, 10)
                };

                // Mettre en cache et retourner
                return smartCache.set('generalStats', cacheKey, result);
            },
            
            // Modals
            showTemplates() {
                document.getElementById('templates-modal').classList.add('active');
                this.renderTemplatesModal();
            },
            
            showImportModal() {
                document.getElementById('import-modal').classList.add('active');
            },
            
            closeModal(modalId) {
                document.getElementById(modalId).classList.remove('active');
            },
            
            loadTemplate(templateId) {
                const template = appState.templates.find(t => t.id === templateId);
                if (!template) {
                    this.showNotification('Modèle introuvable');
                    return;
                }
                
                if (!appState.currentSession) {
                    appState.currentSession = {
                        date: new Date().toISOString().split('T')[0],
                        notes: '',
                        exercises: [],
                        globalSettings: {
                            restBetweenExercises: 120,
                            restBetweenSets: 90
                        }
                    };
                }

                // Remplacer tous les exercices par ceux du modèle
                appState.currentSession.exercises = [];
                
                if (template.exercises && template.exercises.length > 0) {
                    // Nouveau format avec ordre et paramètres détaillés
                    template.exercises.forEach(exData => {
                        const exercise = appState.exercises.find(e => e.id === exData.exerciseId);
                        if (exercise) {
                            appState.currentSession.exercises.push({
                                exercise_id: exData.exerciseId,
                                planned_sets: exData.plannedSets || 3,
                                rest_time: exData.restTime || exercise.default_rest_time || 90,
                                duration: exData.duration || exercise.default_duration || 30,
                                sets: []
                            });
                        }
                    });
                
                    // Appliquer les paramètres globaux s'ils existent
                    if (template.globalSettings) {
                        appState.currentSession.globalSettings = {
                            restBetweenExercises: template.globalSettings.restBetweenExercises || 120,
                            restBetweenSets: template.globalSettings.restBetweenSets || 90
                        };
                    }
                } else {
                    // Compatibilité avec l'ancien format
                    (template.exerciseIds || []).forEach(exerciseId => {
                        const exercise = appState.exercises.find(e => e.id === exerciseId);
                        if (exercise) {
                            appState.currentSession.exercises.push({
                                exercise_id: exerciseId,
                                planned_sets: 3,
                                rest_time: exercise.default_rest_time || 90,
                                duration: exercise.default_duration || 30,
                                sets: []
                            });
                        }
                    });
                }

                this.closeModal('templates-modal');
                render();
                this.showNotification(`Modèle "${template.name}" chargé ! (${appState.currentSession.exercises.length} exercices)`);
            },
            
            // Éditer un modèle existant
            editTemplate(templateId) {
                const template = appState.templates.find(t => t.id === templateId);
                if (template) {
                    // Pré-remplir le nom
                    document.getElementById('template-name').value = template.name;
                    
                    // Charger la structure dans templateInCreation
                    if (template.exercises && template.exercises.length > 0) {
                        // Nouveau format
                        appState.templateInCreation = {
                            exercises: template.exercises.map(ex => ({
                                exerciseId: ex.exerciseId,
                                plannedSets: ex.plannedSets,
                                restTime: ex.restTime
                            })),
                            globalSettings: template.globalSettings || {
                                restBetweenExercises: 120,
                                restBetweenSets: 90
                            }
                        };
                    } else {
                        // Convertir l'ancien format
                        appState.templateInCreation = {
                            exercises: (template.exerciseIds || []).map(exerciseId => ({
                                exerciseId: exerciseId,
                                plannedSets: 3,
                                restTime: 90
                            })),
                            globalSettings: {
                                restBetweenExercises: 120,
                                restBetweenSets: 90
                            }
                        };
                    }
                
                    // Marquer comme modification d'un modèle existant
                    appState.editingTemplateId = templateId;
                    
                    // Supprimer l'ancien modèle (il sera re-créé à la sauvegarde)
                    appState.templates = appState.templates.filter(t => t.id !== templateId);
                    
                    // Remplir les paramètres globaux
                    const restBetweenExercises = document.getElementById('template-rest-between-exercises');
                    const restBetweenSets = document.getElementById('template-rest-between-sets');
                    
                    if (restBetweenExercises) {
                        restBetweenExercises.value = appState.templateInCreation.globalSettings.restBetweenExercises;
                    }
                    if (restBetweenSets) {
                        restBetweenSets.value = appState.templateInCreation.globalSettings.restBetweenSets;
                    }
                
                    // Réafficher les exercices sélectionnés
                    this.renderSelectedExercises();
                    
                    this.showNotification('Modèle chargé pour modification');
                }
            },

            // Thème
            toggleTheme() {
                appState.settings.theme = appState.settings.theme === 'light' ? 'dark' : 'light';
                this.applyTheme();
                this.saveData();
            },
            
            applyTheme() {
                document.documentElement.setAttribute('data-theme', appState.settings.theme);
                const checkbox = document.getElementById('dark-theme');
                if (checkbox) {
                    checkbox.checked = appState.settings.theme === 'dark';
                }
            },
            
            // Import/Export
            exportData() {
                const data = {
                    exercises: appState.exercises,
                    sessions: appState.sessions,
                    templates: appState.templates,
                    measurements: appState.measurements,
                    records: appState.records,
                    settings: appState.settings,
                    exportDate: new Date().toISOString(),
                    version: STORAGE_VERSION
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `smarttrack_backup_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                this.showNotification('Données exportées !');
            },
            
            importData() {
                const textarea = document.getElementById('import-data');
                try {
                    const data = JSON.parse(textarea.value);
                    
                    if (confirm('Remplacer toutes les données actuelles ? Cette action est irréversible.')) {
                        appState.exercises = data.exercises || [];
                        appState.sessions = data.sessions || [];
                        appState.templates = data.templates || [];
                        appState.measurements = data.measurements || [];
                        appState.records = data.records || {};
                        appState.settings = data.settings || { theme: 'light' };
                        
                        this.saveData();
                        this.closeModal('import-modal');
                        this.applyTheme();
                        render();
                        this.showNotification('Données importées !');
                        textarea.value = '';
                    }
                } catch (e) {
                    this.showNotification('Format JSON invalide');
                }
            },
            
            clearAllData() {
                if (confirm('Effacer TOUTES les données ? Cette action est irréversible !')) {
                    if (confirm('Êtes-vous vraiment sûr ? Toutes vos séances et exercices seront perdus !')) {
                        storage.clear();
                        appState = {
                            currentScreen: 'dashboard',
                            currentSession: null,
                            liveSession: null,
                            editingExercise: null,
                            exercises: [],
                            sessions: [],
                            templates: [],
                            measurements: [],
                            records: {},
                            settings: { theme: 'light' }
                        };
                        render();
                        this.showNotification('Toutes les données ont été effacées');
                    }
                }
            },
            
           loadPredefinedExercises() {
                if (appState.exercises.length > 0) {
                    if (!confirm('Cela va ajouter les nouveaux exercices SmartWorkout (+ échauffement). Continuer ?')) {
                        return;
                    }
                }
                
                const predefinedExercises = [];
                
                // Exercices existants + nouveaux exercices d'échauffement
                Object.keys(PREDEFINED_EXERCISES).forEach(category => {
                    PREDEFINED_EXERCISES[category].forEach(ex => {
                        predefinedExercises.push({
                            id: Date.now() + Math.floor(Math.random() * 10000),
                            name: ex.name,
                            is_unilateral: ex.unilateral,
                            default_rest_time: category === 'echauffement' ? 30 : 90,
                            exercise_type: category === 'echauffement' ? 'bodyweight' : 'elastics',
                            anchor_point: ex.anchor,
                            muscle_group: category,
                            category: category === 'echauffement' ? 'warmup' : 'strength',
                            exercise_mode: ex.timeBase ? 'time' : 'reps',
                            default_duration: ex.timeBase ? 30 : null
                        });
                    });
                });
                
                let added = 0;
                predefinedExercises.forEach(newEx => {
                    const exists = appState.exercises.find(ex =>
                        ex.name === newEx.name && ex.muscle_group === newEx.muscle_group
                    );
                    if (!exists) {
                        appState.exercises.push(newEx);
                        added++;
                    }
                });
                
                this.saveData();
                render();
                this.showNotification(`${added} nouveaux exercices ajoutés (dont ${PREDEFINED_EXERCISES.echauffement ? PREDEFINED_EXERCISES.echauffement.length : 0} d'échauffement) !`);
            },

            // Notifications
            showNotification(message) {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.classList.add('show');
                
                // Style spécial pendant les séances live
                if (appState.liveSession) {
                    notification.classList.add('live-session');
                } else {
                    notification.classList.remove('live-session');
                }
                
                // Réduire le temps pour les notifications de records pendant les séances
                const duration = appState.liveSession ? 1500 : 3000;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.classList.remove('live-session');
                }, duration);
            }
        };

        // === FONCTION DE RENDU UNIQUE ===
        function render() {
            console.log('Rendu pour l\'écran:', appState.currentScreen);
            
            // Mettre à jour la navigation active
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Afficher le bon écran
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(`screen-${appState.currentScreen}`).classList.add('active');
            
            // Rendu spécifique par écran
            switch (appState.currentScreen) {
                case 'dashboard':
                    renderDashboard();
                    document.querySelector('.nav-item').classList.add('active');
                    break;
                case 'preparation':
                    renderPreparation();
                    document.querySelectorAll('.nav-item')[1].classList.add('active');
                    break;
                case 'live':
                    renderLiveSession();
                    break;
                case 'history':
                    renderHistory();
                    document.querySelectorAll('.nav-item')[2].classList.add('active');
                    break;
                case 'stats':
                    renderStats();
                    document.querySelectorAll('.nav-item')[3].classList.add('active');
                    break;
                case 'body':
                    renderBody();
                    document.querySelectorAll('.nav-item')[4].classList.add('active');
                    break;
                case 'exercises':
                    renderExercises();
                    break;
                case 'templates':
                    renderTemplates();
                    break;
                case 'settings':
                    renderSettings();
                    break;
                case 'manual-entry':
                    renderManualEntry();
                    break;
            }
        }

        // === FONCTIONS DE RENDU PAR ÉCRAN ===
        function renderDashboard() {
            // Date actuelle ou mois sélectionné
            if (!appState.calendarDate) {
                appState.calendarDate = new Date();
            }
  
            const currentMonth = appState.calendarDate.getMonth();
            const currentYear = appState.calendarDate.getFullYear();
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            
            // Calendrier mensuel
            const calendarGrid = document.getElementById('calendar-grid');
            const calendarContainer = calendarGrid.parentElement;
            
            // Remplacer le titre et ajouter la navigation
            const titleElement = calendarContainer.querySelector('h3');
            if (titleElement) {
                const monthNames = ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin','Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'];
    
                titleElement.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <button onclick="actions.previousMonth()" class="btn btn-small btn-secondary">←</button>
                        <span>${monthNames[currentMonth]} ${currentYear}</span>
                        <button onclick="actions.nextMonth()" class="btn btn-small btn-secondary">→</button>
                    </div>
                `;
            }
  
            // Vérifier le cache du calendrier
            const calendarCacheKey = { 
                month: currentMonth, 
                year: currentYear, 
                sessionsCount: appState.sessions.length 
            };
            const cachedCalendar = smartCache.get('calendar', calendarCacheKey);

            if (cachedCalendar) {
                console.log('📅 Calendrier récupéré du cache');
                calendarGrid.innerHTML = cachedCalendar;
                return;
            }

            console.log('📅 Génération du calendrier...');
            // Créer le calendrier
            calendarGrid.innerHTML = '';
            calendarGrid.style.gridTemplateColumns = 'repeat(7, 1fr)';
            calendarGrid.style.gap = '4px';
            calendarGrid.style.maxHeight = 'none';
            
            // En-têtes des jours
            const dayHeaders = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.style.cssText = 'text-align: center; font-weight: bold; padding: 8px; font-size: 12px; color: var(--text-secondary);';
                header.textContent = day;
                calendarGrid.appendChild(header);
            });
  
            // Premier jour du mois et nombre de jours
            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const firstDayOfWeek = (firstDay.getDay() + 6) % 7; // Lundi = 0
            const daysInMonth = lastDay.getDate();
            
            // Récupérer les dates des séances
            const sessionDates = new Set(appState.sessions.map(s => s.date));
            
            // Cases vides avant le 1er du mois
            for (let i = 0; i < firstDayOfWeek; i++) {
                const emptyDay = document.createElement('div');
                emptyDay.style.cssText = 'aspect-ratio: 1; border-radius: 8px; opacity: 0.3;';
                calendarGrid.appendChild(emptyDay);
            }
  
            // Jours du mois
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(currentYear, currentMonth, day);
                const dateStr = date.toISOString().split('T')[0];
    
                const dayElement = document.createElement('div');
                dayElement.style.cssText = `
                    aspect-ratio: 1; 
                    border-radius: 8px; 
                    background: var(--border); 
                    opacity: 0.3; 
                    font-size: 14px; 
                    display: flex; 
                    align-items: center; 
                    justify-content: center; 
                    color: var(--text-secondary); 
                    font-weight: 500;
                    min-height: 35px;
                `;
    
                dayElement.textContent = day;
    
                // Jour actuel
                if (dateStr === todayStr) {
                    dayElement.style.border = '2px solid var(--primary)';
                    dayElement.style.fontWeight = 'bold';
                }
    
                // Jour avec séance
                if (sessionDates.has(dateStr)) {
                    dayElement.style.opacity = '1';
                    dayElement.style.background = 'var(--secondary)';
                    dayElement.style.color = 'white';
                }
    
                calendarGrid.appendChild(dayElement);
            }
  
            // Mettre en cache le HTML du calendrier
            smartCache.set('calendar', calendarCacheKey, calendarGrid.innerHTML);

            // Statistiques
            document.getElementById('total-sessions').textContent = appState.sessions.length;
            
            // Calcul de la série actuelle
            let streak = 0;
            const sortedSessions = [...appState.sessions].sort((a, b) => b.date.localeCompare(a.date));
            
            if (sortedSessions.length > 0) {
                let checkDate = new Date();
                const sessionDatesArray = new Set(sortedSessions.map(s => s.date));
                
                for (let i = 0; i < 30; i++) {
                    const dateStr = checkDate.toISOString().split('T')[0];
      
                    if (sessionDatesArray.has(dateStr)) {
                        streak++;
                        checkDate.setDate(checkDate.getDate() - 1);
                    } else {
                        if (i === 0 && dateStr === todayStr) {
                            checkDate.setDate(checkDate.getDate() - 1);
                            continue;
                        }
                        break;
                    }
                }
            }
  
            document.getElementById('current-streak').textContent = streak;
        }

        function renderPreparation() {
            // Initialiser la recherche d'exercices
            actions.initializeExerciseSearch();
            
            // Afficher les exercices planifiés AVEC SECTIONS
            const plannedDiv = document.getElementById('planned-exercises');
            plannedDiv.innerHTML = '';
            
            if (appState.currentSession && appState.currentSession.exercises.length > 0) {
                // Séparer échauffement et entraînement principal
                const warmupExercises = [];
                const mainExercises = [];
                
                appState.currentSession.exercises.forEach((plannedEx, index) => {
                    const exercise = appState.exercises.find(e => e.id === plannedEx.exercise_id);
                    if (exercise) {
                        const exerciseData = { ...plannedEx, exercise, originalIndex: index };
                        if (exercise.muscle_group === 'echauffement' || exercise.category === 'warmup') {
                            warmupExercises.push(exerciseData);
                        } else {
                            mainExercises.push(exerciseData);
                        }
                    }
                });
                
                // Section Échauffement
                if (warmupExercises.length > 0) {
                    const warmupTitle = document.createElement('h4');
                    warmupTitle.textContent = '🔥 Échauffement';
                    warmupTitle.className = 'exercise-section-title warmup';
                    plannedDiv.appendChild(warmupTitle);
                    warmupExercises.forEach((exerciseData, sectionIndex) => {
                        plannedDiv.appendChild(createExerciseItem(exerciseData, sectionIndex, 'warmup'));
                    });
                }
                
                // Section Entraînement Principal
                if (mainExercises.length > 0) {
                    const mainTitle = document.createElement('h4');
                    mainTitle.textContent = '💪 Entraînement Principal';
                    mainTitle.className = 'exercise-section-title main';
                    plannedDiv.appendChild(mainTitle);
                    mainExercises.forEach((exerciseData, sectionIndex) => {
                        plannedDiv.appendChild(createExerciseItem(exerciseData, sectionIndex, 'main'));
                    });
                }
                
                document.getElementById('start-live-btn').style.display = 'block';
                document.getElementById('save-manual-btn').style.display = 'block';
            } else {
                plannedDiv.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">Aucun exercice planifié</p>';
                document.getElementById('start-live-btn').style.display = 'none';
                document.getElementById('save-manual-btn').style.display = 'none';
            }
            
            // Charger les paramètres de repos existants dans les champs
            if (appState.currentSession && appState.currentSession.globalSettings) {
                const restBetweenExercisesInput = document.getElementById('session-rest-between-exercises');
                const restBetweenSetsInput = document.getElementById('session-rest-between-sets');
                if (restBetweenExercisesInput) {
                    restBetweenExercisesInput.value = appState.currentSession.globalSettings.restBetweenExercises || 120;
                }
                if (restBetweenSetsInput) {
                    restBetweenSetsInput.value = appState.currentSession.globalSettings.restBetweenSets || 90;
                }
            }
        }

        function renderLiveSession() {
            const liveContent = document.getElementById('live-content');
            
            // AJOUTEZ CES LIGNES DE DEBUG
            console.log('Live session state:', appState.liveSession);
            console.log('Current session:', appState.currentSession);

            if (!appState.liveSession) {
                liveContent.innerHTML = '<p>Aucune séance en cours</p>';
                return;
            }
            
            const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
            if (!currentExercise) {
                actions.finishLiveSession();
                return;
            }
            
            const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
            
            // Calculer la progression
            const currentExerciseNum = appState.liveSession.currentExerciseIndex + 1;
            const totalExercises = appState.liveSession.exercises.length;
            const progressPercentage = actions.calculateSessionProgress();

            // Générer la barre de progression
            const progressBarHtml = `
                <div style="background: var(--surface); padding: 16px; margin-bottom: 16px; border-radius: 12px; border: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 14px; font-weight: 600; color: var(--text-primary);">Progression de la séance</span>
                        <span style="font-size: 14px; font-weight: 600; color: var(--primary);">${progressPercentage}%</span>
                    </div>
                    <div style="width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden;">
                        <div style="height: 100%; background: var(--primary); width: ${progressPercentage}%; transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px; text-align: center;">
                        Exercice ${currentExerciseNum}/${totalExercises} • ${progressPercentage}% des séries
                    </div>
                </div>
            `;

            // Gérer la phase de préparation avant le premier exercice
            if (appState.liveSession.isPreparing) {
                const firstExercise = exercise;
                
                liveContent.innerHTML = `
                    ${progressBarHtml}
                    <div style="text-align: center; padding: 40px 20px;">
                        <h2 style="margin-bottom: 24px; color: var(--primary);">🏁 Préparation</h2>
                        <div id="countdown-display" style="font-size: 72px; font-weight: bold; color: var(--primary); margin: 24px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                            5
                        </div>
                        <h3 style="margin-bottom: 16px;">Premier exercice :</h3>
                        <div style="font-size: 24px; font-weight: 600; margin: 16px 0; color: var(--text-primary);">
                            ${firstExercise.name}
                        </div>
                        <div style="font-size: 16px; color: var(--text-secondary); background: var(--background); padding: 12px; border-radius: 8px; margin: 16px 0;">
                            Préparez vos élastiques et votre position
                        </div>
                        <div style="font-size: 14px; color: var(--text-secondary);">
                            ${firstExercise.is_unilateral ? '🔄 Exercice unilatéral' : '⚖️ Exercice bilatéral'} • 
                            ${firstExercise.default_rest_time}s de repos par défaut
                        </div>
                    </div>
                `;
                return; // Sortir de la fonction
            }

            if (appState.liveSession.isPaused) {
                liveContent.innerHTML = `
                    ${progressBarHtml}
                    <div style="text-align: center; padding: 40px 20px;">
                        <div style="font-size: 48px; margin-bottom: 24px;">⏸️</div>
                        <h2 style="color: var(--warning);">Séance en pause</h2>
                        <p style="color: var(--text-secondary); margin: 16px 0;">
                            Votre progression est sauvegardée
                        </p>
                        <div style="font-size: 14px; color: var(--text-secondary); margin: 16px 0;">
                            Pause depuis ${Math.floor((Date.now() - appState.liveSession.pauseStartTime) / 1000)}s
                        </div>
                        <button class="btn btn-success btn-full" onclick="actions.resumeLiveSession()">
                            ▶️ Reprendre la séance
                        </button>
                        <button class="btn btn-secondary btn-full" onclick="actions.stopLiveSession()" style="margin-top: 12px;">
                            🏁 Terminer la séance
                        </button>
                    </div>
                `;
                return; // Sortir de la fonction
            }

            if (appState.liveSession.isResting) {
                // Phase de repos - CORRIGER LA LOGIQUE
                const currentExercise = appState.liveSession.exercises[appState.liveSession.currentExerciseIndex];
                const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
                
                // Déterminer si on est entre séries du même exercice ou entre exercices différents
                const isRestBetweenSets = currentExercise.sets.length < currentExercise.planned_sets;
                
                let nextExerciseIndex, nextExercise, isLastExercise;
                if (isRestBetweenSets) {
                    // Repos entre séries du même exercice
                    nextExerciseIndex = appState.liveSession.currentExerciseIndex;
                    nextExercise = exercise;
                    isLastExercise = false;
                } else {
                    // Repos entre exercices - PAS D'INCRÉMENTATION car déjà fait dans nextExercise()
                    nextExerciseIndex = appState.liveSession.currentExerciseIndex;
                    isLastExercise = nextExerciseIndex >= appState.liveSession.exercises.length;
                    
                    if (!isLastExercise && appState.liveSession.exercises[nextExerciseIndex]) {
                        nextExercise = appState.exercises.find(e => e.id === appState.liveSession.exercises[nextExerciseIndex].exercise_id);
                    } else {
                        nextExercise = null;
                    }
                }
                
                // Récupérer les dernières performances du prochain exercice
                let nextExerciseInfo = '';
                if (nextExercise) {
                    let lastPerf;
                    if (isRestBetweenSets) {
                        // Repos entre séries - récupérer la performance de la série suivante de la dernière séance
                        const nextSetNumber = currentExercise.sets.length + 1;
                        lastPerf = actions.getLastPerformanceForSet(currentExercise.exercise_id, nextSetNumber);
                    } else {
                        // Repos entre exercices - récupérer toutes les séries du prochain exercice
                        lastPerf = actions.getAllLastPerformances(nextExercise.id);
                    }
                    if (lastPerf) {
                        let performanceDetails = '';
                        if (lastPerf.sets) {
                            // Affichage de toutes les séries (repos entre exercices)
                            performanceDetails = lastPerf.sets.map(set => {
                                const resistance = set.resistance || 0;
                                const duration = set.duration || 0;
                                const reps = set.reps || 0;
                                return `Série ${set.setNumber}: ${resistance}kg • ${set.mode === 'time' ? `${duration}s` : `${reps} reps`}`;
                            }).join('<br>');
                        } else {
                            // Affichage d'une seule série (repos entre séries du même exercice)
                            const resistance = lastPerf.resistance || 0;
                            const duration = lastPerf.duration || 0;
                            const reps = lastPerf.reps || '0';
                            performanceDetails = `${resistance}kg • ${lastPerf.mode === 'time' ? `${duration}s` : `${reps} reps`}`;
                        }
                        
                        nextExerciseInfo = `
                            <div class="card" style="margin: 16px 0; padding: 16px; background: var(--surface); border: 2px solid var(--primary);">
                                <h4 style="color: var(--primary); margin-bottom: 8px;">🔜 Prochain exercice</h4>
                                <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                                    ${nextExercise.name}
                                </div>
                                <div style="font-size: 14px; color: var(--primary); font-weight: bold; background: var(--background); padding: 8px; border-radius: 8px;">
                                    📊 Dernière fois :<br>${performanceDetails}
                                </div>
                                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                    ${new Date(lastPerf.date).toLocaleDateString('fr-FR')}
                                </div>
                            </div>
                        `;
                    } else {
                        // NOUVEAU CODE : Afficher les conseils de résistance
                        const resistanceAdvice = generateResistanceRecommendations(nextExercise.name);
                        
                        nextExerciseInfo = `
                            <div class="card" style="margin: 16px 0; padding: 16px; background: var(--surface); border: 2px solid var(--primary);">
                                <h4 style="color: var(--primary); margin-bottom: 8px;">🔜 Prochain exercice</h4>
                                <div style="font-size: 20px; font-weight: bold; margin-bottom: 8px;">
                                    ${nextExercise.name}
                                </div>
                                <div style="font-size: 14px; color: var(--text-secondary); background: var(--background); padding: 8px; border-radius: 8px;">
                                    🆕 Premier essai pour cet exercice
                                </div>
                                ${resistanceAdvice}
                            </div>
                        `;
                    }
                } else {
                    nextExerciseInfo = `
                        <div class="card" style="margin: 16px 0; padding: 16px; background: var(--secondary); color: white; text-align: center;">
                            <h4 style="margin-bottom: 8px;">🏁 Dernier exercice terminé !</h4>
                            <div style="font-size: 18px;">Félicitations ! 🎉</div>
                        </div>
                    `;
                }

                liveContent.innerHTML = `
                    ${progressBarHtml}
                    <div class="rest-timer">
                        <h2>Temps de repos</h2>
                        <div class="rest-time">00:00</div>
                        <button class="btn btn-primary btn-full" onclick="actions.skipRest()">
                            ⏭️ Passer le repos
                        </button>
                    </div>
                    
                    <div class="card" style="margin: 16px 0; padding: 12px; background: var(--background);">
                        <h4>✅ ${isRestBetweenSets ? 'Série terminée' : 'Exercice terminé'}</h4>
                        <div style="font-size: 16px; font-weight: bold;">${appState.exercises.find(e => e.id === currentExercise.exercise_id).name}</div>
                        <div style="font-size: 14px; color: var(--text-secondary);">
                            ${isRestBetweenSets ? 
                                `Série ${currentExercise.sets.length} / ${currentExercise.planned_sets} terminée` :
                                `Toutes les séries terminées (${currentExercise.sets.length}/${currentExercise.planned_sets})`
                            }
                        </div>
                    </div>
                    
                    ${nextExerciseInfo}
                `;
            } else {
                // Phase d'exercice
                const setNumber = currentExercise.sets.length + 1;
                
                // MODIFICATION : Utiliser la nouvelle fonction pour gérer tous les modes
                const performanceInputs = actions.generatePerformanceInputs(exercise);
                
                // Récupérer les dernières performances
                const lastPerf = actions.getLastPerformance(exercise.id);

                let perfRecap = '';
                if (lastPerf) {
                    let setsDisplay = '';
                    if (lastPerf.sets && lastPerf.sets.length > 0) {
                        setsDisplay = lastPerf.sets.map((set, index) => {
                            if (set.exercise_mode === 'time') {
                                return `Série ${index + 1}: ${set.duration}s${set.resistance > 0 ? ` - ${set.resistance}kg` : ''}`;
                            } else if (exercise.is_unilateral) {
                                return `Série ${index + 1}: ${set.left_reps}G/${set.right_reps}D - ${set.resistance}kg`;
                            } else {
                                return `Série ${index + 1}: ${set.reps} reps - ${set.resistance}kg`;
                            }
                        }).join(' • ');
                    }
                    
                    perfRecap += `
                        <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                            <h5>🎯 Dernière performance (${lastPerf.totalSets} séries) :</h5>
                            <div style="font-size: 14px;">
                                ${setsDisplay}
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                ${new Date(lastPerf.date).toLocaleDateString('fr-FR')}
                            </div>
                        </div>
                    `;
                }


                // Déterminer ce qui vient après cette série
                const willHaveMoreSets = (currentExercise.sets.length + 1) < currentExercise.planned_sets;
                if (willHaveMoreSets) {
                    // Il reste des séries pour cet exercice
                    perfRecap += `
                        <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                            <h5>🔜 Après cette série :</h5>
                            <div style="font-size: 14px;">
                                Série ${currentExercise.sets.length + 2} de ${exercise.name}
                            </div>
                        </div>
                    `;
                } else {
                    // C'est la dernière série de cet exercice, afficher le prochain exercice
                    const nextExerciseIndex = appState.liveSession.currentExerciseIndex + 1;
                    const nextExercise = nextExerciseIndex < appState.liveSession.exercises.length ?
                        appState.exercises.find(e => e.id === appState.liveSession.exercises[nextExerciseIndex].exercise_id) : null;
                    const nextPerf = nextExercise ? actions.getLastPerformance(nextExercise.id) : null;
                    
                    if (nextPerf && nextExercise) {
                        const resistance = nextPerf.resistance || 0;
                        const duration = nextPerf.duration || 0;
                        const reps = nextPerf.reps || '0';
                        perfRecap += `
                            <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                                <h5>🔜 Prochain exercice : ${nextExercise.name}</h5>
                                <div style="font-size: 14px;">
                                    Dernière fois : ${resistance}kg • ${nextPerf.mode === 'time' ? `${duration}s` : `${reps} reps`}
                                </div>
                            </div>
                        `;
                    } else if (nextExercise) {
                        perfRecap += `
                            <div class="card" style="margin: 12px 0; padding: 12px; background: var(--background);">
                                <h5>🔜 Prochain exercice : ${nextExercise.name}</h5>
                                <div style="font-size: 14px;">
                                    🆕 Premier essai pour cet exercice
                                </div>
                            </div>
                        `;
                    } else {
                        perfRecap += `
                            <div class="card" style="margin: 12px 0; padding: 12px; background: var(--secondary); color: white;">
                                <h5>🏁 Dernière série du dernier exercice !</h5>
                                <div style="font-size: 14px;">Félicitations, vous terminez ! 🎉</div>
                            </div>
                        `;
                    }
                }

                liveContent.innerHTML = `
                    ${progressBarHtml}
                    <div class="current-exercise">
                        <div class="exercise-name">${exercise.name}</div>
                        <div class="set-counter">Série ${setNumber} / ${currentExercise.planned_sets}</div>
                    </div>
                    ${perfRecap}
                    ${performanceInputs}
                    
                    <div class="input-group">
                        <label>Type de série</label>
                        <select id="set-type" class="select">
                            <option value="work">Travail</option>
                            <option value="warmup">Échauffement</option>
                            <option value="dropset">Série dégressif</option>
                            <option value="failure">Jusqu'à l'échec</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-success btn-full" onclick="actions.validateSet()">
                        ✅ Valider la série
                    </button>
                    
                    <button class="btn btn-secondary btn-full" onclick="actions.nextExercise()">
                        ➡️ Exercice suivant
                    </button>
                `;
            }
        }

        function renderHistory() {
            const sessionsList = document.getElementById('sessions-list');
            const historyCount = document.getElementById('history-count');
            
            historyCount.textContent = appState.sessions.length;
            sessionsList.innerHTML = '';
            
            const sortedSessions = [...appState.sessions].sort((a, b) => b.date.localeCompare(a.date));
            
            sortedSessions.forEach(session => {
                const sessionDiv = document.createElement('div');
                sessionDiv.className = 'card';
                
                const date = new Date(session.date);
                const formattedDate = date.toLocaleDateString('fr-FR', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                let exercisesHtml = '';
                session.exercises.forEach(sessionEx => {
                    const exercise = appState.exercises.find(e => e.id === sessionEx.exercise_id);
                    if (exercise) {
                        exercisesHtml += `
                            <div style="margin: 8px 0; padding: 8px; background: var(--background); border-radius: 8px;">
                                <strong>${exercise.name}</strong> (${sessionEx.sets.length} séries)
                                <div style="font-size: 14px; color: var(--text-secondary);">
                                    ${sessionEx.sets.map(set => {
                                        if (set.exercise_mode === 'time') {
                                            // Exercice en mode temps - ne pas afficher les résistances si elles sont à 0
                                            if (exercise.is_unilateral) {
                                                let leftResistance, rightResistance;
                                                if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                                    leftResistance = set.total_resistance.left || 0;
                                                    rightResistance = set.total_resistance.right || 0;
                                                } else {
                                                    leftResistance = set.total_resistance || 0;
                                                    rightResistance = set.total_resistance || 0;
                                                }
                                            
                                                // Afficher les résistances seulement si elles sont > 0
                                                if (leftResistance > 0 || rightResistance > 0) {
                                                    return `${set.duration || 0}s - ${leftResistance}kg (G) | ${rightResistance}kg (D)`;
                                                } else {
                                                    return `${set.duration || 0}s`;
                                                }
                                            } else {
                                                const resistance = set.total_resistance || 0;
                                                // Afficher la résistance seulement si elle est > 0
                                                if (resistance > 0) {
                                                    return `${set.duration || 0}s - ${resistance}kg`;
                                                } else {
                                                    return `${set.duration || 0}s`;
                                                }
                                            }
                                        } else {
                                            // Exercice en mode répétitions (logique existante)
                                            if (exercise.is_unilateral) {
                                                let leftResistance, rightResistance;
                                                if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                                    leftResistance = set.total_resistance.left || 0;
                                                    rightResistance = set.total_resistance.right || 0;
                                                } else {
                                                    leftResistance = set.total_resistance || 0;
                                                    rightResistance = set.total_resistance || 0;
                                                }
                                                return `${set.left_reps || 0} reps (G) | ${set.right_reps || 0} reps (D) - ${leftResistance}kg (G) | ${rightResistance}kg (D)`;
                                            } else {
                                                return `${set.reps || 0} reps - ${set.total_resistance || 0}kg`;
                                            }
                                        }
                                    }).join(' • ')}
                                </div>
                            </div>
                        `;
                    }
                });
                
                // Calculer la durée totale de la séance
                const sessionDuration = session.endTime && session.startTime ? 
                    Math.floor((session.endTime - session.startTime) / 1000 / 60) : 0;

                // Calculer le volume total et le temps total d'exercice
                let totalVolume = 0;
                let totalExerciseTime = 0;
                session.exercises.forEach(ex => {
                    const sessionExercise = appState.exercises.find(e => e.id === ex.exercise_id);
                    ex.sets.forEach(set => {
                        // Calculer le temps d'exercice selon le mode
                        if (set.exercise_mode === 'time' && set.duration) {
                            // Exercice en mode temps
                            totalExerciseTime += set.duration;
                        } else if (set.exercise_mode === 'reps' || !set.exercise_mode) {
                            // Exercice en mode répétitions - estimer le temps
                            let reps = 0;
                            if (sessionExercise && sessionExercise.is_unilateral) {
                                reps = (set.left_reps || 0) + (set.right_reps || 0);
                            } else {
                                reps = set.reps || 0;
                            }
                            // Estimer 2 secondes par répétition
                            totalExerciseTime += (reps * 2);
                        }
                    
                        // Calculer le volume pour les exercices en répétitions
                        if (set.exercise_mode !== 'time' && set.type === 'work') {
                            let resistance = 0;
                            let reps = 0;
                    
                            if (sessionExercise && sessionExercise.is_unilateral) {
                                // Exercice unilatéral - gérer les résistances par côté
                                if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                    resistance = (set.total_resistance.left || 0) + (set.total_resistance.right || 0);
                                } else {
                                    // Compatibilité avec l'ancien format
                                    resistance = (set.total_resistance || 0) * 2;
                                }
                                reps = (set.left_reps || 0) + (set.right_reps || 0);
                            } else {
                                // Exercice bilatéral
                                resistance = set.total_resistance || 0;
                                reps = set.reps || 0;
                            }
                    
                            totalVolume += (resistance * reps);
                        }
                    });
                });

                sessionDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div style="flex: 1;">
                            <h3>${formattedDate}</h3>
                            <div style="font-size: 14px; color: var(--text-secondary); margin: 4px 0;">
                                ⏱️ ${sessionDuration}min • 📊 ${Math.round(totalVolume)}kg volume
                                ${totalExerciseTime > 0 ? ` • 🔥 ${Math.floor(totalExerciseTime / 60)}min ${totalExerciseTime % 60}s actif` : ''}
                                ${session.difficulty ? ` • ${session.difficulty === 'Facile' ? '😊' : session.difficulty === 'Normale' ? '💪' : '🔥'} ${session.difficulty}` : ''}
                                ${session.globalSettings ? ` • Repos: ${session.globalSettings.restBetweenExercises}s/${session.globalSettings.restBetweenSets}s` : ''}
                            </div>
                            ${session.notes ? `<p style="color: var(--text-secondary); margin: 8px 0;">${session.notes}</p>` : ''}
                            <details style="margin-top: 12px;">
                                <summary style="cursor: pointer; font-weight: 500;">Voir les détails</summary>
                                <div style="margin-top: 12px;">${exercisesHtml}</div>
                            </details>
                        </div>
                        <div style="display: flex; gap: 8px; margin-left: 12px;">
                            <button class="btn btn-small btn-secondary" onclick="actions.editSession(${session.id})" title="Modifier la séance">
                                ✏️
                            </button>
                            <button class="btn btn-small btn-danger" onclick="actions.deleteSession(${session.id})" title="Supprimer la séance">
                                🗑️
                            </button>
                        </div>
                    </div>
                `;
                
                sessionsList.appendChild(sessionDiv);
            });
            
            if (sortedSessions.length === 0) {
                sessionsList.innerHTML = '<div class="card"><p style="text-align: center; color: var(--text-secondary);">Aucune séance enregistrée</p></div>';
            }
        }

        function renderStats() {
            const statsContent = document.getElementById('stats-content');
            
            // STATISTIQUES GÉNÉRALES (sans select)
            const generalStats = actions.calculateGeneralStats();
            let generalStatsHtml = `
                <div class="card">
                    <h3>📊 Statistiques générales</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.sessionsThisWeek}</div>
                            <div class="stat-label">Séances cette semaine</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.totalVolumeThisWeek}kg</div>
                            <div class="stat-label">Volume cette semaine</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.sessionsThisMonth}</div>
                            <div class="stat-label">Séances ce mois</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.totalVolumeThisMonth}kg</div>
                            <div class="stat-label">Volume ce mois</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.averageSessionDuration}min</div>
                            <div class="stat-label">Durée moyenne</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${generalStats.totalSessions}</div>
                            <div class="stat-label">Total séances</div>
                        </div>
                    </div>
                    <div style="margin: 16px 0;">
                        <h4>🏆 Records personnels récents</h4>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${generalStats.recentRecords.length > 0 ?
                                generalStats.recentRecords.map(record => `
                                    <div style="padding: 8px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between;">
                                        <div>
                                            <strong>${record.exerciseName}</strong>
                                            <div style="font-size: 14px; color: var(--text-secondary);">
                                                ${record.type === 'max_weight' ? 'Poids Max' :
                                                record.type === 'max_reps' ? 'Reps Max' : '1RM Estimé'}:
                                                ${record.value}${record.type === 'max_reps' ? '' : 'kg'}
                                            </div>
                                        </div>
                                        <div style="font-size: 12px; color: var(--text-secondary);">
                                            ${new Date(record.date).toLocaleDateString('fr-FR')}
                                        </div>
                                    </div>
                                `).join('') :
                                '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun record récent</p>'
                            }
                        </div>
                    </div>
                </div>
            `;

            // STATISTIQUES PAR EXERCICE - Créer d'abord le HTML avec le select vide
            let exerciseStatsHtml = `
                <div class="card">
                    <h3>📈 Statistiques par exercice</h3>
                    <div class="input-group">
                        <label>Sélectionner un exercice</label>
                        <select id="stats-exercise-select" class="select" onchange="actions.updateStats(this.value)">
                            <option value="">Choisir un exercice...</option>
                        </select>
                    </div>
                </div>
            `;

            // Afficher d'abord le HTML de base
            statsContent.innerHTML = generalStatsHtml + exerciseStatsHtml;

            // MAINTENANT remplir le select après qu'il soit dans le DOM
            const exerciseSelect = document.getElementById('stats-exercise-select');
            if (exerciseSelect) {
                // Grouper les exercices par groupes musculaires
                const groupedExercises = {};
                appState.exercises.forEach(exercise => {
                    const group = exercise.muscle_group || 'autres';
                    if (!groupedExercises[group]) {
                        groupedExercises[group] = [];
                    }
                    groupedExercises[group].push(exercise);
                });

                // Ordre d'affichage des catégories
                const groupOrder = ['echauffement', 'biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
                groupOrder.forEach(group => {
                    if (groupedExercises[group] && groupedExercises[group].length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                        
                        // Trier les exercices par nom dans chaque groupe
                        groupedExercises[group].sort((a, b) => a.name.localeCompare(b.name));
                        groupedExercises[group].forEach(exercise => {
                            const option = document.createElement('option');
                            option.value = exercise.id;
                            // Ajouter l'indicateur de mode
                            const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' :
                                exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                            option.textContent = `${modeIcon} ${exercise.name}`;
                            optgroup.appendChild(option);
                        });
                        exerciseSelect.appendChild(optgroup);
                    }
                });

                // Conserver la valeur sélectionnée si elle existe
                const currentValue = exerciseSelect.dataset.currentValue;
                if (currentValue) {
                    exerciseSelect.value = currentValue;
                }
            }

            // Afficher les stats de l'exercice sélectionné
            const selectedExerciseId = parseInt(exerciseSelect?.value || '0');
            if (selectedExerciseId) {
                const exercise = appState.exercises.find(e => e.id === selectedExerciseId);
                const records = appState.records[selectedExerciseId] || [];
                
                // Calculer les records actuels
                const maxWeight = actions.getCurrentRecord(selectedExerciseId, 'max_weight');
                const maxReps = actions.getCurrentRecord(selectedExerciseId, 'max_reps');
                const max1RM = actions.getCurrentRecord(selectedExerciseId, 'max_1rm');
                
                // Calculer le volume max
                let maxVolume = 0;
                appState.sessions.forEach(session => {
                    const sessionExercise = session.exercises.find(e => e.exercise_id === selectedExerciseId);
                    if (sessionExercise) {
                        let sessionVolume = 0;
                        sessionExercise.sets.forEach(set => {
                            if (set.type === 'work') {
                                const resistance = set.total_resistance || 0;
                                if (exercise.is_unilateral) {
                                    const leftReps = set.left_reps || 0;
                                    const rightReps = set.right_reps || 0;
                                    sessionVolume += (leftReps + rightReps) * resistance;
                                } else {
                                    const reps = set.reps || 0;
                                    sessionVolume += reps * resistance;
                                }
                            }
                        });
                        maxVolume = Math.max(maxVolume, sessionVolume);
                    }
                });

                // Calculer le temps max pour les exercices en mode temps
                let maxTime = 0;
                let hasTimeMode = false;
                appState.sessions.forEach(session => {
                    const sessionExercise = session.exercises.find(e => e.exercise_id === selectedExerciseId);
                    if (sessionExercise) {
                        sessionExercise.sets.forEach(set => {
                            if (set.exercise_mode === 'time' && set.duration) {
                                hasTimeMode = true;
                                maxTime = Math.max(maxTime, set.duration);
                            }
                        });
                    }
                });

                // Générer les cartes de statistiques selon le mode de l'exercice
                let statsCardsHtml = '';
                if (hasTimeMode) {
                    // Pour les exercices utilisés en mode temps
                    statsCardsHtml = `
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value">${maxTime}s</div>
                                <div class="stat-label">Temps Max Tenu</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${maxWeight}kg</div>
                                <div class="stat-label">Poids Max</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${maxVolume}kg</div>
                                <div class="stat-label">Volume Max</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${Math.round((maxTime * maxWeight) / 10) / 10}pts</div>
                                <div class="stat-label">Score Temps×Poids</div>
                            </div>
                        </div>
                    `;
                } else {
                    // Pour les exercices utilisés uniquement en mode répétitions
                    statsCardsHtml = `
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-value">${maxWeight}kg</div>
                                <div class="stat-label">Poids Max</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${maxReps}</div>
                                <div class="stat-label">Reps Max</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${maxVolume}kg</div>
                                <div class="stat-label">Volume Max</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value">${max1RM.toFixed(1)}kg</div>
                                <div class="stat-label">1RM Estimé</div>
                            </div>
                        </div>
                    `;
                }

                // Récupérer les dernières séries effectuées
                const lastSets = [];
                const sessionsWithExercise = appState.sessions
                    .filter(session => session.exercises.some(ex => ex.exercise_id === selectedExerciseId))
                    .sort((a, b) => b.date.localeCompare(a.date));

                // Collecter les dernières séries jusqu'à 5 maximum
                for (const session of sessionsWithExercise) {
                    const exerciseData = session.exercises.find(ex => ex.exercise_id === selectedExerciseId);
                    if (exerciseData && exerciseData.sets.length > 0) {
                        const workSets = exerciseData.sets.filter(set => set.type === 'work');
                        for (const set of workSets) {
                            if (lastSets.length < 5) {
                                lastSets.push({
                                    date: session.date,
                                    ...set
                                });
                            }
                        }
                    }
                    if (lastSets.length >= 5) break;
                }

                // Générer l'HTML des dernières séries
                let lastSetsHtml = '';
                if (lastSets.length > 0) {
                    lastSetsHtml = `
                        <div class="card">
                            <h3>🔄 Dernières séries effectuées</h3>
                            <div style="max-height: 200px; overflow-y: auto;">
                                ${lastSets.map((set, index) => {
                                    const date = new Date(set.date).toLocaleDateString('fr-FR', {
                                        day: 'numeric',
                                        month: 'short'
                                    });
                                    let setInfo = '';
                                    if (set.exercise_mode === 'time') {
                                        if (exercise.is_unilateral) {
                                            let leftResistance, rightResistance;
                                            if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                                leftResistance = set.total_resistance.left || 0;
                                                rightResistance = set.total_resistance.right || 0;
                                            } else {
                                                leftResistance = set.total_resistance || 0;
                                                rightResistance = set.total_resistance || 0;
                                            }
                                            setInfo = leftResistance > 0 || rightResistance > 0 ?
                                                `${set.duration || 0}s - ${leftResistance}kg (G) | ${rightResistance}kg (D)` :
                                                `${set.duration || 0}s`;
                                        } else {
                                            const resistance = set.total_resistance || 0;
                                            setInfo = resistance > 0 ?
                                                `${set.duration || 0}s - ${resistance}kg` :
                                                `${set.duration || 0}s`;
                                        }
                                    } else {
                                        if (exercise.is_unilateral) {
                                            let leftResistance, rightResistance;
                                            if (typeof set.total_resistance === 'object' && set.total_resistance.left !== undefined) {
                                                leftResistance = set.total_resistance.left || 0;
                                                rightResistance = set.total_resistance.right || 0;
                                            } else {
                                                leftResistance = set.total_resistance || 0;
                                                rightResistance = set.total_resistance || 0;
                                            }
                                            setInfo = `${set.left_reps || 0} reps (G) | ${set.right_reps || 0} reps (D) - ${leftResistance}kg (G) | ${rightResistance}kg (D)`;
                                        } else {
                                            setInfo = `${set.reps || 0} reps - ${set.total_resistance || 0}kg`;
                                        }
                                    }
                                    return `
                                        <div style="padding: 8px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                                            <div>
                                                <div style="font-weight: 500;">${setInfo}</div>
                                            </div>
                                            <div style="font-size: 12px; color: var(--text-secondary);">${date}</div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }

                // Ajouter les statistiques détaillées de l'exercice
                const detailedStatsHtml = `
                    ${statsCardsHtml}
                    ${lastSetsHtml}
                    <div class="card">
                        <h3>Évolution des performances</h3>
                        <div class="chart-container" id="stats-chart">
                            ${actions.generateSimpleChart(selectedExerciseId, exercise.name)}
                        </div>
                    </div>
                    <div class="card">
                        <h3>Historique des records</h3>
                        <div id="records-history">
                            ${records.length > 0 ?
                                records.map(record => `
                                    <div style="padding: 8px; border-bottom: 1px solid var(--border);">
                                        <strong>${new Date(record.date).toLocaleDateString('fr-FR')}</strong> -
                                        ${record.type === 'max_weight' ? 'Poids Max' :
                                        record.type === 'max_reps' ? 'Reps Max' :
                                        record.type === 'max_time' ? 'Temps Max' : '1RM Estimé'}:
                                        <span style="color: var(--primary);">${record.value}${record.type === 'max_reps' ? '' : record.type === 'max_time' ? 's' : 'kg'}</span>
                                    </div>
                                `).join('')
                                : '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun record enregistré</p>'
                            }
                        </div>
                    </div>
                `;

                // Ajouter les statistiques détaillées après les statistiques générales
                statsContent.innerHTML = generalStatsHtml + exerciseStatsHtml + detailedStatsHtml;
                
                // Re-remplir le select car le DOM a été modifié
                const newExerciseSelect = document.getElementById('stats-exercise-select');
                if (newExerciseSelect) {
                    newExerciseSelect.innerHTML = '<option value="">Choisir un exercice...</option>';
                    
                    // Re-créer les options
                    groupOrder.forEach(group => {
                        if (groupedExercises[group] && groupedExercises[group].length > 0) {
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                            
                            groupedExercises[group].forEach(exercise => {
                                const option = document.createElement('option');
                                option.value = exercise.id;
                                const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' :
                                    exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                                option.textContent = `${modeIcon} ${exercise.name}`;
                                optgroup.appendChild(option);
                            });
                            newExerciseSelect.appendChild(optgroup);
                        }
                    });
                    
                    // Restaurer la valeur sélectionnée
                    newExerciseSelect.value = selectedExerciseId;
                }
            } else {
                // Aucun exercice sélectionné
                const noSelectionHtml = `
                    <p style="text-align: center; color: var(--text-secondary); padding: 40px;">
                        Sélectionnez un exercice pour voir les statistiques détaillées
                    </p>
                `;
                statsContent.innerHTML = generalStatsHtml + exerciseStatsHtml + noSelectionHtml;
            }
        }

        function renderBody() {
            const measurementsList = document.getElementById('measurements-list');
            
            // Définir la date par défaut à aujourd'hui
            const measurementDate = document.getElementById('measurement-date');
            if (!measurementDate.value) {
                measurementDate.value = new Date().toISOString().split('T')[0];
            }
            
            measurementsList.innerHTML = '';
            
            // Mettre à jour le graphique
            const chartContainer = document.querySelector('#screen-body .chart-container');
            if (chartContainer) {
                chartContainer.innerHTML = actions.generateMeasurementsChart();
            }
            
            const sortedMeasurements = [...appState.measurements].sort((a, b) => b.date.localeCompare(a.date));
            
            // Calculer l'IMC actuel (dernière mesure)
            const latestMeasurement = sortedMeasurements.length > 0 ? sortedMeasurements[0] : null;
            let currentImcCard = '';

            if (latestMeasurement && latestMeasurement.height > 0 && latestMeasurement.weight > 0) {
                let imc, imcCategory;
            
                if (latestMeasurement.imc && latestMeasurement.imc > 0) {
                    // IMC déjà calculé
                    imc = latestMeasurement.imc;
                    imcCategory = latestMeasurement.imcCategory;
                } else {
                    // Calculer l'IMC
                    const heightInMeters = latestMeasurement.height / 100;
                    imc = latestMeasurement.weight / (heightInMeters * heightInMeters);
                    imc = Math.round(imc * 10) / 10;
                    
                    if (imc < 18.5) {
                        imcCategory = 'Insuffisance pondérale';
                    } else if (imc < 25) {
                        imcCategory = 'Poids normal';
                    } else if (imc < 30) {
                        imcCategory = 'Surpoids';
                    } else if (imc < 35) {
                        imcCategory = 'Obésité modérée';
                    } else if (imc < 40) {
                        imcCategory = 'Obésité sévère';
                    } else {
                        imcCategory = 'Obésité morbide';
                    }
                }
            
                const imcColor = imc < 18.5 ? '#FF9500' : 
                                 imc < 25 ? '#34C759' : 
                                 imc < 30 ? '#FF9500' : '#FF3B30';
                
                const imcIcon = imc < 18.5 ? '⬇️' : 
                                imc < 25 ? '✅' : 
                                imc < 30 ? '⚠️' : '🔴';
            
                currentImcCard = `
                    <div class="card">
                        <h3>📏 IMC Actuel</h3>
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 48px; font-weight: bold; color: ${imcColor}; margin-bottom: 8px;">
                                ${imc}
                            </div>
                            <div style="font-size: 18px; font-weight: 600; color: ${imcColor}; margin-bottom: 16px;">
                                ${imcIcon} ${imcCategory}
                            </div>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                Taille: ${latestMeasurement.height}cm • Poids: ${latestMeasurement.weight}kg
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
                                Mesuré le ${new Date(latestMeasurement.date).toLocaleDateString('fr-FR')}
                            </div>
                        </div>
                
                        <div style="font-size: 12px; color: var(--text-secondary); background: var(--background); padding: 12px; border-radius: 8px; margin-top: 16px;">
                            <strong>Référence IMC :</strong><br>
                            • &lt; 18.5 : Insuffisance pondérale<br>
                            • 18.5 - 24.9 : Poids normal<br>
                            • 25 - 29.9 : Surpoids<br>
                            • ≥ 30 : Obésité
                        </div>
                    </div>
                `;
            }

            if (sortedMeasurements.length > 0) {
                const listDiv = document.createElement('div');
                listDiv.className = 'card';
                listDiv.innerHTML = '<h3>Historique des mensurations</h3>';
                
                sortedMeasurements.forEach(measurement => {
                    const measurementDiv = document.createElement('div');
                    measurementDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--border);';
                    
                    let details = [];
                    let imcInfo = '';

                    // Afficher les mensurations de base
                    if (measurement.height > 0) details.push('Taille: ' + measurement.height + 'cm');
                    if (measurement.weight > 0) details.push(measurement.weight + 'kg');

                    // Calculer et afficher l'IMC s'il n'est pas déjà stocké
                    if (measurement.imc && measurement.imc > 0) {
                        // IMC déjà calculé et stocké
                        const imcColor = measurement.imc < 18.5 ? '#FF9500' : 
                                         measurement.imc < 25 ? '#34C759' : 
                                         measurement.imc < 30 ? '#FF9500' : '#FF3B30';
                        imcInfo = `<div style="font-size: 14px; margin-top: 4px; padding: 4px 8px; background: ${imcColor}20; border-radius: 4px; color: ${imcColor}; font-weight: 600;">
                            IMC: ${measurement.imc} • ${measurement.imcCategory}
                        </div>`;
                    } else if (measurement.height > 0 && measurement.weight > 0) {
                        // Calculer l'IMC à la volée pour les anciennes données
                        const heightInMeters = measurement.height / 100;
                        const imc = measurement.weight / (heightInMeters * heightInMeters);
                        const roundedImc = Math.round(imc * 10) / 10;
                    
                        let imcCategory = '';
                        if (imc < 18.5) {
                            imcCategory = 'Insuffisance pondérale';
                        } else if (imc < 25) {
                            imcCategory = 'Poids normal';
                        } else if (imc < 30) {
                            imcCategory = 'Surpoids';
                        } else if (imc < 35) {
                            imcCategory = 'Obésité modérée';
                        } else if (imc < 40) {
                            imcCategory = 'Obésité sévère';
                        } else {
                            imcCategory = 'Obésité morbide';
                        }
                    
                        const imcColor = imc < 18.5 ? '#FF9500' : 
                                         imc < 25 ? '#34C759' : 
                                         imc < 30 ? '#FF9500' : '#FF3B30';
                        imcInfo = `<div style="font-size: 14px; margin-top: 4px; padding: 4px 8px; background: ${imcColor}20; border-radius: 4px; color: ${imcColor}; font-weight: 600;">
                            IMC: ${roundedImc} • ${imcCategory}
                        </div>`;
                    }

                    // Autres mensurations
                    if (measurement.waist > 0) details.push('Tour taille: ' + measurement.waist + 'cm');
                    if (measurement.chest > 0) details.push('Poitrine: ' + measurement.chest + 'cm');
                    if (measurement.arm > 0) details.push('Bras: ' + measurement.arm + 'cm');
                    if (measurement.thigh > 0) details.push('Cuisse: ' + measurement.thigh + 'cm');
                    
                    measurementDiv.innerHTML = `
                        <div>
                            <strong>${new Date(measurement.date).toLocaleDateString('fr-FR')}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${details.join(' • ')}
                            </div>
                            ${imcInfo}
                        </div>
                        <button class="btn btn-small btn-danger" onclick="actions.deleteMeasurement(${measurement.id})">🗑️</button>
                    `;
                    listDiv.appendChild(measurementDiv);
                });
                
                // Ajouter la carte IMC si elle existe
                if (currentImcCard) {
                    const imcDiv = document.createElement('div');
                    imcDiv.innerHTML = currentImcCard;
                    measurementsList.appendChild(imcDiv);
                }

                measurementsList.appendChild(listDiv);
            } else {
                measurementsList.innerHTML = '<div class="card"><p style="text-align: center; color: var(--text-secondary);">Aucune mensuration enregistrée</p></div>';
            }
        }

        function renderExercises() {
            const exercisesList = document.getElementById('exercises-list');
            const formTitle = document.getElementById('exercise-form-title');
            const saveBtn = document.getElementById('save-exercise-btn');
            const cancelBtn = document.getElementById('cancel-exercise-btn');
            
            // Mise à jour du formulaire selon le mode (création/édition)
            if (appState.editingExercise) {
                formTitle.textContent = 'Modifier l\'exercice';
                saveBtn.textContent = '💾 Sauvegarder';
                cancelBtn.style.display = 'block';
            } else {
                formTitle.textContent = 'Nouvel exercice';
                saveBtn.textContent = '➕ Ajouter l\'exercice';
                cancelBtn.style.display = 'none';
            }
            
            // Liste des exercices
            exercisesList.innerHTML = '';
            
            if (appState.exercises.length > 0) {
                // Grouper les exercices par groupe musculaire
                const groupedExercises = {};
                appState.exercises.forEach(exercise => {
                    const group = exercise.muscle_group || 'autres';
                    if (!groupedExercises[group]) {
                        groupedExercises[group] = [];
                    }
                    groupedExercises[group].push(exercise);
                });
                
                // Afficher par groupes
                const groupOrder = ['biceps', 'triceps', 'epaules', 'dos', 'pectoraux', 'jambes', 'autres'];
                groupOrder.forEach(group => {
                    if (groupedExercises[group] && groupedExercises[group].length > 0) {
                        const groupTitle = document.createElement('h4');
                        groupTitle.textContent = `${group.charAt(0).toUpperCase() + group.slice(1)} (${groupedExercises[group].length})`;
                        groupTitle.style.cssText = 'margin: 20px 0 10px 0; color: var(--primary); border-bottom: 1px solid var(--border); padding-bottom: 8px;';
                        exercisesList.appendChild(groupTitle);
                        
                        groupedExercises[group].forEach(exercise => {
                            const anchorText = {
                                'none': 'Sans ancrage',
                                'door-middle': 'Porte (milieu)',
                                'door-high': 'Porte (haut)',
                                'door-low': 'Porte (bas)',
                                'floor': 'Sol/Pieds',
                                'body': 'Corps',
                                'external': 'Extérieur'
                            };
                            
                            const div = document.createElement('div');
                            div.className = 'exercise-item';
                            div.innerHTML = `
                                <div>
                                    <strong>${exercise.name}</strong>
                                    <div style="font-size: 14px; color: var(--text-secondary);">
                                        ${exercise.is_unilateral ? 'Unilatéral' : 'Bilatéral'} • ${exercise.default_rest_time}s repos • ${anchorText[exercise.anchor_point] || 'Non défini'}
                                    </div>
                                </div>
                                <div class="exercise-actions">
                                    <button class="btn btn-small btn-secondary" onclick="actions.editExercise(${exercise.id})">✏️</button>
                                    <button class="btn btn-small btn-danger" onclick="actions.deleteExercise(${exercise.id})">🗑️</button>
                                </div>
                            `;
                            exercisesList.appendChild(div);
                        });
                    }
                });
            } else {
                exercisesList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun exercice créé</p>';
            }
        }

        function renderTemplates() {
            const templatesList = document.getElementById('templates-list');
            const checkboxContainer = document.getElementById('template-exercises-checkboxes');

            // NOUVELLE INTERFACE DE CRÉATION DE MODÈLE
            checkboxContainer.innerHTML = `
                <div style="margin-bottom: 16px;">
                    <button class="btn btn-secondary btn-full" onclick="actions.showExerciseSelector()" id="show-exercise-selector-btn">
                        ➕ Ajouter des exercices au modèle
                    </button>
                </div>
                
                <div id="selected-exercises-container" style="margin: 16px 0;">
                    <h4>Exercices sélectionnés :</h4>
                    <div id="template-selected-exercises" style="min-height: 50px; padding: 16px; border: 2px dashed var(--border); border-radius: 8px; background: var(--background);">
                        <p style="text-align: center; color: var(--text-secondary);">Aucun exercice sélectionné</p>
                    </div>
                </div>
            `;

            // Initialiser la liste des exercices sélectionnés si elle existe
            if (appState.templateInCreation) {
                actions.renderSelectedExercises();
            }

            // Afficher les modèles existants avec les nouvelles informations
            templatesList.innerHTML = '';
            if (appState.templates.length > 0) {
                appState.templates.forEach(template => {
                    const div = document.createElement('div');
                    div.className = 'exercise-item';
                
                    // Construire la liste des exercices du modèle avec les nouvelles informations
                    let exercisesHtml = '';
                    if (template.exercises && template.exercises.length > 0) {
                        exercisesHtml = template.exercises.map((exData, index) => {
                            const exercise = appState.exercises.find(e => e.id === exData.exerciseId);
                            if (exercise) {
                                const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' : 
                                                exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                                return `${index + 1}. ${modeIcon} ${exercise.name} (${exData.plannedSets} séries)`;
                            }
                            return null;
                        }).filter(name => name).join(', ');
                    } else {
                        // Compatibilité avec l'ancien format
                        exercisesHtml = (template.exerciseIds || [])
                            .map(id => {
                                const exercise = appState.exercises.find(e => e.id === id);
                                if (exercise) {
                                    const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' : 
                                                    exercise.exercise_mode === 'both' ? '🔄' : '🔢';
                                    return `${modeIcon} ${exercise.name}`;
                                }
                                return null;
                            })
                            .filter(name => name)
                            .join(', ');
                    }

                    // Afficher les paramètres globaux s'ils existent
                    let settingsHtml = '';
                    if (template.globalSettings) {
                        settingsHtml = `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                            Repos: ${template.globalSettings.restBetweenExercises}s (exercices) • ${template.globalSettings.restBetweenSets}s (séries)
                        </div>`;
                    }

                    div.innerHTML = `
                        <div>
                            <strong>${template.name}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${exercisesHtml || 'Aucun exercice'}
                            </div>
                            ${settingsHtml}
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-small btn-secondary" onclick="actions.editTemplate(${template.id})">✏️</button>
                            <button class="btn btn-small btn-danger" onclick="actions.deleteTemplate(${template.id})">🗑️</button>
                        </div>
                    `;
                    templatesList.appendChild(div);
                });
            } else {
                templatesList.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun modèle créé</p>';
            }
        }    

        function renderSettings() {
            // Le thème est déjà appliqué via applyTheme()
        }

        function renderManualEntry() {
            const content = document.getElementById('manual-entry-content');
            if (!appState.manualSession) {
                content.innerHTML = '<p>Aucune séance en cours</p>';
                return;
            }

            const currentExercise = appState.manualSession.exercises[appState.manualSession.currentExerciseIndex];
            if (!currentExercise) {
                actions.finishManualSession();
                return;
            }

            const exercise = appState.exercises.find(e => e.id === currentExercise.exercise_id);
            const performanceInputs = actions.generatePerformanceInputs(exercise, 'manual-');

            // Afficher les séries déjà saisies
            let setsHtml = '';
            if (currentExercise.sets.length > 0) {
                setsHtml = `
                    <div class="card">
                        <h4>Séries effectuées</h4>
                        ${currentExercise.sets.map((set, index) => {
                            if (exercise.is_unilateral) {
                                return `<div>Série ${index + 1}: ${set.left_reps || 0} reps (G) | ${set.right_reps || 0} reps (D) - ${set.total_resistance || 0}kg</div>`;
                            } else {
                                return `<div>Série ${index + 1}: ${set.reps || 0} reps - ${set.total_resistance || 0}kg</div>`;
                            }
                        }).join('')}
                    </div>
                `;
            }

            content.innerHTML = `
                <div class="current-exercise">
                    <div class="exercise-name">${exercise.name}</div>
                    <div class="set-counter">Série ${currentExercise.sets.length + 1}</div>
                    <div style="color: var(--text-secondary);">Exercice ${appState.manualSession.currentExerciseIndex + 1} / ${appState.manualSession.exercises.length}</div>
                </div>
                ${setsHtml}
                ${performanceInputs}
                <div class="input-group">
                    <label>Type de série</label>
                    <select id="manual-set-type" class="select">
                        <option value="work">Travail</option>
                        <option value="warmup">Échauffement</option>
                        <option value="dropset">Série dégressif</option>
                        <option value="failure">Jusqu'à l'échec</option>
                    </select>
                </div>
                <button class="btn btn-success btn-full" onclick="actions.saveManualSet()">
                    ✅ Ajouter cette série
                </button>
                <button class="btn btn-primary btn-full" onclick="actions.nextManualExercise()">
                    ➡️ Exercice suivant
                </button>
                <button class="btn btn-secondary btn-full" onclick="actions.finishManualSession()">
                    🏁 Terminer la séance
                </button>
            `;
        }

        // === FONCTIONS UTILITAIRES ===
        actions.renderTemplatesModal = function() {
            const modalContent = document.getElementById('templates-modal-content');
            modalContent.innerHTML = '';

            // Forcer le rechargement des modèles depuis le stockage
            appState.templates = storage.load('templates', []);

            if (appState.templates.length > 0) {
                appState.templates.forEach(template => {
                    const div = document.createElement('div');
                    div.className = 'exercise-item';
                    div.style.cursor = 'pointer';
                    div.onclick = () => actions.loadTemplate(template.id);
                    
                    let exerciseNames = '';
                    if (template.exercises && template.exercises.length > 0) {
                        // Nouveau format
                        exerciseNames = template.exercises.map(exData => {
                            const exercise = appState.exercises.find(e => e.id === exData.exerciseId);
                            return exercise ? exercise.name : 'Exercice supprimé';
                        }).join(', ');
                    } else {
                        // Ancien format
                        exerciseNames = (template.exerciseIds || [])
                            .map(id => appState.exercises.find(e => e.id === id)?.name)
                            .filter(name => name)
                            .join(', ');
                    }
                
                    div.innerHTML = `
                        <div>
                            <strong>${template.name}</strong>
                            <div style="font-size: 14px; color: var(--text-secondary);">
                                ${exerciseNames || 'Aucun exercice'}
                            </div>
                        </div>
                        <div>👆</div>
                    `;
                    modalContent.appendChild(div);
                });
            } else {
            modalContent.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 20px;">Aucun modèle disponible</p>';
            }
        };

        actions.deleteSession = function(sessionId) {
            if (confirm('Supprimer cette séance ?')) {
                appState.sessions = appState.sessions.filter(s => s.id !== sessionId);
                this.saveData();
                render();
                this.showNotification('Séance supprimée');
            }
        };

        // Édition des séances
        actions.editSession = function(sessionId) {
            const session = appState.sessions.find(s => s.id === sessionId);
            if (!session) {
                this.showNotification('Séance introuvable');
                return;
            }
            
            appState.editingSession = { ...session }; // Copie pour éviter les modifications directes
            this.renderEditSessionModal();
            document.getElementById('edit-session-modal').classList.add('active');
        };

        actions.renderEditSessionModal = function() {
            const content = document.getElementById('edit-session-content');
            const session = appState.editingSession;
            
            let exercisesHtml = '';
            session.exercises.forEach((sessionEx, exerciseIndex) => {
                const exercise = appState.exercises.find(e => e.id === sessionEx.exercise_id);
                if (!exercise) return;
                
                let setsHtml = '';
                sessionEx.sets.forEach((set, setIndex) => {
                    setsHtml += this.renderEditableSet(set, exercise, exerciseIndex, setIndex);
                });
                
                exercisesHtml += `
                    <div class="card" style="margin-bottom: 16px;">
                        <h4>${exercise.name}</h4>
                        <div style="margin-bottom: 12px;">
                            <button class="btn btn-small btn-secondary" onclick="actions.addSetToExercise(${exerciseIndex})">
                                ➕ Ajouter une série
                            </button>
                        </div>
                        ${setsHtml}
                    </div>
                `;
            });
            
            content.innerHTML = `
                <div class="input-group">
                    <label>Date de la séance</label>
                    <input type="date" id="edit-session-date" class="input" value="${session.date}">
                </div>
                
                <div class="input-group">
                    <label>Notes de séance</label>
                    <textarea id="edit-session-notes" class="textarea" placeholder="Notes optionnelles...">${session.notes || ''}</textarea>
                </div>
                
                <div class="input-group" ${session.difficulty ? '' : 'style="display: none;"'}>
                    <label>Difficulté ressentie</label>
                    <select id="edit-session-difficulty" class="select">
                        <option value="">Non définie</option>
                        <option value="Facile" ${session.difficulty === 'Facile' ? 'selected' : ''}>😊 Facile</option>
                        <option value="Normale" ${session.difficulty === 'Normale' ? 'selected' : ''}>💪 Normale</option>
                        <option value="Difficile" ${session.difficulty === 'Difficile' ? 'selected' : ''}>🔥 Difficile</option>
                    </select>
                </div>
                
                <h3>Exercices et performances</h3>
                ${exercisesHtml}
                
                <div style="display: flex; gap: 12px; margin-top: 24px;">
                    <button class="btn btn-success" onclick="actions.saveSessionEdits()" style="flex: 1;">
                        💾 Sauvegarder les modifications
                    </button>
                    <button class="btn btn-secondary" onclick="actions.cancelSessionEdit()" style="flex: 1;">
                        ❌ Annuler
                    </button>
                </div>
            `;
        };

        actions.renderEditableSet = function(set, exercise, exerciseIndex, setIndex) {
            const setId = `exercise-${exerciseIndex}-set-${setIndex}`;
            
            let performanceInputs = '';
            if (set.exercise_mode === 'time') {
                performanceInputs = `
                    <div class="input-group">
                        <label>Durée (secondes)</label>
                        <input type="number" id="${setId}-duration" class="input" value="${set.duration || 0}" min="0" max="600">
                    </div>
                `;
            } else {
                if (exercise.is_unilateral) {
                    performanceInputs = `
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div class="input-group">
                                <label>Reps Gauche</label>
                                <input type="number" id="${setId}-left-reps" class="input" value="${set.left_reps || 0}" min="0">
                            </div>
                            <div class="input-group">
                                <label>Reps Droite</label>
                                <input type="number" id="${setId}-right-reps" class="input" value="${set.right_reps || 0}" min="0">
                            </div>
                        </div>
                    `;
                } else {
                    performanceInputs = `
                        <div class="input-group">
                            <label>Répétitions</label>
                            <input type="number" id="${setId}-reps" class="input" value="${set.reps || 0}" min="0">
                        </div>
                    `;
                }
            }
            
            // Gestion de la résistance (simplifiée pour l'édition)
            let resistanceInput = '';
            if (exercise.exercise_type === 'elastics') {
                const resistance = exercise.is_unilateral ? 
                    (typeof set.total_resistance === 'object' ? 
                        (set.total_resistance.left || 0) + (set.total_resistance.right || 0) : 
                        (set.total_resistance || 0) * 2) :
                    (set.total_resistance || 0);
                
                resistanceInput = `
                    <div class="input-group">
                        <label>Résistance totale (kg)</label>
                        <input type="number" id="${setId}-resistance" class="input" value="${resistance}" min="0" step="0.5">
                    </div>
                `;
            }
            
            return `
                <div class="card" style="margin: 8px 0; padding: 12px; background: var(--background);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h5>Série ${setIndex + 1}</h5>
                        <button class="btn btn-small btn-danger" onclick="actions.removeSetFromExercise(${exerciseIndex}, ${setIndex})" title="Supprimer cette série">
                            🗑️
                        </button>
                    </div>
                
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                        ${performanceInputs}
                        ${resistanceInput}
                        <div class="input-group">
                            <label>Type</label>
                            <select id="${setId}-type" class="select">
                                <option value="work" ${set.type === 'work' ? 'selected' : ''}>Travail</option>
                                <option value="warmup" ${set.type === 'warmup' ? 'selected' : ''}>Échauffement</option>
                                <option value="dropset" ${set.type === 'dropset' ? 'selected' : ''}>Dégressif</option>
                                <option value="failure" ${set.type === 'failure' ? 'selected' : ''}>Échec</option>
                            </select>
                        </div>
                    </div>
                </div>
            `;
        };

        actions.addSetToExercise = function(exerciseIndex) {
            const session = appState.editingSession;
            const sessionExercise = session.exercises[exerciseIndex];
            const exercise = appState.exercises.find(e => e.id === sessionExercise.exercise_id);
            
            // Créer une nouvelle série basée sur le type d'exercice
            const newSet = {
                type: 'work',
                exercise_mode: exercise.exercise_mode || 'reps'
            };
            
            if (exercise.is_unilateral) {
                newSet.left_reps = 0;
                newSet.right_reps = 0;
            } else {
                newSet.reps = 0;
            }
            
            if (exercise.exercise_mode === 'time') {
                newSet.duration = exercise.default_duration || 30;
            }
            
            newSet.total_resistance = 0;
            
            sessionExercise.sets.push(newSet);
            this.renderEditSessionModal();
        };

        actions.removeSetFromExercise = function(exerciseIndex, setIndex) {
            if (confirm('Supprimer cette série ?')) {
                appState.editingSession.exercises[exerciseIndex].sets.splice(setIndex, 1);
                this.renderEditSessionModal();
            }
        };

        actions.saveSessionEdits = function() {
            const session = appState.editingSession;
            
            // Récupérer les données du formulaire
            session.date = document.getElementById('edit-session-date').value;
            session.notes = document.getElementById('edit-session-notes').value;
            
            const difficultySelect = document.getElementById('edit-session-difficulty');
            if (difficultySelect) {
                session.difficulty = difficultySelect.value || null;
            }
            
            // Récupérer toutes les modifications de performances
            session.exercises.forEach((sessionEx, exerciseIndex) => {
                const exercise = appState.exercises.find(e => e.id === sessionEx.exercise_id);
                
                sessionEx.sets.forEach((set, setIndex) => {
                    const setId = `exercise-${exerciseIndex}-set-${setIndex}`;
                
                    // Type de série
                    const typeInput = document.getElementById(`${setId}-type`);
                    if (typeInput) set.type = typeInput.value;
                
                    // Performances selon le mode
                    if (set.exercise_mode === 'time') {
                        const durationInput = document.getElementById(`${setId}-duration`);
                        if (durationInput) set.duration = parseInt(durationInput.value) || 0;
                    } else {
                        if (exercise.is_unilateral) {
                            const leftRepsInput = document.getElementById(`${setId}-left-reps`);
                            const rightRepsInput = document.getElementById(`${setId}-right-reps`);
                            if (leftRepsInput) set.left_reps = parseInt(leftRepsInput.value) || 0;
                            if (rightRepsInput) set.right_reps = parseInt(rightRepsInput.value) || 0;
                        } else {
                            const repsInput = document.getElementById(`${setId}-reps`);
                            if (repsInput) set.reps = parseInt(repsInput.value) || 0;
                        }
                    }
                
                    // Résistance
                    const resistanceInput = document.getElementById(`${setId}-resistance`);
                    if (resistanceInput) {
                        const totalResistance = parseFloat(resistanceInput.value) || 0;
                        if (exercise.is_unilateral) {
                            // Pour les exercices unilatéraux, diviser équitablement
                            set.total_resistance = {
                                left: totalResistance / 2,
                                right: totalResistance / 2
                            };
                        } else {
                            set.total_resistance = totalResistance;
                        }
                    }
                });
            });
            
            // Sauvegarder dans l'état principal
            const sessionIndex = appState.sessions.findIndex(s => s.id === session.id);
            if (sessionIndex !== -1) {
                appState.sessions[sessionIndex] = session;
                this.saveData();
                this.closeModal('edit-session-modal');
                render();
                this.showNotification('✅ Séance modifiée avec succès !');
            }
        };

        actions.cancelSessionEdit = function() {
            appState.editingSession = null;
            this.closeModal('edit-session-modal');
        };

        // Initialisation de la recherche d'exercices
        actions.initializeExerciseSearch = function() {
            const searchInput = document.getElementById('exercise-search');
            const resultsContainer = document.getElementById('exercise-search-results');
            const historyContainer = document.getElementById('search-history');
            
            if (!searchInput) return;
            
            let currentSelection = -1;
            let currentResults = [];
            
            // Charger l'historique
            smartSearch.loadHistory();
            this.updateSearchHistory();
            
            // Événement de saisie avec debouncing
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                currentSelection = -1;
                
                if (query.length === 0) {
                    resultsContainer.style.display = 'none';
                    historyContainer.style.display = searchHistory.length > 0 ? 'block' : 'none';
                    return;
                }
                
                historyContainer.style.display = 'none';
                
                // Utiliser le debouncing pour éviter trop d'appels
                debounceManager.debounce(() => {
                    currentResults = smartSearch.search(query);
                    this.displaySearchResults(currentResults, query);
                }, 200, 'search');
            });
        
            // Événement focus - afficher la liste complète ou l'historique
            searchInput.addEventListener('focus', () => {
                if (!searchInput.value) {
                    if (searchHistory.length > 0) {
                        historyContainer.style.display = 'block';
                    } else {
                        // Afficher tous les exercices si pas d'historique
                        currentResults = smartSearch.search('');
                        this.displaySearchResults(currentResults, '');
                    }
                }
            });
        
            // Événement blur - masquer les résultats (avec délai pour permettre les clics)
            searchInput.addEventListener('blur', () => {
                setTimeout(() => {
                    resultsContainer.style.display = 'none';
                    historyContainer.style.display = 'none';
                }, 200);
            });
        
            // Navigation au clavier
            searchInput.addEventListener('keydown', (e) => {
                if (resultsContainer.style.display === 'none') return;
                
                switch(e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        currentSelection = Math.min(currentSelection + 1, currentResults.length - 1);
                        this.highlightResult(currentSelection);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        currentSelection = Math.max(currentSelection - 1, -1);
                        this.highlightResult(currentSelection);
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (currentSelection >= 0 && currentResults[currentSelection]) {
                            this.selectExercise(currentResults[currentSelection]);
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        resultsContainer.style.display = 'none';
                        searchInput.blur();
                        break;
                }
            });
        };

        actions.displaySearchResults = function(results, query) {
            const resultsContainer = document.getElementById('exercise-search-results');
            
            if (results.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="search-no-results">
                        Aucun exercice trouvé pour "${query}"
                        <div style="margin-top: 8px; font-size: 11px;">
                            💡 Essayez avec des mots-clés comme "biceps", "squat", "porte"...
                        </div>
                    </div>
                `;
                resultsContainer.style.display = 'block';
                return;
            }
        
            let html = '';
            results.forEach((exercise, index) => {
                const modeIcon = exercise.exercise_mode === 'time' ? '⏱️' :
                                 exercise.exercise_mode === 'both' ? '🔄' : '🔢';
            
                const anchorText = {
                    'none': 'Sans ancrage',
                    'door-middle': 'Porte (milieu)',
                    'door-high': 'Porte (haut)', 
                    'door-low': 'Porte (bas)',
                    'floor': 'Sol/Pieds',
                    'body': 'Corps',
                    'external': 'Extérieur'
                };
            
                html += `
                    <div class="search-result-item" onclick="actions.selectExercise({id: ${exercise.id}, name: '${exercise.name.replace(/'/g, "\\'")}'})" data-index="${index}">
                        <div>
                            <div class="search-result-name">${modeIcon} ${exercise.name}</div>
                            <div class="search-result-details">
                                ${exercise.muscle_group} • ${exercise.is_unilateral ? 'Unilatéral' : 'Bilatéral'} • ${anchorText[exercise.anchor_point] || 'Non défini'}
                            </div>
                        </div>
                        <div style="font-size: 20px;">+</div>
                    </div>
                `;
            });
        
            resultsContainer.innerHTML = html;
            resultsContainer.style.display = 'block';
        };

        actions.highlightResult = function(index) {
            const items = document.querySelectorAll('.search-result-item');
            items.forEach(item => item.classList.remove('highlighted'));
            
            if (index >= 0 && items[index]) {
                items[index].classList.add('highlighted');
                items[index].scrollIntoView({ block: 'nearest' });
            }
        };

        actions.selectExercise = function(exercise) {
            // Ajouter l'exercice à la session
            if (!appState.currentSession) {
                appState.currentSession = {
                    date: new Date().toISOString().split('T')[0],
                    notes: '',
                    exercises: [],
                    globalSettings: {
                        restBetweenExercises: 120,
                        restBetweenSets: 90
                    }
                };
            }
            
            // Vérifier si l'exercice n'est pas déjà dans la liste
            const exists = appState.currentSession.exercises.find(e => e.exercise_id === exercise.id);
            if (exists) {
                this.showNotification('Cet exercice est déjà dans la liste');
                return;
            }
            
            const fullExercise = appState.exercises.find(e => e.id === exercise.id);
            if (!fullExercise) {
                this.showNotification('Exercice introuvable');
                return;
            }
            
            appState.currentSession.exercises.push({
                exercise_id: exercise.id,
                planned_sets: 3,
                rest_time: fullExercise.default_rest_time || 90,
                duration: fullExercise?.default_duration || 30,
                sets: []
            });
            
            // Réinitialiser la recherche
            const searchInput = document.getElementById('exercise-search');
            const resultsContainer = document.getElementById('exercise-search-results');
            if (searchInput) searchInput.value = '';
            if (resultsContainer) resultsContainer.style.display = 'none';
            
            render();
            this.showNotification(`Exercice "${exercise.name}" ajouté !`);
        };

        actions.updateSearchHistory = function() {
            const historyContainer = document.getElementById('search-history');
            if (!historyContainer) return;
            
            if (searchHistory.length === 0) {
                historyContainer.style.display = 'none';
                return;
            }
            
            let html = '<div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Recherches récentes :</div>';
            searchHistory.slice(0, 5).forEach(item => {
                html += `
                    <span class="search-history-item" onclick="actions.useHistorySearch('${item.query}')">
                        ${item.query}
                    </span>
                `;
            });
            
            html += `
                <span class="search-history-item" onclick="actions.clearSearchHistory()" style="background: var(--danger); color: white;">
                    ✕ Effacer
                </span>
            `;
            
            historyContainer.innerHTML = html;
        };

        actions.useHistorySearch = function(query) {
            const searchInput = document.getElementById('exercise-search');
            if (searchInput) {
                searchInput.value = query;
                searchInput.focus();
                // Déclencher la recherche
                const event = new Event('input', { bubbles: true });
                searchInput.dispatchEvent(event);
            }
        };

        actions.clearSearchHistory = function() {
            smartSearch.clearHistory();
            this.updateSearchHistory();
            this.showNotification('Historique de recherche effacé');
        };

        // === INITIALISATION ===
        document.addEventListener('DOMContentLoaded', () => {
            console.log('SmartTrack - Initialisation de l\'application');
            actions.init();
        
            // === GESTION DU BOUTON RETOUR ===
            window.addEventListener('popstate', (event) => {
                event.preventDefault();
                const canGoBack = navigateBack();
                if (!canGoBack) {
                    // Si on est sur le dashboard et qu'il n'y a nulle part où aller, on peut quitter
                    if (appState.currentScreen === 'dashboard') {
                        // Demander confirmation avant de quitter
                        if (confirm('Voulez-vous vraiment quitter SmartTrack ?')) {
                            window.history.back();
                        } else {
                            // Rester dans l'application
                            window.history.pushState(null, '', window.location.href);
                        }
                    }
                }
            });

            // Intercepter aussi la tentative de fermeture/actualisation
            window.addEventListener('beforeunload', (event) => {
                // Ne demander confirmation que s'il y a une séance en cours
                if (appState.liveSession || appState.manualSession) {
                    event.preventDefault();
                    event.returnValue = 'Une séance est en cours. Êtes-vous sûr de vouloir quitter ?';
                    return event.returnValue;
                }
            });

            // Ajouter un état initial à l'historique du navigateur
            window.history.pushState(null, '', window.location.href);
        });

        // Fermeture des modals en cliquant à l'extérieur
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('active');
            }
        });
    
    
    </script>
    <script>
    // Enregistrement du Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            console.log('SmartTrack SW: Enregistré avec succès');
            
            // Écouter les mises à jour
            registration.addEventListener('updatefound', () => {
              const newWorker = registration.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // Nouvelle version disponible
                  console.log('SmartTrack: Nouvelle version disponible');
                  // Optionnel: afficher une notification à l'utilisateur
                }
              });
            });
          })
          .catch(error => {
            console.log('SmartTrack SW: Échec d\'enregistrement', error);
          });
      });
    }
  </script>
</body>
</html>
